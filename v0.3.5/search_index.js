var documenterSearchIndex = {"docs":
[{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/incompressible_elasticity.jl\"","category":"page"},{"location":"examples/incompressible_elasticity/#Incompressible-Elasticity","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: incompressible_elasticity.ipynb.","category":"page"},{"location":"examples/incompressible_elasticity/#Introduction","page":"Incompressible Elasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Mixed elements can be used to overcome locking when the material becomes incompressible. However, for an element to be stable, it needs to fulfill the LBB condition. In this example we will consider two different element formulations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"linear displacement with linear pressure approximation (does not fulfill LBB)\nquadratic displacement with linear pressure approximation (does fulfill LBB)","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The quadratic/linear element is also known as the Taylor-Hood element. We will consider Cook's Membrane with an applied traction on the right hand side.","category":"page"},{"location":"examples/incompressible_elasticity/#Commented-program","page":"Incompressible Elasticity","title":"Commented program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing BlockArrays, SparseArrays, LinearAlgebra","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"First we generate a simple grid, specifying the 4 corners of Cooks membrane.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Next we define a function to set up our cell- and facevalues.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We create a DofHandler, with two fields, :u and :p, with possibly different interpolations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We also need to add Dirichlet boundary conditions on the \"clamped\" faceset. We specify a homogeneous Dirichlet bc on the displacement field, :u.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The material is linear elastic, which is here specified by the shear and bulk moduli","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct LinearElasticity{T}\n    G::T\n    K::T\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Now to the assembling of the stiffness matrix. This mixed formulation leads to a blocked element matrix. Since Ferrite does not force us to use any particular matrix type we will use a PseudoBlockArray from BlockArrays.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function doassemble(cellvalues_u::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim},\n                    facevalues_u::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, mp::LinearElasticity) where {dim}\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    # traction vector\n    t = Vec{2}((0.0, 1/16))\n    # cache ɛdev outside the element routine to avoid some unnecessary allocations\n    ɛdev = [zero(SymmetricTensor{2, dim}) for i in 1:getnbasefunctions(cellvalues_u)]\n\n    for cell in CellIterator(dh)\n        fill!(ke, 0)\n        fill!(fe, 0)\n        assemble_up!(ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n        assemble!(assembler, celldofs(cell), fe, ke)\n    end\n\n    return K, f\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The element routine integrates the local stiffness and force vector for all elements. Since the problem results in a symmetric matrix we choose to only assemble the lower part, and then symmetrize it after the loop over the quadrature points.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function assemble_up!(Ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    u▄, p▄ = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    @inbounds for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ɛdev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            divδu = shape_divergence(cellvalues_u, q_point, i)\n            δu = shape_value(cellvalues_u, q_point, i)\n            for j in 1:i\n                Ke[BlockIndex((u▄, u▄), (i, j))] += 2 * mp.G * ɛdev[i] ⊡ ɛdev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδu = shape_divergence(cellvalues_u, q_point, j)\n                Ke[BlockIndex((p▄, u▄), (i, j))] += -δp * divδu * dΩ\n            end\n            for j in 1:i\n                p = shape_value(cellvalues_p, q_point, j)\n                Ke[BlockIndex((p▄, p▄), (i, j))] += - 1/mp.K * δp * p * dΩ\n            end\n\n        end\n    end\n\n    symmetrize_lower!(Ke)\n\n    # We integrate the Neumann boundary using the facevalues.\n    # We loop over all the faces in the cell, then check if the face\n    # is in our `\"traction\"` faceset.\n    @inbounds for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"traction\")\n            reinit!(facevalues_u, cell, face)\n            for q_point in 1:getnquadpoints(facevalues_u)\n                dΓ = getdetJdV(facevalues_u, q_point)\n                for i in 1:n_basefuncs_u\n                    δu = shape_value(facevalues_u, q_point, i)\n                    fe[i] += (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Now we have constructed all the necessary components, we just need a function to put it all together.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function solve(ν, interpolation_u, interpolation_p)\n    # material\n    Emod = 1.\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    mp = LinearElasticity(Gmod, Kmod)\n\n    # grid, dofhandler, boundary condition\n    n = 50\n    grid = create_cook_grid(n, n)\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    dbc = create_bc(dh)\n\n    # cellvalues\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # assembly and solve\n    K = create_sparsity_pattern(dh);\n    K, f = doassemble(cellvalues_u, cellvalues_p, facevalues_u, K, grid, dh, mp);\n    apply!(K, f, dbc)\n    u = Symmetric(K) \\ f;\n\n    # export\n    filename = \"cook_\" * (isa(interpolation_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\") *\n                         \"_linear\"\n    vtk_grid(filename, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\n    return u\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"All that is left is to solve the problem. We choose a value of Poissons ratio that is near incompressibility – ν = 05 – and thus expect the linear/linear approximation to return garbage, and the quadratic/linear approximation to be stable.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"linear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\n\nu1 = solve(0.4999999, linear, linear)\nu2 = solve(0.4999999, quadratic, linear);\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#incompressible_elasticity-plain-program","page":"Incompressible Elasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Here follows a version of the program without any comments. The file is also available here: incompressible_elasticity.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing BlockArrays, SparseArrays, LinearAlgebra\n\nfunction create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\n\nstruct LinearElasticity{T}\n    G::T\n    K::T\nend\n\nfunction doassemble(cellvalues_u::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim},\n                    facevalues_u::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, mp::LinearElasticity) where {dim}\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    # traction vector\n    t = Vec{2}((0.0, 1/16))\n    # cache ɛdev outside the element routine to avoid some unnecessary allocations\n    ɛdev = [zero(SymmetricTensor{2, dim}) for i in 1:getnbasefunctions(cellvalues_u)]\n\n    for cell in CellIterator(dh)\n        fill!(ke, 0)\n        fill!(fe, 0)\n        assemble_up!(ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n        assemble!(assembler, celldofs(cell), fe, ke)\n    end\n\n    return K, f\nend;\n\nfunction assemble_up!(Ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    u▄, p▄ = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    @inbounds for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ɛdev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            divδu = shape_divergence(cellvalues_u, q_point, i)\n            δu = shape_value(cellvalues_u, q_point, i)\n            for j in 1:i\n                Ke[BlockIndex((u▄, u▄), (i, j))] += 2 * mp.G * ɛdev[i] ⊡ ɛdev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδu = shape_divergence(cellvalues_u, q_point, j)\n                Ke[BlockIndex((p▄, u▄), (i, j))] += -δp * divδu * dΩ\n            end\n            for j in 1:i\n                p = shape_value(cellvalues_p, q_point, j)\n                Ke[BlockIndex((p▄, p▄), (i, j))] += - 1/mp.K * δp * p * dΩ\n            end\n\n        end\n    end\n\n    symmetrize_lower!(Ke)\n\n    # We integrate the Neumann boundary using the facevalues.\n    # We loop over all the faces in the cell, then check if the face\n    # is in our `\"traction\"` faceset.\n    @inbounds for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"traction\")\n            reinit!(facevalues_u, cell, face)\n            for q_point in 1:getnquadpoints(facevalues_u)\n                dΓ = getdetJdV(facevalues_u, q_point)\n                for i in 1:n_basefuncs_u\n                    δu = shape_value(facevalues_u, q_point, i)\n                    fe[i] += (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nfunction solve(ν, interpolation_u, interpolation_p)\n    # material\n    Emod = 1.\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    mp = LinearElasticity(Gmod, Kmod)\n\n    # grid, dofhandler, boundary condition\n    n = 50\n    grid = create_cook_grid(n, n)\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    dbc = create_bc(dh)\n\n    # cellvalues\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # assembly and solve\n    K = create_sparsity_pattern(dh);\n    K, f = doassemble(cellvalues_u, cellvalues_p, facevalues_u, K, grid, dh, mp);\n    apply!(K, f, dbc)\n    u = Symmetric(K) \\ f;\n\n    # export\n    filename = \"cook_\" * (isa(interpolation_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\") *\n                         \"_linear\"\n    vtk_grid(filename, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\n    return u\nend\n\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\n\nu1 = solve(0.4999999, linear, linear)\nu2 = solve(0.4999999, quadratic, linear);","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/postprocessing.jl\"","category":"page"},{"location":"examples/postprocessing/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"(Image: )","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Figure 1: Heat flux computed from the solution to the heat equation on the unit square, see previous example: Heat equation.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"tip: Tip\nThis example is also available as a Jupyter notebook: postprocessing.ipynb.","category":"page"},{"location":"examples/postprocessing/#Introduction","page":"Postprocessing","title":"Introduction","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"After running a simulation, we usually want to visualize the results in different ways. The L2Projector and the PointEvalHandler build a pipeline for doing so. With the L2Projector, integration point quantities can be projected to the nodes. The PointEvalHandler enables evaluation of the finite element approximated function in any coordinate in the domain. Thus with the combination of both functionalities, both nodal quantities and integration point quantities can be evaluated in any coordinate, allowing for example cut-planes through 3D structures or cut-lines through 2D-structures.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"This example continues from the Heat equation example, where the temperature field was determined on a square domain. In this example, we first compute the heat flux in each integration point (based on the solved temperature field) and then we do an L2-projection of the fluxes to the nodes of the mesh. By doing this, we can more easily visualize integration points quantities. Finally, we visualize the temperature field and the heat fluxes along a cut-line.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"The L2-projection is defined as follows: Find projection q(boldsymbolx) in L_2(Omega) such that","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"int v q  mathrmdOmega = int v d  mathrmdOmega quad forall v in L_2(Omega)","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"where d is the quadrature data to project. Since the flux is a vector the projection function will be solved with multiple right hand sides, e.g. with d = q_x and d = q_y for this 2D problem.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Ferrite has functionality for doing much of this automatically, as displayed in the code below. In particular L2Projector for assembling the left hand side, and project for assembling the right hand sides and solving for the projection.","category":"page"},{"location":"examples/postprocessing/#Implementation","page":"Postprocessing","title":"Implementation","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Start by simply running the Heat equation example to solve the problem","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"include(\"heat_equation.jl\");\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Next we define a function that computes the heat flux for each integration point in the domain. Fourier's law is adopted, where the conductivity tensor is assumed to be isotropic with unit conductivity lambda = 1  q = - nabla u, where u is the temperature.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"function compute_heat_fluxes(cellvalues::CellScalarValues{dim,T}, dh::DofHandler, a) where {dim,T}\n\n    n = getnbasefunctions(cellvalues)\n    cell_dofs = zeros(Int, n)\n    nqp = getnquadpoints(cellvalues)\n\n    # Allocate storage for the fluxes to store\n    q = [Vec{2,T}[] for _ in 1:getncells(dh.grid)]\n\n    for (cell_num, cell) in enumerate(CellIterator(dh))\n        q_cell = q[cell_num]\n        celldofs!(cell_dofs, dh, cell_num)\n        aᵉ = a[cell_dofs]\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:nqp\n            q_qp = - function_gradient(cellvalues, q_point, aᵉ)\n            push!(q_cell, q_qp)\n        end\n    end\n    return q\nend\nnothing # hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Now call the function to get all the fluxes.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"q_gp = compute_heat_fluxes(cellvalues, dh, u);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Next, create an L2Projector using the same interpolation as was used to approximate the temperature field. On instantiation, the projector assembles the coefficient matrix M and computes the Cholesky factorization of it. By doing so, the projector can be reused without having to invert M every time.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"projector = L2Projector(ip, grid);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Project the integration point values to the nodal values","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"q_projected = project(projector, q_gp, qr; project_to_nodes=false); # TODO: this should be default.\nnothing #hide","category":"page"},{"location":"examples/postprocessing/#Exporting-to-VTK","page":"Postprocessing","title":"Exporting to VTK","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"To visualize the heat flux, we export the projected field q_projected to a VTK-file, which can be viewed in e.g. ParaView. The result is also visualized in Figure 1.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"vtk_grid(\"heat_equation_flux\", grid) do vtk\n    vtk_point_data(vtk, projector, q_projected, \"q\")\nend;\nnothing #hide","category":"page"},{"location":"examples/postprocessing/#Point-Evaluation","page":"Postprocessing","title":"Point Evaluation","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"(Image: )","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Figure 2: Visualization of the cut line where we want to compute the temperature and heat flux.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Consider a cut-line through the domain like the black line in Figure 2 above. We will evaluate the temperature and the heat flux distribution along a horizontal line.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"points = [Vec((x, 0.75)) for x in range(-1.0, 1.0, length=101)];\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"First, we need to generate a PointEvalHandler. This will find and store the cells containing the input points.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"ph = PointEvalHandler(grid, points);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"After the L2-Projection, the heat fluxes q_projected are stored in the DoF-ordering determined by the projector's internal DoFHandler, so to evaluate the flux q at our points we give the PointEvalHandler, the L2Projector and the values q_projected.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"q_points = get_point_values(ph, projector, q_projected);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"We can also extract the field values, here the temperature, right away from the result vector of the simulation, that is stored in u. These values are stored in the order of our initial DofHandler so the input is not the PointEvalHandler, the original DofHandler, the dof-vector u, and (optionally for single-field problems) the name of the field. from the L2Projection, the values are stored in the order of the degrees of freedom.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"u_points = Ferrite.get_point_values(ph, dh, u, :u);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Now, we can plot the temperature and flux values with the help of any plotting library, e.g. Plots.jl. To do this, we need to import the package:","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"import Plots","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Firstly, we are going to plot the temperature values along the given line.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Plots.plot(getindex.(points,1), u_points, xlabel=\"x (coordinate)\", ylabel=\"u (temperature)\", label=nothing)","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Figure 3: Temperature along the cut line from Figure 2.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Secondly, the horizontal heat flux (i.e. the first component of the heat flux vector) is plotted.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Plots.plot(getindex.(points,1), getindex.(q_points,1), xlabel=\"x (coordinate)\", ylabel=\"q_x (flux in x-direction)\", label=nothing)","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Figure 4: x-component of the flux along the cut line from Figure 2.","category":"page"},{"location":"examples/postprocessing/#postprocessing-plain-program","page":"Postprocessing","title":"Plain program","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Here follows a version of the program without any comments. The file is also available here: postprocessing.jl.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"include(\"heat_equation.jl\");\n\nfunction compute_heat_fluxes(cellvalues::CellScalarValues{dim,T}, dh::DofHandler, a) where {dim,T}\n\n    n = getnbasefunctions(cellvalues)\n    cell_dofs = zeros(Int, n)\n    nqp = getnquadpoints(cellvalues)\n\n    # Allocate storage for the fluxes to store\n    q = [Vec{2,T}[] for _ in 1:getncells(dh.grid)]\n\n    for (cell_num, cell) in enumerate(CellIterator(dh))\n        q_cell = q[cell_num]\n        celldofs!(cell_dofs, dh, cell_num)\n        aᵉ = a[cell_dofs]\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:nqp\n            q_qp = - function_gradient(cellvalues, q_point, aᵉ)\n            push!(q_cell, q_qp)\n        end\n    end\n    return q\nend\n\nq_gp = compute_heat_fluxes(cellvalues, dh, u);\n\nprojector = L2Projector(ip, grid);\n\nq_projected = project(projector, q_gp, qr; project_to_nodes=false); # TODO: this should be default.\n\nvtk_grid(\"heat_equation_flux\", grid) do vtk\n    vtk_point_data(vtk, projector, q_projected, \"q\")\nend;\n\npoints = [Vec((x, 0.75)) for x in range(-1.0, 1.0, length=101)];\n\nph = PointEvalHandler(grid, points);\n\nq_points = get_point_values(ph, projector, q_projected);\n\nu_points = Ferrite.get_point_values(ph, dh, u, :u);\n\nimport Plots\n\nPlots.plot(getindex.(points,1), u_points, xlabel=\"x (coordinate)\", ylabel=\"u (temperature)\", label=nothing)\n\nPlots.plot(getindex.(points,1), getindex.(q_points,1), xlabel=\"x (coordinate)\", ylabel=\"q_x (flux in x-direction)\", label=nothing)","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ConstraintHandler\nDirichlet\nPeriodicDirichlet\nadd!\nclose!\napply!\napply_zero!\nget_rhs_data\napply_rhs!\nFerrite.RHSData","category":"page"},{"location":"reference/boundary_conditions/#Ferrite.ConstraintHandler","page":"Boundary Conditions","title":"Ferrite.ConstraintHandler","text":"ConstraintHandler\n\nCollection of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.Dirichlet","page":"Boundary Conditions","title":"Ferrite.Dirichlet","text":"Dirichlet(u, ∂Ω, f)\nDirichlet(u, ∂Ω, f, component)\n\nCreate a Dirichlet boundary condition on u on the ∂Ω part of the boundary. f is a function that takes two arguments, x and t where x is the spatial coordinate and t is the current time, and returns the prescribed value. For example, here we create a Dirichlet condition for the :u field, on the faceset called ∂Ω and the value given by the sin function:\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t))\n\nIf :u is a vector field we can specify which component the condition should be applied to by specifying component. component can be given either as an integer, or as a vector, for example:\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t), 1)      # applied to component 1\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t), [1, 3]) # applied to component 1 and 3\n\nDirichlet boundary conditions are added to a ConstraintHandler which applies the condition via apply! and/or apply_zero!.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.PeriodicDirichlet","page":"Boundary Conditions","title":"Ferrite.PeriodicDirichlet","text":"PeriodicDirichlet(u, Γ⁻ => Γ⁺, component=1)\nPeriodicDirichlet(u, Γ⁻ => Γ⁺, f, component=1)\n\nCreate a periodic Dirichlet boundary condition for the field u, with a mirror boundary, Γ⁻ and an image boundary, Γ⁺. The condition is imposed in a strong sense, and requires (i) a periodic domain (usually a cube) and (ii) a periodic mesh.\n\nSee also manual section on Periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.add!","page":"Boundary Conditions","title":"Ferrite.add!","text":"add!(ch::ConstraintHandler, dbc::Dirichlet)\n\nAdd a Dirichlet boundary condition to the ConstraintHandler.\n\n\n\n\n\nadd!(ch::ConstraintHandler, ac::AffineConstraint)\n\nAdd the AffineConstraint to the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.close!","page":"Boundary Conditions","title":"Ferrite.close!","text":"close!(dh::AbstractDofHandler)\n\nCloses dh and creates degrees of freedom for each cell.\n\nIf there are several fields, the dofs are added in the following order: For a MixedDofHandler, go through each FieldHandler in the order they were added. For each field in the FieldHandler or in the DofHandler (again, in the order the fields were added), create dofs for the cell. This means that dofs on a particular cell, the dofs will be numbered according to the fields; first dofs for field 1, then field 2, etc.\n\n\n\n\n\nclose!(ch::ConstraintHandler)\n\nClose and finalize the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply!","page":"Boundary Conditions","title":"Ferrite.apply!","text":"apply!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)\n\nAdjust the matrix K and right hand side rhs to account for the Dirichlet boundary conditions specified in ch such that K \\ rhs gives the expected solution.\n\napply!(v::AbstractVector, ch::ConstraintHandler)\n\nApply Dirichlet boundary conditions, specified in ch, to the solution vector v.\n\nExamples\n\nK, f = assemble_system(...) # Assemble system\napply!(K, f, ch)            # Adjust K and f to account for boundary conditions\nu = K \\ f                   # Solve the system, u should be \"approximately correct\"\napply!(u, ch)               # Explicitly make sure bcs are correct\n\nnote: Note\nThe last operation is not strictly necessary since the boundary conditions should already be fulfilled after apply!(K, f, ch). However, solvers of linear systems are not exact, and thus apply!(u, ch) can be used to make sure the boundary conditions are fulfilled exactly.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply_zero!","page":"Boundary Conditions","title":"Ferrite.apply_zero!","text":"apply_zero!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)\n\nAdjust the matrix K and the right hand side rhs to account for prescribed Dirichlet boundary conditions such that du = K \\ rhs give the expected result (e.g. with du zero for all prescribed degrees of freedom).\n\napply_zero!(v::AbstractVector, ch::ConstraintHandler)\n\nZero-out values in v corresponding to prescribed degrees of freedom.\n\nThese methods are typically used in e.g. a Newton solver where the increment, du, should be prescribed to zero even for non-homogeneouos boundary conditions.\n\nSee also: apply!.\n\nExamples\n\nu = un + Δu                 # Current guess\nK, g = assemble_system(...) # Assemble residual and tangent for current guess\napply_zero!(K, g, ch)       # Adjust tangent and residual to take prescribed values into account\nΔΔu = - K \\ g               # Compute the increment, prescribed values are \"approximately\" zero\napply_zero!(ΔΔu, ch)        # Make sure values are exactly zero\nΔu .+= ΔΔu                  # Update current guess\n\nnote: Note\nThe last call to apply_zero! is not strictly necessary since the boundary conditions should already be fulfilled after apply!(K, g, ch). However, solvers of linear systems are not exact, and thus apply!(ΔΔu, ch) can be used to make sure the values for the prescribed degrees of freedom are fulfilled exactly.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.get_rhs_data","page":"Boundary Conditions","title":"Ferrite.get_rhs_data","text":"get_rhs_data(ch::ConstraintHandler, A::SparseMatrixCSC) -> RHSData\n\nReturns the needed RHSData for apply_rhs!.\n\nThis must be used when the same stiffness matrix is reused for multiple steps, for example when timestepping, with different non-homogeneouos Dirichlet boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.apply_rhs!","page":"Boundary Conditions","title":"Ferrite.apply_rhs!","text":"apply_rhs!(data::RHSData, f::AbstractVector, ch::ConstraintHandler, applyzero::Bool=false)\n\nApplies the boundary condition to the right-hand-side vector without modifying the stiffness matrix.\n\nSee also: get_rhs_data.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.RHSData","page":"Boundary Conditions","title":"Ferrite.RHSData","text":"RHSData\n\nStores the constrained columns and mean of the diagonal of stiffness matrix A.\n\n\n\n\n\n","category":"type"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/interpolations/#reference-interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"Interpolation\ngetnbasefunctions\ngetdim\ngetrefshape\ngetorder","category":"page"},{"location":"reference/interpolations/#Ferrite.Interpolation","page":"Interpolation","title":"Ferrite.Interpolation","text":"Interpolation{dim, ref_shape, order}()\n\nReturn an Interpolation of given dimension dim, reference shape (see see AbstractRefShape) ref_shape and order order. order corresponds to the highest order term in the polynomial. The interpolation is used to define shape functions to interpolate a function between nodes.\n\nThe following interpolations are implemented:\n\nLagrange{1,RefCube,1}\nLagrange{1,RefCube,2}\nLagrange{2,RefCube,1}\nLagrange{2,RefCube,2}\nLagrange{2,RefTetrahedron,1}\nLagrange{2,RefTetrahedron,2}\nLagrange{3,RefCube,1}\nSerendipity{2,RefCube,2}\nSerendipity{3,RefCube,2}\nLagrange{3,RefTetrahedron,1}\nLagrange{3,RefTetrahedron,2}\n\nExamples\n\njulia> ip = Lagrange{2,RefTetrahedron,2}()\nFerrite.Lagrange{2,Ferrite.RefTetrahedron,2}()\n\njulia> getnbasefunctions(ip)\n6\n\n\n\n\n\n","category":"type"},{"location":"reference/interpolations/#Ferrite.getnbasefunctions","page":"Interpolation","title":"Ferrite.getnbasefunctions","text":"Return the number of base functions for an Interpolation or Values object.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getdim","page":"Interpolation","title":"Ferrite.getdim","text":"Return the dimension of an Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getrefshape","page":"Interpolation","title":"Ferrite.getrefshape","text":"Return the reference shape of an Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getorder","page":"Interpolation","title":"Ferrite.getorder","text":"Return the polynomial order of the Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/fevalues/#FEValues","page":"FEValues","title":"FEValues","text":"","category":"section"},{"location":"reference/fevalues/#reference-cellvalues","page":"FEValues","title":"CellValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CellValues\nreinit!\ngetnquadpoints\ngetdetJdV\n\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\n\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate","category":"page"},{"location":"reference/fevalues/#Ferrite.CellValues","page":"FEValues","title":"Ferrite.CellValues","text":"CellScalarValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\nCellVectorValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA CellValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. in the finite element cell. There are two different types of CellValues: CellScalarValues and CellVectorValues. As the names suggest, CellScalarValues utilizes scalar shape functions and CellVectorValues utilizes vectorial shape functions. For a scalar field, the CellScalarValues type should be used. For vector field, both subtypes can be used.\n\nArguments:\n\nT: an optional argument (default to Float64) to determine the type the internal data is stored as.\nquad_rule: an instance of a QuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of a Interpolation which is used to interpolate the geometry\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.reinit!","page":"FEValues","title":"Ferrite.reinit!","text":"reinit!(cv::CellValues, x::Vector)\nreinit!(bv::FaceValues, x::Vector, face::Int)\n\nUpdate the CellValues/FaceValues object for a cell or face with coordinates x. The derivatives of the shape functions, and the new integration weights are computed.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.getnquadpoints","page":"FEValues","title":"Ferrite.getnquadpoints","text":"getnquadpoints(fe_v::Values)\n\nReturn the number of quadrature points for the Values object.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.getdetJdV","page":"FEValues","title":"Ferrite.getdetJdV","text":"getdetJdV(fe_v::Values, q_point::Int)\n\nReturn the product between the determinant of the Jacobian and the quadrature point weight for the given quadrature point: det(J(mathbfx)) w_q\n\nThis value is typically used when one integrates a function on a finite element cell or face as\n\nintlimits_Omega f(mathbfx) d Omega approx sumlimits_q = 1^n_q f(mathbfx_q) det(J(mathbfx)) w_q intlimits_Gamma f(mathbfx) d Gamma approx sumlimits_q = 1^n_q f(mathbfx_q) det(J(mathbfx)) w_q\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_value","page":"FEValues","title":"Ferrite.shape_value","text":"shape_value(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the value of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_gradient","page":"FEValues","title":"Ferrite.shape_gradient","text":"shape_gradient(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_symmetric_gradient","page":"FEValues","title":"Ferrite.shape_symmetric_gradient","text":"shape_symmetric_gradient(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the symmetric gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_divergence","page":"FEValues","title":"Ferrite.shape_divergence","text":"shape_divergence(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the divergence of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_value","page":"FEValues","title":"Ferrite.function_value","text":"function_value(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the value of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe value of a scalar valued function is computed as u(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) u_i where u_i are the value of u in the nodes. For a vector valued function the value is calculated as mathbfu(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) mathbfu_i where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_gradient","page":"FEValues","title":"Ferrite.function_gradient","text":"function_gradient(fe_v::Values{dim}, q_point::Int, u::AbstractVector)\n\nCompute the gradient of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe gradient of a scalar function or a vector valued function with use of VectorValues is computed as mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx) u_i or mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla mathbfN_i (mathbfx) u_i respectively, where u_i are the nodal values of the function. For a vector valued function with use of ScalarValues the gradient is computed as mathbfnabla mathbfu(mathbfx) = sumlimits_i = 1^n mathbfu_i otimes mathbfnabla N_i (mathbfx) where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_symmetric_gradient","page":"FEValues","title":"Ferrite.function_symmetric_gradient","text":"function_symmetric_gradient(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the symmetric gradient of the function, see function_gradient. Return a SymmetricTensor.\n\nThe symmetric gradient of a scalar function is computed as left mathbfnabla  mathbfu(mathbfx_q) right^textsym =  sumlimits_i = 1^n  frac12 left mathbfnabla N_i (mathbfx_q) otimes mathbfu_i + mathbfu_i  otimes  mathbfnabla N_i (mathbfx_q) right where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_divergence","page":"FEValues","title":"Ferrite.function_divergence","text":"function_divergence(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the divergence of the vector valued function in a quadrature point.\n\nThe divergence of a vector valued functions in the quadrature point mathbfx_q) is computed as mathbfnabla cdot mathbfu(mathbfx_q) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx_q) cdot mathbfu_i where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.spatial_coordinate","page":"FEValues","title":"Ferrite.spatial_coordinate","text":"spatial_coordinate(fe_v::Values{dim}, q_point::Int, x::AbstractVector)\n\nCompute the spatial coordinate in a quadrature point. x contains the nodal coordinates of the cell.\n\nThe coordinate is computed, using the geometric interpolation, as mathbfx = sumlimits_i = 1^n M_i (mathbfx) mathbfhatx_i\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#reference-facevalues","page":"FEValues","title":"FaceValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"All of the methods for CellValues apply for FaceValues as well. In addition, there are some methods that are unique for FaecValues:","category":"page"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"FaceValues\ngetcurrentface","category":"page"},{"location":"reference/fevalues/#Ferrite.FaceValues","page":"FEValues","title":"Ferrite.FaceValues","text":"FaceScalarValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\nFaceVectorValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA FaceValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. on the faces of finite elements. There are two different types of FaceValues: FaceScalarValues and FaceVectorValues. As the names suggest, FaceScalarValues utilizes scalar shape functions and FaceVectorValues utilizes vectorial shape functions. For a scalar field, the FaceScalarValues type should be used. For vector field, both subtypes can be used.\n\nnote: Note\nThe quadrature rule for the face should be given with one dimension lower. I.e. for a 3D case, the quadrature rule should be in 2D.\n\nArguments:\n\nT: an optional argument to determine the type the internal data is stored as.\nquad_rule: an instance of a QuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of an Interpolation which is used to interpolate the geometry\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.getcurrentface","page":"FEValues","title":"Ferrite.getcurrentface","text":"getcurrentface(fv::FaceValues)\n\nReturn the current active face of the FaceValues object (from last reinit!).\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/assembly/#Assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"start_assemble\nassemble!\nend_assemble","category":"page"},{"location":"reference/assembly/#Ferrite.start_assemble","page":"Assembly","title":"Ferrite.start_assemble","text":"start_assemble([N=0]) -> Assembler\n\nCreate an Assembler object which can be used to assemble element contributions to the global sparse matrix. Use assemble! for each element, and end_assemble, to finalize the assembly and return the sparse matrix.\n\nNote that giving a sparse matrix as input can be more efficient. See below and  as described in the manual.\n\nnote: Note\nWhen the same matrix pattern is used multiple times (for e.g. multiple time steps or Newton iterations) it is more efficient to create the sparse matrix once and reuse the same pattern. See the manual section on assembly.\n\n\n\n\n\nstart_assemble(K::SparseMatrixCSC;            fillzero::Bool=true) -> AssemblerSparsityPattern\nstart_assemble(K::SparseMatrixCSC, f::Vector; fillzero::Bool=true) -> AssemblerSparsityPattern\n\nCreate a AssemblerSparsityPattern from the matrix K and optional vector f.\n\nstart_assemble(K::Symmetric{SparseMatrixCSC};                 fillzero::Bool=true) -> AssemblerSymmetricSparsityPattern\nstart_assemble(K::Symmetric{SparseMatrixCSC}, f::Vector=Td[]; fillzero::Bool=true) -> AssemblerSymmetricSparsityPattern\n\nCreate a AssemblerSymmetricSparsityPattern from the matrix K and optional vector f.\n\nAssemblerSparsityPattern and AssemblerSymmetricSparsityPattern allocate workspace necessary for efficient matrix assembly. To assemble the contribution from an element, use assemble!.\n\nThe keyword argument fillzero can be set to false if K and f should not be zeroed out, but instead keep their current values.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.assemble!","page":"Assembly","title":"Ferrite.assemble!","text":"assemble!(a::Assembler, Ke, edof)\n\nAssembles the element matrix Ke into a.\n\n\n\n\n\nassemble!(g, ge, edof)\n\nAssembles the element residual ge into the global residual vector g.\n\n\n\n\n\nassemble!(A::AbstractSparseAssembler, dofs::AbstractVector{Int}, Ke::AbstractMatrix)\nassemble!(A::AbstractSparseAssembler, dofs::AbstractVector{Int}, Ke::AbstractMatrix, fe::AbstractVector)\n\nAssemble the element stiffness matrix Ke (and optional force vector fe) into the global stiffness (and force) in A, given the element degrees of freedom dofs.\n\nThis is equivalent to K[dofs, dofs] += Ke and f[dofs] += fe, where K is the global stiffness matrix and f the global force/residual vector, but more efficient.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.end_assemble","page":"Assembly","title":"Ferrite.end_assemble","text":"end_assemble(a::Assembler) -> K\n\nFinalizes an assembly. Returns a sparse matrix with the assembled values. Note that this step is not necessary for AbstractSparseAssemblers.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"create_sparsity_pattern\ncreate_symmetric_sparsity_pattern","category":"page"},{"location":"reference/assembly/#Ferrite.create_sparsity_pattern","page":"Assembly","title":"Ferrite.create_sparsity_pattern","text":"create_sparsity_pattern(dh::DofHandler)\n\nCreate the sparsity pattern corresponding to the degree of freedom numbering in the DofHandler. Return a SparseMatrixCSC with stored values in the correct places.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.create_symmetric_sparsity_pattern","page":"Assembly","title":"Ferrite.create_symmetric_sparsity_pattern","text":"create_symmetric_sparsity_pattern(dh::DofHandler)\n\nCreate the symmetric sparsity pattern corresponding to the degree of freedom numbering in the DofHandler by only considering the upper triangle of the matrix. Return a Symmetric{SparseMatrixCSC}.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/export/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/export/#Project-to-nodes","page":"Postprocessing","title":"Project to nodes","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"L2Projector\nproject","category":"page"},{"location":"reference/export/#Ferrite.L2Projector","page":"Postprocessing","title":"Ferrite.L2Projector","text":"L2Projector(func_ip::Interpolation, grid::AbstractGrid; kwargs...)\n\nCreate an L2Projector used for projecting quadrature data. func_ip is the function interpolation used for the projection and grid the grid over which the projection is applied.\n\nKeyword arguments:\n\nqr_lhs: quadrature for the left hand side. Defaults to a quadrature which exactly integrates a mass matrix with func_ip as the interpolation.\nset: element set over which the projection applies. Defaults to all elements in the grid.\ngeom_ip: geometric interpolation. Defaults to the default interpolation for the grid.\n\nThe L2Projector acts as the integrated left hand side of the projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project.\n\nUse project to integrate the right hand side and solve for the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.project","page":"Postprocessing","title":"Ferrite.project","text":"project(proj::L2Projector, vals, qr_rhs::QuadratureRule; project_to_nodes=true)\n\nMakes a L2 projection of data vals to the nodes of the grid using the projector proj (see L2Projector).\n\nproject integrates the right hand side, and solves the projection u from the following projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project, i.e. vals.\n\nThe data vals should be a vector, with length corresponding to number of elements, of vectors, with length corresponding to number of quadrature points per element, matching the number of points in qr_rhs. Alternatively, vals can be a matrix, with number of columns corresponding to number of elements, and number of rows corresponding to number of points in qr_rhs. Example (scalar) input data:\n\nvals = [\n    [0.44, 0.98, 0.32], # data for quadrature point 1, 2, 3 of element 1\n    [0.29, 0.48, 0.55], # data for quadrature point 1, 2, 3 of element 2\n    # ...\n]\n\nor equivalent in matrix form:\n\nvals = [\n    0.44 0.29 # ...\n    0.98 0.48 # ...\n    0.32 0.55 # ...\n]\n\nSupported data types to project are Numbers and AbstractTensors.\n\nIf the parameter project_to_nodes is true, then the projection returns the values in the order of the mesh nodes (suitable format for exporting). If false, it returns the values corresponding to the degrees of freedom for a scalar field over the domain, which is useful if one wants to interpolate the projected values.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Postprocessing-2","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"PointEvalHandler\nget_point_values\nFerrite.PointValues\nPointIterator\nPointLocation","category":"page"},{"location":"reference/export/#Ferrite.PointEvalHandler","page":"Postprocessing","title":"Ferrite.PointEvalHandler","text":"PointEvalHandler(grid::Grid, points::AbstractVector{Vec{dim,T}}) where {dim, T}\n\nThe PointEvalHandler can be used for function evaluation in arbitrary points in the domain – not just in quadrature points or nodes.\n\nThe constructor takes a grid and a vector of coordinates for the points. The PointEvalHandler computes i) the corresponding cell, and ii) the (local) coordinate within the cell, for each point. The fields of the PointEvalHandler are:\n\ncells::Vector{Union{Int,Nothing}}: vector with cell IDs for the points, with nothing for points that could not be found.\nlocal_coords::Vector{Union{Vec,Nothing}}: vector with the local coordinates (i.e. coordinates in the reference configuration) for the points, with nothing for points that could not be found.\n\nThere are two ways to use the PointEvalHandler to evaluate functions:\n\nget_point_values: can be used when the function is described by i) a dh::DofHandler + uh::Vector (for example the FE-solution), or ii) a p::L2Projector + ph::Vector (for projected data).\nIteration with PointIterator + PointValues: can be used for more flexible evaluation in the points, for example to compute gradients.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.get_point_values","page":"Postprocessing","title":"Ferrite.get_point_values","text":"get_point_values(ph::PointEvalHandler, dh::AbstractDofHandler, dof_values::Vector{T}, [fieldname::Symbol]) where T\nget_point_values(ph::PointEvalHandler, proj::L2Projector, dof_values::Vector{T}) where T\n\nReturn a Vector{T} (for a 1-dimensional field) or a Vector{Vec{fielddim, T}} (for a vector field) with the field values of field fieldname in the points of the PointEvalHandler. The fieldname can be omitted if only one field is stored in dh. The field values are computed based on the dof_values and interpolated to the local coordinates by the function interpolation of the corresponding field stored in the AbstractDofHandler or the L2Projector.\n\nPoints that could not be found in the domain when constructing the PointEvalHandler will have NaNs for the corresponding entries in the output vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Ferrite.PointValues","page":"Postprocessing","title":"Ferrite.PointValues","text":"PointScalarValues(cv::CellScalarValues)\nPointScalarValues(ip_f::Interpolation, ip_g::Interpolation=ip_f)\n\nPointVectorValues(cv::CellVectorValues)\nPointVectorValues(ip_f::Interpolation, ip_g::Interpolation=ip_f)\n\nSimilar to CellScalarValues and CellVectorValues but with a single updateable \"quadrature point\". PointValues are used for evaluation of functions/gradients in arbitrary points of the domain together with a PointEvalHandler.\n\nPointValues can be created from CellValues, or from the interpolations directly.\n\nPointValues are reinitialized like other CellValues, but since the local reference coordinate of the \"quadrature point\" changes this needs to be passed to reinit!, in addition to the element coordinates: reinit!(pv, coords, local_coord). Alternatively, it can be reinitialized with a PointLocation when iterating a PointEvalHandler with a PointIterator.\n\nFor function/gradient evaluation, PointValues are used in the same way as CellValues, i.e. by using function_value, function_gradient, etc, with the exception that there is no need to specify the quadrature point index (since PointValues only have 1, this is the default).\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.PointIterator","page":"Postprocessing","title":"Ferrite.PointIterator","text":"PointIterator(ph::PointEvalHandler)\n\nCreate an iterator over the points in the PointEvalHandler. The elements of the iterator are either a PointLocation, if the corresponding point could be found in the grid, or nothing, if the point was not found.\n\nA PointLocation can be used to query the cell ID with cellid, and can be used to reinitialize PointValues with reinit!.\n\nExamples\n\nph = PointEvalHandler(grid, points)\n\nfor point in PointIterator(ph)\n    point === nothing && continue # Skip any points that weren't found\n    reinit!(pointvalues, point)   # Update pointvalues\n    # ...\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.PointLocation","page":"Postprocessing","title":"Ferrite.PointLocation","text":"PointLocation\n\nElement of a PointIterator, typically used to reinitialize PointValues. Fields:\n\ncid::Int: ID of the cell containing the point\nlocal_coord::Vec: the local (reference) coordinate of the point\ncoords::Vector{Vec}: the coordinates of the cell\n\n\n\n\n\n","category":"type"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"reshape_to_nodes","category":"page"},{"location":"reference/export/#Ferrite.reshape_to_nodes","page":"Postprocessing","title":"Ferrite.reshape_to_nodes","text":"reshape_to_nodes(dh::AbstractDofHandler, u::Vector{T}, fieldname::Symbol) where T\n\nReshape the entries of the dof-vector u which correspond to the field fieldname in nodal order. Return a matrix with a column for every node and a row for every dimension of the field. For superparametric fields only the entries corresponding to nodes of the grid will be returned. Do not use this function for subparametric approximations.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#VTK-Export","page":"Postprocessing","title":"VTK Export","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"vtk_grid(filename::AbstractString, grid::Grid{dim,C,T}; compress::Bool) where {dim,C,T} \nvtk_point_data(vtk::WriteVTK.DatasetFile, data::Union{Vector{SymmetricTensor{2,dim,T,M}}},name::AbstractString) where {dim,T,M}\nvtk_point_data(vtk::WriteVTK.DatasetFile, data::Union{ Vector{Tensor{order,dim,T,M}}, Vector{SymmetricTensor{order,dim,T,M}}}, name::AbstractString) where {order,dim,T,M}\nvtk_cellset\nvtk_cell_data_colors","category":"page"},{"location":"reference/export/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{C}, Tuple{dim}, Tuple{AbstractString, Grid{dim, C, T}}} where {dim, C, T}","page":"Postprocessing","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString, grid::Grid)\n\nCreate a unstructured VTK grid from a Grid. Return a DatasetFile which data can be appended to, see vtk_point_data and vtk_cell_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#WriteVTK.vtk_point_data-Union{Tuple{M}, Tuple{T}, Tuple{dim}, Tuple{WriteVTK.DatasetFile, Array{SymmetricTensor{2, dim, T, M}, 1}, AbstractString}} where {dim, T, M}","page":"Postprocessing","title":"WriteVTK.vtk_point_data","text":"vtk_point_data(vtk, data::Vector{<:AbstractTensor}, name)\n\nWrite the tensor field data to the vtk file. Two-dimensional tensors are padded with zeros.\n\nFor second order tensors the following indexing ordering is used: [11, 22, 33, 23, 13, 12, 32, 31, 21]. This is the default Voigt order in Tensors.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#WriteVTK.vtk_point_data-Union{Tuple{M}, Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{WriteVTK.DatasetFile, Union{Array{SymmetricTensor{order, dim, T, M}, 1}, Array{Tensor{order, dim, T, M}, 1}}, AbstractString}} where {order, dim, T, M}","page":"Postprocessing","title":"WriteVTK.vtk_point_data","text":"vtk_point_data(vtk, data::Vector{<:AbstractTensor}, name)\n\nWrite the tensor field data to the vtk file. Two-dimensional tensors are padded with zeros.\n\nFor second order tensors the following indexing ordering is used: [11, 22, 33, 23, 13, 12, 32, 31, 21]. This is the default Voigt order in Tensors.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#Ferrite.vtk_cellset","page":"Postprocessing","title":"Ferrite.vtk_cellset","text":"vtk_cellset(vtk, grid::Grid)\n\nExport all cell sets in the grid. Each cell set is exported with vtk_cell_data with value 1 if the cell is in the set, and 0 otherwise.\n\n\n\n\n\nvtk_cellset(vtk, grid::Grid, cellset::String)\n\nExport the cell set specified by cellset as cell data with value 1 if the cell is in the set and 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Ferrite.vtk_cell_data_colors","page":"Postprocessing","title":"Ferrite.vtk_cell_data_colors","text":"vtk_cell_data_colors(vtkfile, cell_colors, name=\"coloring\")\n\nWrite cell colors (see create_coloring) to a VTK file for visualization.\n\nIn case of coloring a subset, the cells which are not part of the subset are represented as color 0.\n\n\n\n\n\n","category":"function"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/threaded_assembly.jl\"","category":"page"},{"location":"examples/threaded_assembly/#Threaded-Assembly","page":"Threaded Assembly","title":"Threaded Assembly","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"tip: Tip\nThis example is also available as a Jupyter notebook: threaded_assembly.ipynb.","category":"page"},{"location":"examples/threaded_assembly/#Example-of-a-colored-grid","page":"Threaded Assembly","title":"Example of a colored grid","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Creates a simple 2D grid and colors it. Save the example grid to a VTK file to show the coloring. No cells with the same color has any shared nodes (dofs). This means that it is safe to assemble in parallel as long as we only assemble one color at a time.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"For this structured grid the greedy algorithm uses fewer colors, but both algorithms result in colors that contain roughly the same number of elements. For unstructured grids the greedy algorithm can result in colors with very few element. For those cases the workstream algorithm is better since it tries to balance the colors evenly.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"using Ferrite, SparseArrays\n\nfunction create_example_2d_grid()\n    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))\n    colors_workstream = create_coloring(grid; alg=ColoringAlgorithm.WorkStream)\n    colors_greedy = create_coloring(grid; alg=ColoringAlgorithm.Greedy)\n    vtk_grid(\"colored\", grid) do vtk\n        vtk_cell_data_colors(vtk, colors_workstream, \"workstream-coloring\")\n        vtk_cell_data_colors(vtk, colors_greedy, \"greedy-coloring\")\n    end\nend\n\ncreate_example_2d_grid();\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"(Image: )","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Figure 1: Element coloring using the \"workstream\"-algorithm (left) and the \"greedy\"- algorithm (right).","category":"page"},{"location":"examples/threaded_assembly/#Cantilever-beam-in-3D-with-threaded-assembly","page":"Threaded Assembly","title":"Cantilever beam in 3D with threaded assembly","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"We will now look at an example where we assemble the stiffness matrix using multiple threads. We set up a simple grid and create a coloring, then create a DofHandler, and define the material stiffness","category":"page"},{"location":"examples/threaded_assembly/#Grid-for-the-beam","page":"Threaded Assembly","title":"Grid for the beam","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_colored_cantilever_grid(celltype, n)\n    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))\n    colors = create_coloring(grid)\n    return grid, colors\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#DofHandler","page":"Threaded Assembly","title":"DofHandler","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_dofhandler(grid::Grid{dim}) where {dim}\n    dh = DofHandler(grid)\n    push!(dh, :u, dim) # Add a displacement field\n    close!(dh)\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Stiffness-tensor-for-linear-elasticity","page":"Threaded Assembly","title":"Stiffness tensor for linear elasticity","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_stiffness(::Val{dim}) where {dim}\n    E = 200e9\n    ν = 0.3\n    λ = E*ν / ((1+ν) * (1 - 2ν))\n    μ = E / (2(1+ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n    C = SymmetricTensor{4, dim}(g);\n    return C\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Threaded-data-structures","page":"Threaded Assembly","title":"Threaded data structures","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"ScratchValues is a thread-local collection of data that each thread needs to own, since we need to be able to mutate the data in the threads independently","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"struct ScratchValues{T, CV <: CellValues, FV <: FaceValues, TT <: AbstractTensor, dim, Ti}\n    Ke::Matrix{T}\n    fe::Vector{T}\n    cellvalues::CV\n    facevalues::FV\n    global_dofs::Vector{Int}\n    ɛ::Vector{TT}\n    coordinates::Vector{Vec{dim, T}}\n    assembler::Ferrite.AssemblerSparsityPattern{T, Ti}\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Each thread need its own CellValues and FaceValues (although, for this example we don't use the FaceValues)","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_values(refshape, dim, order::Int)\n    # Interpolations and values\n    interpolation_space = Lagrange{dim, refshape, 1}()\n    quadrature_rule = QuadratureRule{dim, refshape}(order)\n    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)\n    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    return cellvalues, facevalues\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Create a ScratchValues for each thread with the thread local data","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}\n    nthreads = Threads.nthreads()\n    assemblers = [start_assemble(K, f) for i in 1:nthreads]\n    cellvalues, facevalues = create_values(RefCube, dim, 2)\n\n    n_basefuncs = getnbasefunctions(cellvalues[1])\n    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]\n\n    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector\n    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]\n\n    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]\n\n    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]\n\n    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],\n                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Threaded-assemble","page":"Threaded Assembly","title":"Threaded assemble","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"The assembly function loops over each color and does a threaded assembly for that color","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}\n\n    f = zeros(ndofs(dh))\n    scratches = create_scratchvalues(K, f, dh)\n    b = Vec{3}((0.0, 0.0, 0.0)) # Body force\n\n    for color in colors\n        # Each color is safe to assemble threaded\n        Threads.@threads for i in 1:length(color)\n            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)\n        end\n    end\n\n    return K, f\nend","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"The cell assembly function is written the same way as if it was a single threaded example. The only difference is that we unpack the variables from our scratch.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,\n                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}\n\n    # Unpack our stuff from the scratch\n    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =\n         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,\n         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler\n\n    fill!(Ke, 0)\n    fill!(fe, 0)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n\n    # Fill up the coordinates\n    nodeids = grid.cells[cell].nodes\n    for j in 1:length(coordinates)\n        coordinates[j] = grid.nodes[nodeids[j]].x\n    end\n\n    reinit!(cellvalues, coordinates)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        for i in 1:n_basefuncs\n            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))\n        end\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(cellvalues, q_point, i)\n            fe[i] += (δu ⋅ b) * dΩ\n            ɛC = ɛ[i] ⊡ C\n            for j in 1:n_basefuncs\n                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ\n            end\n        end\n    end\n\n    celldofs!(global_dofs, dh, cell)\n    assemble!(assembler, global_dofs, fe, Ke)\nend;\n\nfunction run_assemble()\n    refshape = RefCube\n    quadrature_order = 2\n    dim = 3\n    n = 20\n    grid, colors = create_colored_cantilever_grid(Hexahedron, n);\n    dh = create_dofhandler(grid);\n\n    K = create_sparsity_pattern(dh);\n    C = create_stiffness(Val{3}());\n    # compilation\n    doassemble(K, colors, grid, dh, C);\n    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);\n    return b\nend\n\nrun_assemble()","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Running the code with different number of threads give the following runtimes:","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"1 thread  2.46 seconds\n2 threads 1.19 seconds\n3 threads 0.83 seconds\n4 threads 0.75 seconds","category":"page"},{"location":"examples/threaded_assembly/#threaded_assembly-plain-program","page":"Threaded Assembly","title":"Plain program","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Here follows a version of the program without any comments. The file is also available here: threaded_assembly.jl.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"using Ferrite, SparseArrays\n\nfunction create_example_2d_grid()\n    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))\n    colors_workstream = create_coloring(grid; alg=ColoringAlgorithm.WorkStream)\n    colors_greedy = create_coloring(grid; alg=ColoringAlgorithm.Greedy)\n    vtk_grid(\"colored\", grid) do vtk\n        vtk_cell_data_colors(vtk, colors_workstream, \"workstream-coloring\")\n        vtk_cell_data_colors(vtk, colors_greedy, \"greedy-coloring\")\n    end\nend\n\ncreate_example_2d_grid();\n\nfunction create_colored_cantilever_grid(celltype, n)\n    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))\n    colors = create_coloring(grid)\n    return grid, colors\nend;\n\nfunction create_dofhandler(grid::Grid{dim}) where {dim}\n    dh = DofHandler(grid)\n    push!(dh, :u, dim) # Add a displacement field\n    close!(dh)\nend;\n\nfunction create_stiffness(::Val{dim}) where {dim}\n    E = 200e9\n    ν = 0.3\n    λ = E*ν / ((1+ν) * (1 - 2ν))\n    μ = E / (2(1+ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n    C = SymmetricTensor{4, dim}(g);\n    return C\nend;\n\nstruct ScratchValues{T, CV <: CellValues, FV <: FaceValues, TT <: AbstractTensor, dim, Ti}\n    Ke::Matrix{T}\n    fe::Vector{T}\n    cellvalues::CV\n    facevalues::FV\n    global_dofs::Vector{Int}\n    ɛ::Vector{TT}\n    coordinates::Vector{Vec{dim, T}}\n    assembler::Ferrite.AssemblerSparsityPattern{T, Ti}\nend;\n\nfunction create_values(refshape, dim, order::Int)\n    # Interpolations and values\n    interpolation_space = Lagrange{dim, refshape, 1}()\n    quadrature_rule = QuadratureRule{dim, refshape}(order)\n    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)\n    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    return cellvalues, facevalues\nend;\n\nfunction create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}\n    nthreads = Threads.nthreads()\n    assemblers = [start_assemble(K, f) for i in 1:nthreads]\n    cellvalues, facevalues = create_values(RefCube, dim, 2)\n\n    n_basefuncs = getnbasefunctions(cellvalues[1])\n    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]\n\n    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector\n    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]\n\n    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]\n\n    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]\n\n    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],\n                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]\nend;\n\nfunction doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}\n\n    f = zeros(ndofs(dh))\n    scratches = create_scratchvalues(K, f, dh)\n    b = Vec{3}((0.0, 0.0, 0.0)) # Body force\n\n    for color in colors\n        # Each color is safe to assemble threaded\n        Threads.@threads for i in 1:length(color)\n            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)\n        end\n    end\n\n    return K, f\nend\n\nfunction assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,\n                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}\n\n    # Unpack our stuff from the scratch\n    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =\n         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,\n         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler\n\n    fill!(Ke, 0)\n    fill!(fe, 0)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n\n    # Fill up the coordinates\n    nodeids = grid.cells[cell].nodes\n    for j in 1:length(coordinates)\n        coordinates[j] = grid.nodes[nodeids[j]].x\n    end\n\n    reinit!(cellvalues, coordinates)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        for i in 1:n_basefuncs\n            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))\n        end\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(cellvalues, q_point, i)\n            fe[i] += (δu ⋅ b) * dΩ\n            ɛC = ɛ[i] ⊡ C\n            for j in 1:n_basefuncs\n                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ\n            end\n        end\n    end\n\n    celldofs!(global_dofs, dh, cell)\n    assemble!(assembler, global_dofs, fe, Ke)\nend;\n\nfunction run_assemble()\n    refshape = RefCube\n    quadrature_order = 2\n    dim = 3\n    n = 20\n    grid, colors = create_colored_cantilever_grid(Hexahedron, n);\n    dh = create_dofhandler(grid);\n\n    K = create_sparsity_pattern(dh);\n    C = create_stiffness(Val{3}());\n    # compilation\n    doassemble(K, colors, grid, dh, C);\n    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);\n    return b\nend\n\nrun_assemble()","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"using Ferrite","category":"page"},{"location":"manual/degrees_of_freedom/#Degrees-of-Freedom","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The distribution and numbering of degrees of freedom (dofs) are handled by the DofHandler. The DofHandler will be used to query information about the dofs. For example we can obtain the dofs for a particular cell, which we need when assembling the system.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The DofHandler is based on the grid. Here we create a simple grid with Triangle cells, and then create a DofHandler based on the grid","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"grid = generate_grid(Triangle, (20, 20))\ndh = DofHandler(grid)\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/#Fields","page":"Degrees of Freedom","title":"Fields","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Before we can distribute the dofs we need to specify fields. A field is simply the unknown function(s) we are solving for. To add a field we need a name (a Symbol) and we also need to specify number of components for the field. Here we add a vector field :u (2 components for a 2D problem) and a scalar field :p.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"push!(dh, :u, 2)\npush!(dh, :p, 1)\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Finally, when we have added all the fields, we have to close! the DofHandler. When the DofHandler is closed it will traverse the grid and distribute all the dofs for the fields we added.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"close!(dh)","category":"page"},{"location":"manual/degrees_of_freedom/#Specifying-interpolation-for-a-field","page":"Degrees of Freedom","title":"Specifying interpolation for a field","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"In the example above we did not specify which interpolation should be used for our fields :u and :p. By default iso-parametric elements will be used meaning that the interpolation that matches the grid will be used – for a linear grid a linear interpolation will be used etc. It is sometimes useful to separate the grid interpolation from the interpolation that is used to approximate our fields (e.g. sub- and super-parametric elements).","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"We can specify which interpolation that should be used for the approximation when we add the fields to the dofhandler. For example, here we add our vector field :u with a quadratic interpolation, and our :p field with a linear approximation.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"dh = DofHandler(grid) # hide\npush!(dh, :u, 2, Lagrange{2,RefTetrahedron,2}())\npush!(dh, :p, 1, Lagrange{2,RefTetrahedron,1}())\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/#Ordering-of-Dofs","page":"Degrees of Freedom","title":"Ordering of Dofs","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"ordered in the same order as we add to dofhandler nodes -> (edges ->) faces -> cells","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/ns_vs_diffeq.jl\"","category":"page"},{"location":"examples/ns_vs_diffeq/#Incompressible-Navier-Stokes-Equations-via-DifferentialEquations.jl","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"In this example we focus on a simple but visually appealing problem from fluid dynamics, namely vortex shedding. This problem is also known as von-Karman vortex streets. Within this example, we show how to utilize DifferentialEquations.jl in tandem with Ferrite.jl to solve this space-time problem. To keep things simple we use a naive approach to discretize the system.","category":"page"},{"location":"examples/ns_vs_diffeq/#Remarks-on-DifferentialEquations.jl","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Remarks on DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Many \"time step solvers\" of DifferentialEquations.jl assume that that the problem is provided in mass matrix form. The incompressible Navier-Stokes equations as stated above yield a DAE in this form after applying a spatial discretization technique - in our case FEM. The mass matrix form of ODEs and DAEs is given as:","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"  M(t) mathrmd_t u = f(ut)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where M is a possibly time-dependent and not necessarily invertible mass matrix, u the vector of unknowns and f the right-hand-side (RHS). For us f can be interpreted as the spatial discretization of all linear and nonlinear operators depending on u and t, but not on the time derivative of u.","category":"page"},{"location":"examples/ns_vs_diffeq/#Some-Theory-on-the-Incompressible-Navier-Stokes-Equations","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Some Theory on the Incompressible Navier-Stokes Equations","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/#Problem-Description-in-Strong-Form","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Problem Description in Strong Form","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"The incompressible Navier-Stokes equations can be stated as the system","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" beginaligned\n   partial_t v = underbracenu Delta v_textviscosity - underbrace(v cdot nabla) v_textadvection - underbracenabla p_textpressure \n              0 = underbracenabla cdot v_textincompressibility\n endaligned","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where v is the unknown velocity field, p the unknown pressure field, nu the dynamic viscosity and Delta the Laplacian. In the derivation we assumed a constant density of 1 for the fluid and negligible coupling between the velocity components. Finally we see that the pressure term appears only in combination with the gradient operator, so for any solution p the function p + c is also an admissible solution, if we do not impose Dirichlet conditions on the pressure. To resolve this we introduce the implicit constraint that $ \\int_\\Omega p = 0 $.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Our setup is derived from Turek's DFG benchmark. We model a channel with size 041 times 22 and a hole of radius 005 centered at (02 02). The left side has a parabolic inflow profile, which is ramped up over time, modeled as the time dependent Dirichlet condition","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" v(xyt)\n =\n beginbmatrix\n     4 v_in(t) y (041-y)041^2 \n     0\n endbmatrix","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where v_in(t) = textclamp(t 00 10). With a dynamic viscosity of nu = 0001 this is enough to induce turbulence behind the cylinder which leads to vortex shedding. The top and bottom of our channel have no-slip conditions, i.e. v = 00^textrmT, while the right boundary has the do-nothing boundary condtion nu partial_textrmn v - p n = 0 to model outflow. With these boundary conditions we can choose the zero solution as a feasible initial condition.","category":"page"},{"location":"examples/ns_vs_diffeq/#Derivation-of-Semi-Discrete-Weak-Form","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Derivation of Semi-Discrete Weak Form","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"By multiplying test functions varphi and psi from a suitable test function space on the strong form, followed by integrating over the domain and applying partial integration to the pressure and viscosity terms we can obtain the following weak form","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" beginaligned\n   int_Omega partial_t v cdot varphi = - int_Omega nu nabla v  nabla varphi - int_Omega (v cdot nabla) v cdot varphi + int_Omega p (nabla cdot varphi) + int_partial Omega_N underbrace(nu partial_n v - p n )_=0 cdot varphi \n                                 0 = int_Omega (nabla cdot v) psi\n endaligned","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"for all possible test functions from the suitable space.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we can discretize the problem as usual with the finite element method utilizing Taylor-Hood elements (Q2Q1) to yield a stable discretization in mass matrix form:","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" underbracebeginbmatrix\n     M_v  0 \n      0   0\n endbmatrix_=M\n beginbmatrix\n     mathrmd_thatv \n     mathrmd_thatp\n endbmatrix\n =\n underbracebeginbmatrix\n      A  B^textrmT \n      B  0\n endbmatrix_=K\n beginbmatrix\n     hatv \n     hatp\n endbmatrix\n +\n beginbmatrix\n     N(hatv hatv hatvarphi) \n     0\n endbmatrix","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Here M is the singular block mass matrix, K is the discretized Stokes operator and N the nonlinear advection term, which is also called trilinear form. hatv and hatp represent the time-dependent vectors of nodal values of the discretizations of v and p respectively, while hatvarphi is the choice for the test function in the discretization. The hats are dropped in the implementation and only stated for clarity in this section.","category":"page"},{"location":"examples/ns_vs_diffeq/#Commented-Implementation","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Commented Implementation","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we solve the problem with Ferrite and DifferentialEquations.jl. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"First we load Ferrite and some other packages we need","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"using Ferrite, SparseArrays, BlockArrays, LinearAlgebra, UnPack","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Since we do not need the complete DifferentialEquations suite, we just load the required ODE infrastructure, which can also handle DAEs in mass matrix form.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"We start off by defining our only material parameter.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"ν = 1.0/1000.0; #dynamic viscosity\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next a fine 2D rectangular grid has to be generated. We leave the cell size parametric for flexibility when playing around with the code. Note that the mesh is pretty fine, leading to a high memory consumption when feeding the equation system to direct solvers.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"dim = 2\ncell_scale_factor = 2.0\nx_cells = round(Int, cell_scale_factor*220)\ny_cells = round(Int, cell_scale_factor*41)\nx_cells = round(Int, 55/3)                  #hide\ny_cells = round(Int, 41/3)                  #hide\ngrid = generate_grid(Quadrilateral, (x_cells, y_cells), Vec{2}((0.0, 0.0)), Vec{2}((2.2, 0.41)));\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next we carve a hole B_005(0202) in the mesh by deleting the cells and update the boundary face sets. This code will be replaced once a proper mesh interface is avaliable.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"cell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05, 1:length(grid.cells))\nhole_cell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))<=0.05, 1:length(grid.cells));\nhole_face_ring = Set{FaceIndex}()\nfor hci ∈ hole_cell_indices\n    push!(hole_face_ring, FaceIndex((hci+1, 4)))\n    push!(hole_face_ring, FaceIndex((hci-1, 2)))\n    push!(hole_face_ring, FaceIndex((hci-x_cells, 3)))\n    push!(hole_face_ring, FaceIndex((hci+x_cells, 1)))\nend\ngrid.facesets[\"hole\"] = Set(filter(x->x.idx[1] ∉ hole_cell_indices, collect(hole_face_ring)));\ncell_indices_map = map(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05 ? indexin([ci], cell_indices)[1] : 0, 1:length(grid.cells))\ngrid.cells = grid.cells[cell_indices]\nfor facesetname in keys(grid.facesets)\n    grid.facesets[facesetname] = Set(map(fi -> FaceIndex( cell_indices_map[fi.idx[1]] ,fi.idx[2]), collect(grid.facesets[facesetname])))\nend;\n\ngrid = generate_grid(Quadrilateral, (x_cells, y_cells), Vec{2}((0.0, 0.0)), Vec{2}((0.55, 0.41)));   #hide\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Function-Space","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Function Space","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"To ensure stability we utilize the Taylor-Hood element pair Q2-Q1. We have to utilize the same quadrature rule for the pressure as for the velocity, because in the weak form the linear pressure term is tested against a quadratic function.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"ip_v = Lagrange{dim, RefCube, 2}()\nip_geom = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(4)\ncellvalues_v = CellVectorValues(qr, ip_v, ip_geom);\n\nip_p = Lagrange{dim, RefCube, 1}()\ncellvalues_p = CellScalarValues(qr, ip_p, ip_geom);\n\ndh = DofHandler(grid)\npush!(dh, :v, dim, ip_v)\npush!(dh, :p, 1, ip_p)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Boundary-Conditions","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Boundary Conditions","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"As in the DFG benchmark we apply no-slip conditions to the top, bottom and cylinder boundary. The no-slip condition states that the velocity of the fluid on this portion of the boundary is fixed to be zero.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"ch = ConstraintHandler(dh);\n\nnosplip_face_names = [\"top\", \"bottom\", \"hole\"];\nnosplip_face_names = [\"top\", \"bottom\"]                                  #hide\n∂Ω_noslip = union(getfaceset.((grid, ), nosplip_face_names)...);\nnoslip_bc = Dirichlet(:v, ∂Ω_noslip, (x, t) -> [0,0], [1,2])\nadd!(ch, noslip_bc);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"The left boundary has a parabolic inflow with peak velocity of 1.0. This ensures that for the given geometry the Reynolds number is 100, which is already enough to obtain some simple vortex streets. By increasing the velocity further we can obtain stronger vortices - which may need additional refinement of the grid.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"∂Ω_inflow = getfaceset(grid, \"left\");\n\nvᵢₙ(t) = clamp(t, 0.0, 1.0)*1.0 #inflow velocity\nvᵢₙ(t) = clamp(t, 0.0, 1.0)*0.3 #hide\nparabolic_inflow_profile((x,y),t) = [4*vᵢₙ(t)*y*(0.41-y)/0.41^2,0]\ninflow_bc = Dirichlet(:v, ∂Ω_inflow, parabolic_inflow_profile, [1,2])\nadd!(ch, inflow_bc);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"The outflow boundary condition has been applied on the right side of the cylinder when the weak form has been derived by setting the boundary integral to zero. It is also called the do-nothing condition. Other outflow conditions are also possible.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"∂Ω_free = getfaceset(grid, \"right\");\n\nclose!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Linear-System-Assembly","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Linear System Assembly","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next we describe how the block mass matrix and the Stokes matrix are assembled.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"For the block mass matrix M we remember that only the first equation had a time derivative and that the block mass matrix corresponds to the term arising from discretizing the time derivatives. Hence, only the upper left block has non-zero components.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"function assemble_mass_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, M::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Allocate a buffer for the local matrix and some helpers, together with the assembler.\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Mₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # It follows the assembly loop as explained in the basic tutorials.\n    mass_assembler = start_assemble(M)\n    @inbounds for cell in CellIterator(dh)\n        fill!(Mₑ, 0)\n        Ferrite.reinit!(cellvalues_v, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            # Remember that we assemble a vector mass term, hence the dot product.\n            for i in 1:n_basefuncs_v\n                φᵢ = shape_value(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    φⱼ = shape_value(cellvalues_v, q_point, j)\n                    Mₑ[BlockIndex((v▄, v▄), (i, j))] += φᵢ ⋅ φⱼ * dΩ\n                end\n            end\n        end\n        assemble!(mass_assembler, celldofs(cell), Mₑ)\n    end\n\n    return M\nend;\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next we discuss the assembly of the Stokes matrix. Remember that we use the same function spaces for trial and test, hence the matrix has the following block form","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"  K = beginbmatrix\n      A  B^textrmT \n      B  0\n  endbmatrix","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"which is also called saddle point matrix. These problems are known to have a non-trivial kernel, which is a reflection of the strong form as discussed in the theory portion if this example.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"function assemble_stokes_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, ν, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Again, some buffers and helpers\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Kₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # Assembly loop\n    stiffness_assembler = start_assemble(K)\n    @inbounds for cell in CellIterator(dh)\n        # Don't forget to initialize everything\n        fill!(Kₑ, 0)\n\n        Ferrite.reinit!(cellvalues_v, cell)\n        Ferrite.reinit!(cellvalues_p, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Assemble local viscosity block of A","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"            for i in 1:n_basefuncs_v\n                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    ∇φⱼ = shape_gradient(cellvalues_v, q_point, j)\n                    Kₑ[BlockIndex((v▄, v▄), (i, j))] -= ν * ∇φᵢ ⊡ ∇φⱼ * dΩ\n                end\n            end","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Assemble local pressure and incompressibility blocks of B^textrmT and B.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"            for j in 1:n_basefuncs_p\n                ψ = shape_value(cellvalues_p, q_point, j)\n                for i in 1:n_basefuncs_v\n                    divφ = shape_divergence(cellvalues_v, q_point, i)\n                    Kₑ[BlockIndex((v▄, p▄), (i, j))] += (divφ * ψ) * dΩ\n                    Kₑ[BlockIndex((p▄, v▄), (j, i))] += (ψ * divφ) * dΩ\n                end\n            end\n        end\n\n        # Assemble `Kₑ` into the Stokes matrix `K`.\n        assemble!(stiffness_assembler, celldofs(cell), Kₑ)\n    end\n    return K\nend;\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Solution-of-the-semi-discretized-system-via-DifferentialEquations.jl","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Solution of the semi-discretized system via DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"First we assemble the linear portions for efficiency. These matrices are assumed to be constant over time.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"T = 10.0\nΔt₀ = 0.01\nΔt_save = 0.1\n\nM = create_sparsity_pattern(dh);\nM = assemble_mass_matrix(cellvalues_v, cellvalues_p, M, dh);\n\nK = create_sparsity_pattern(dh);\nK = assemble_stokes_matrix(cellvalues_v, cellvalues_p, ν, K, dh);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"These are our initial conditions. We start from the zero solution, because it is trivially admissible if the Dirichlet conditions are zero everywhere on the Dirichlet boundary for t=0. Note that the time stepper is also doing fine if the Dirichlet condition is non-zero and not too pathological.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"u₀ = zeros(ndofs(dh))\napply!(u₀, ch);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"DifferentialEquations assumes dense matrices by default, which is not feasible for semi-discretization of finite element models. We communicate that a sparse matrix with specified pattern should be utilized through the jac_prototyp argument. It is simple to see that the Jacobian and the stiffness matrix share the same sparsity pattern, since they share the same relation between trial and test functions.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"jac_sparsity = sparse(K);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"To apply the nonlinear portion of the Navier-Stokes problem we simply hand over the dof handler and cell values to the right-hand-side (RHS) as a parameter. Further the pre-assembled linear part (which is time independent) is passed to save some runtime. To apply the time-dependent Dirichlet BCs, we also hand over the constraint handler. The basic idea to apply the Dirichlet BCs consistently is that we copy the current solution u, apply the Dirichlet BCs on the copy, evaluate the discretized RHS of the Navier-Stokes equations with this vector and finally set the RHS to zero on every constraint. This way we obtain a correct solution for all dofs which are not Dirichlet constrained. These dofs are then corrected in a post-processing step, when evaluating the solution vector at specific time points. It should be finally noted that this trick does not work out of the box for constraining algebraic portion of the DAE, i.e. if we would like to put a Dirichlet BC on pressure dofs. As a workaround we have to set f_textrmi = 1 instead of f_textrmi = 0, because otherwise the equation system gets singular. This is obvious when we remember that our mass matrix is zero for these dofs, such that we obtain the equation 0 cdot mathrmd_t p_textrmi = 1 cdot p_textrmi, which now has a unique solution.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"struct RHSparams\n    K::SparseMatrixCSC\n    ch::ConstraintHandler\n    dh::DofHandler\n    cellvalues_v::CellVectorValues\nend\np = RHSparams(K, ch, dh, cellvalues_v)\n\nfunction navierstokes!(du,u_uc,p,t)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Unpack the struct to save some allocations.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    @unpack K,ch,dh,cellvalues_v = p","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"We start by applying the time-dependent Dirichlet BCs. Note that we are not allowed to mutate u_uc! We also can not pre-allocate this variable if we want to use AD to derive the Jacobian matrix, which appears in the utilized implicit Euler. If we hand over the Jacobian analytically to the solver, or when utilizing a method which does not require building the Jacobian, then we could also hand over a buffer for u in our RHSparams structure to save the allocations made here.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    u = copy(u_uc)\n    update!(ch, t)\n    apply!(u, ch)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we apply the rhs of the Navier-Stokes equations","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    # Linear contribution (Stokes operator)\n    mul!(du, K, u) # du .= K * u\n\n    # nonlinear contribution\n    n_basefuncs = getnbasefunctions(cellvalues_v)\n    for cell in CellIterator(dh)\n        Ferrite.reinit!(cellvalues_v, cell)\n        all_celldofs = celldofs(cell)\n        v_celldofs = all_celldofs[dof_range(dh, :v)]\n        v_cell = u[v_celldofs]\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            ∇v = function_gradient(cellvalues_v, q_point, v_cell)\n            v = function_value(cellvalues_v, q_point, v_cell)\n            for j in 1:n_basefuncs\n                φⱼ = shape_value(cellvalues_v, q_point, j)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Note that in Tensors.jl the definition textrmgrad v = nabla v holds. With this information it can be quickly shown in index notation that","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"(v cdot nabla) v_textrmi = v_textrmj (partial_textrmj v_textrmi) = v (nabla v)^textrmT_textrmi","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where we should pay attentation to the transpose of the gradient.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"                du[v_celldofs[j]] -= v ⋅ ∇v' ⋅ φⱼ * dΩ\n            end\n        end\n    end","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"For now we have to ingore the evolution of the Dirichlet BCs. The DBC dofs in the solution vector will be corrected in a post-processing step.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    apply_zero!(du, ch)\nend;\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Finally, together with our pre-assembled mass matrix, we are now able to define our problem in mass matrix form.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"rhs = ODEFunction(navierstokes!, mass_matrix=M; jac_prototype=jac_sparsity)\nproblem = ODEProblem(rhs, u₀, (0.0,T), p);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we can put everything together by specifying how to solve the problem. We want to use the adaptive implicit Euler method with our custom linear solver, which helps in the enforcement of the Dirichlet BCs. Further we enable the progress bar with the progess and progress_steps arguments. Finally we have to communicate the time step length and initialization algorithm. Since we start with a valid initial state we do not use one of DifferentialEquations.jl initialization algorithms. NOTE: At the time of writing this no Hessenberg index 2 initialization is implemented.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"To visualize the result we export the grid and our fields to VTK-files, which can be viewed in ParaView by utilizing the corresponding pvd file.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"timestepper = ImplicitEuler()\nintegrator = init(\n    problem, timestepper, initializealg=NoInit(), dt=Δt₀,\n    adaptive=true, abstol=1e-3, reltol=1e-3,\n    progress=true, progress_steps=1,\n    saveat=Δt_save);\n\npvd = paraview_collection(\"vortex-street.pvd\");\nintegrator = TimeChoiceIterator(integrator, 0.0:Δt_save:T)\nfor (u_uc,t) in integrator","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"We ignored the Dirichlet constraints in the solution vector up to now, so we have to bring them back now.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    update!(ch, t)\n    u = copy(u_uc)\n    apply!(u, ch)\n    vtk_grid(\"vortex-street-$t.vtu\", dh) do vtk\n        vtk_point_data(vtk,dh,u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\nend\nvtk_save(pvd);\n\nusing Test                                                                  #hide\nfunction compute_divergence(dh, u, cellvalues_v)                            #hide\n    divv = 0.0                                                              #hide\n    @inbounds for (i,cell) in enumerate(CellIterator(dh))                   #hide\n        Ferrite.reinit!(cellvalues_v, cell)                                 #hide\n        for q_point in 1:getnquadpoints(cellvalues_v)                       #hide\n            dΩ = getdetJdV(cellvalues_v, q_point)                           #hide\n                                                                            #hide\n            all_celldofs = celldofs(cell)                                   #hide\n            v_celldofs = all_celldofs[dof_range(dh, :v)]                    #hide\n            v_cell = u[v_celldofs]                                          #hide\n                                                                            #hide\n            divv += function_divergence(cellvalues_v, q_point, v_cell) * dΩ #hide\n        end                                                                 #hide\n    end                                                                     #hide\n    return divv                                                             #hide\nend                                                                         #hide\n@testset \"INS OrdinaryDiffEq\" begin                                         #hide\n    u = copy(integrator.integrator.u)                                       #hide\n    apply!(u, ch)                                                           #hide\n    Δdivv = abs(compute_divergence(dh, u, cellvalues_v))                    #hide\n    @test isapprox(Δdivv, 0.0, atol=1e-12)                                  #hide\n                                                                            #hide\n    Δv = 0.0                                                                #hide\n    for cell in CellIterator(dh)                                            #hide\n        Ferrite.reinit!(cellvalues_v, cell)                                 #hide\n        all_celldofs = celldofs(cell)                                       #hide\n        v_celldofs = all_celldofs[dof_range(dh, :v)]                        #hide\n        v_cell = u[v_celldofs]                                              #hide\n        coords = getcoordinates(cell)                                       #hide\n        for q_point in 1:getnquadpoints(cellvalues_v)                       #hide\n            dΩ = getdetJdV(cellvalues_v, q_point)                           #hide\n            coords_qp = spatial_coordinate(cellvalues_v, q_point, coords)   #hide\n            v = function_value(cellvalues_v, q_point, v_cell)               #hide\n            Δv += norm(v - parabolic_inflow_profile(coords_qp, T))^2*dΩ     #hide\n        end                                                                 #hide\n    end                                                                     #hide\n    @test isapprox(sqrt(Δv), 0.0, atol=1e-3)                                #hide\nend;                                                                        #hide\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#ns_vs_diffeq-plain-program","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Plain program","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Here follows a version of the program without any comments. The file is also available here: ns_vs_diffeq.jl.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"using Ferrite, SparseArrays, BlockArrays, LinearAlgebra, UnPack\n\nusing OrdinaryDiffEq\n\nν = 1.0/1000.0; #dynamic viscosity\n\ndim = 2\ncell_scale_factor = 2.0\nx_cells = round(Int, cell_scale_factor*220)\ny_cells = round(Int, cell_scale_factor*41)\ngrid = generate_grid(Quadrilateral, (x_cells, y_cells), Vec{2}((0.0, 0.0)), Vec{2}((2.2, 0.41)));\n\ncell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05, 1:length(grid.cells))\nhole_cell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))<=0.05, 1:length(grid.cells));\nhole_face_ring = Set{FaceIndex}()\nfor hci ∈ hole_cell_indices\n    push!(hole_face_ring, FaceIndex((hci+1, 4)))\n    push!(hole_face_ring, FaceIndex((hci-1, 2)))\n    push!(hole_face_ring, FaceIndex((hci-x_cells, 3)))\n    push!(hole_face_ring, FaceIndex((hci+x_cells, 1)))\nend\ngrid.facesets[\"hole\"] = Set(filter(x->x.idx[1] ∉ hole_cell_indices, collect(hole_face_ring)));\ncell_indices_map = map(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05 ? indexin([ci], cell_indices)[1] : 0, 1:length(grid.cells))\ngrid.cells = grid.cells[cell_indices]\nfor facesetname in keys(grid.facesets)\n    grid.facesets[facesetname] = Set(map(fi -> FaceIndex( cell_indices_map[fi.idx[1]] ,fi.idx[2]), collect(grid.facesets[facesetname])))\nend;\n\n\nip_v = Lagrange{dim, RefCube, 2}()\nip_geom = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(4)\ncellvalues_v = CellVectorValues(qr, ip_v, ip_geom);\n\nip_p = Lagrange{dim, RefCube, 1}()\ncellvalues_p = CellScalarValues(qr, ip_p, ip_geom);\n\ndh = DofHandler(grid)\npush!(dh, :v, dim, ip_v)\npush!(dh, :p, 1, ip_p)\nclose!(dh);\n\nch = ConstraintHandler(dh);\n\nnosplip_face_names = [\"top\", \"bottom\", \"hole\"];\n∂Ω_noslip = union(getfaceset.((grid, ), nosplip_face_names)...);\nnoslip_bc = Dirichlet(:v, ∂Ω_noslip, (x, t) -> [0,0], [1,2])\nadd!(ch, noslip_bc);\n\n∂Ω_inflow = getfaceset(grid, \"left\");\n\nvᵢₙ(t) = clamp(t, 0.0, 1.0)*1.0 #inflow velocity\nparabolic_inflow_profile((x,y),t) = [4*vᵢₙ(t)*y*(0.41-y)/0.41^2,0]\ninflow_bc = Dirichlet(:v, ∂Ω_inflow, parabolic_inflow_profile, [1,2])\nadd!(ch, inflow_bc);\n\n∂Ω_free = getfaceset(grid, \"right\");\n\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction assemble_mass_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, M::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Allocate a buffer for the local matrix and some helpers, together with the assembler.\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Mₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # It follows the assembly loop as explained in the basic tutorials.\n    mass_assembler = start_assemble(M)\n    @inbounds for cell in CellIterator(dh)\n        fill!(Mₑ, 0)\n        Ferrite.reinit!(cellvalues_v, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            # Remember that we assemble a vector mass term, hence the dot product.\n            for i in 1:n_basefuncs_v\n                φᵢ = shape_value(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    φⱼ = shape_value(cellvalues_v, q_point, j)\n                    Mₑ[BlockIndex((v▄, v▄), (i, j))] += φᵢ ⋅ φⱼ * dΩ\n                end\n            end\n        end\n        assemble!(mass_assembler, celldofs(cell), Mₑ)\n    end\n\n    return M\nend;\n\nfunction assemble_stokes_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, ν, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Again, some buffers and helpers\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Kₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # Assembly loop\n    stiffness_assembler = start_assemble(K)\n    @inbounds for cell in CellIterator(dh)\n        # Don't forget to initialize everything\n        fill!(Kₑ, 0)\n\n        Ferrite.reinit!(cellvalues_v, cell)\n        Ferrite.reinit!(cellvalues_p, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n\n            for i in 1:n_basefuncs_v\n                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    ∇φⱼ = shape_gradient(cellvalues_v, q_point, j)\n                    Kₑ[BlockIndex((v▄, v▄), (i, j))] -= ν * ∇φᵢ ⊡ ∇φⱼ * dΩ\n                end\n            end\n\n            for j in 1:n_basefuncs_p\n                ψ = shape_value(cellvalues_p, q_point, j)\n                for i in 1:n_basefuncs_v\n                    divφ = shape_divergence(cellvalues_v, q_point, i)\n                    Kₑ[BlockIndex((v▄, p▄), (i, j))] += (divφ * ψ) * dΩ\n                    Kₑ[BlockIndex((p▄, v▄), (j, i))] += (ψ * divφ) * dΩ\n                end\n            end\n        end\n\n        # Assemble `Kₑ` into the Stokes matrix `K`.\n        assemble!(stiffness_assembler, celldofs(cell), Kₑ)\n    end\n    return K\nend;\n\nT = 10.0\nΔt₀ = 0.01\nΔt_save = 0.1\n\nM = create_sparsity_pattern(dh);\nM = assemble_mass_matrix(cellvalues_v, cellvalues_p, M, dh);\n\nK = create_sparsity_pattern(dh);\nK = assemble_stokes_matrix(cellvalues_v, cellvalues_p, ν, K, dh);\n\nu₀ = zeros(ndofs(dh))\napply!(u₀, ch);\n\njac_sparsity = sparse(K);\n\nstruct RHSparams\n    K::SparseMatrixCSC\n    ch::ConstraintHandler\n    dh::DofHandler\n    cellvalues_v::CellVectorValues\nend\np = RHSparams(K, ch, dh, cellvalues_v)\n\nfunction navierstokes!(du,u_uc,p,t)\n\n    @unpack K,ch,dh,cellvalues_v = p\n\n    u = copy(u_uc)\n    update!(ch, t)\n    apply!(u, ch)\n\n    # Linear contribution (Stokes operator)\n    mul!(du, K, u) # du .= K * u\n\n    # nonlinear contribution\n    n_basefuncs = getnbasefunctions(cellvalues_v)\n    for cell in CellIterator(dh)\n        Ferrite.reinit!(cellvalues_v, cell)\n        all_celldofs = celldofs(cell)\n        v_celldofs = all_celldofs[dof_range(dh, :v)]\n        v_cell = u[v_celldofs]\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            ∇v = function_gradient(cellvalues_v, q_point, v_cell)\n            v = function_value(cellvalues_v, q_point, v_cell)\n            for j in 1:n_basefuncs\n                φⱼ = shape_value(cellvalues_v, q_point, j)\n\n                du[v_celldofs[j]] -= v ⋅ ∇v' ⋅ φⱼ * dΩ\n            end\n        end\n    end\n\n    apply_zero!(du, ch)\nend;\n\nrhs = ODEFunction(navierstokes!, mass_matrix=M; jac_prototype=jac_sparsity)\nproblem = ODEProblem(rhs, u₀, (0.0,T), p);\n\ntimestepper = ImplicitEuler()\nintegrator = init(\n    problem, timestepper, initializealg=NoInit(), dt=Δt₀,\n    adaptive=true, abstol=1e-3, reltol=1e-3,\n    progress=true, progress_steps=1,\n    saveat=Δt_save);\n\npvd = paraview_collection(\"vortex-street.pvd\");\nintegrator = TimeChoiceIterator(integrator, 0.0:Δt_save:T)\nfor (u_uc,t) in integrator\n\n    update!(ch, t)\n    u = copy(u_uc)\n    apply!(u, ch)\n    vtk_grid(\"vortex-street-$t.vtu\", dh) do vtk\n        vtk_point_data(vtk,dh,u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\nend\nvtk_save(pvd);","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/hyperelasticity.jl\"","category":"page"},{"location":"examples/hyperelasticity/#Hyperelasticity","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Keywords: hyperelasticity, finite strain, large deformations, Newton's method, conjugate gradient, automatic differentiation","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"(Image: hyperelasticity.png)","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Figure 1: Cube loaded in torsion modeled with a hyperelastic material model and finite strain.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: hyperelasticity.ipynb.","category":"page"},{"location":"examples/hyperelasticity/#Introduction","page":"Hyperelasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"In this example we will solve a problem in a finite strain setting using an hyperelastic material model. In order to compute the stress we will use automatic differentiation, to solve the non-linear system we use Newton's method, and for solving the Newton increment we use conjugate gradients.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The weak form is expressed in terms of the first Piola-Kirchoff stress mathbfP as follows: Find u in mathbbU such that","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"int_Omega nabla_mathbfX delta mathbfu  mathbfP(mathbfu) mathrmdOmega =\nint_Omega delta mathbfu cdot mathbfb mathrmdOmega + int_Gamma^mathrmN\ndelta mathbfu cdot mathbft mathrmdGamma\nquad forall delta mathbfu in mathbbU^0","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where mathbfu is the unknown displacement field, mathbfb is the body force acting on the reference domain, mathbft is the traction acting on the Neumann part of the reference domain's boundary, and where mathbbU and mathbbU^0 are suitable trial and test sets. Omega denotes the reference domain, which is also called reference or material domain. Gradients are defined with respect to the reference domain, here denoted with  an X. Formally this is expressed as (nabla_mathbfX bullet)_ij = fracpartial(bullet)_ipartial X_j. Note that for large deformation problems it is also possibile that gradients and integrals are defined on the deformed domain, which is also called the current or spatial domain, depending on the specific formulation.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Ferrite, Tensors, TimerOutputs, ProgressMeter\nimport KrylovMethods, IterativeSolvers","category":"page"},{"location":"examples/hyperelasticity/#Hyperelastic-material-model","page":"Hyperelasticity","title":"Hyperelastic material model","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The stress can be derived from an energy potential, defined in terms of the right Cauchy-Green tensor mathbfC = mathbfF^mathrmT mathbfF, where mathbfF = mathbfI + nabla_mathbfX mathbfu is the deformation gradient. We shall use a neo-Hookean model, where the potential can be written as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Psi(mathbfC) = fracmu2 (I_1 - 3) - mu ln(J) + fraclambda2 ln(J)^2","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where I_1 = mathrmtr(mathbfC) is the first invariant, J = sqrtdet(mathbfC) and mu and lambda material parameters. From the potential we obtain the second Piola-Kirchoff stress mathbfS as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"mathbfS = 2 fracpartial Psipartial mathbfC","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"and the tangent of mathbfS as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"fracpartial mathbfSpartial mathbfC = 4 fracpartial Psipartial mathbfC","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"We can implement the material model as follows, where we utilize automatic differentiation for the stress and the tangent, and thus only define the potential:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"struct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 4.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Finally, for the finite element problem we need mathbfP and fracpartial mathbfPpartial mathbfF, which can be obtained by using the following relations:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"beginalign*\nmathbfP = mathbfF cdot mathbfS\nfracpartial mathbfPpartial mathbfF = mathbfF barotimes mathbfI \nfracpartial mathbfSpartial mathbfC  mathbfF^mathrmT barotimes mathbfI\n+ mathbfI barotimes mathbfS\nendalign*","category":"page"},{"location":"examples/hyperelasticity/#Newton's-Method","page":"Hyperelasticity","title":"Newton's Method","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"As mentioned above, to deal with the non-linear weak form we first linearize the problem such that we can apply Newton's method, and then apply the FEM to discretize the problem. Skipping a detailed derivation, Newton's method can be expressed as: Given some initial guess mathbfu^0, find a sequence mathbfu^k by iterating","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"mathbfu^k+1 = mathbfu^k - Delta mathbfu^k","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"until some termination condition has been met. Therein we determine Delta mathbfu^k","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"mathbfK(mathbfu^k) Delta mathbfu^k = mathbfg(mathbfu^k)","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where mathbfg is the global residual and mathbfK = fracpartial gpartial u the Jacobi matrix, such that","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"K_ij = int_Omega nabla_mathbfX delta mathbfu_i  fracpartial mathbfPpartial mathbfF  nabla_mathbfX delta mathbfu_j  mathrmd Omega","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"and","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"g_i = int_Omega nabla_mathbfX delta mathbfu_i  mathbfP - delta mathbfu_i cdot mathbfb  mathrmd Omega","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"A detailed derivation can be found in every continuum mechanics book, which has a chapter about finite elasticity theory. We used \"Nonlinear solid mechanics: a continuum approach for engineering science.\" by Gerhard Holzapfel (chapter 8) as a reference.","category":"page"},{"location":"examples/hyperelasticity/#Finite-element-assembly","page":"Hyperelasticity","title":"Finite element assembly","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The element routine for assembling the residual and tangent stiffness is implemented as usual, with loops over quadrature points and shape functions:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    t = Vec{3}((0.1, 0.0, 0.0)) # Traction\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F)\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function + gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face)\n            reinit!(fv, cell, face)\n            for q_point in 1:getnquadpoints(fv)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Assembling global residual and tangent","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function assemble_global!(K, f, dh, cv, fv, mp, u)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and f\n    assembler = start_assemble(K, f)\n\n    # Loop over all cells in the grid\n    @timeit \"assemble\" for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n        assemble!(assembler, global_dofs, ge, ke)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Define a main function, with a loop for Newton iterations","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    qr = QuadratureRule{3, RefTetrahedron}(1)\n    qr_face = QuadratureRule{2, RefTetrahedron}(1)\n    cv = CellVectorValues(qr, ip)\n    fv = FaceVectorValues(qr_face, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    push!(dh, :u, 3) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t, θ = deg2rad(60.0))\n        x, y, z = X\n        return t * Vec{3}(\n            (0.0,\n            L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n            L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n            ))\n    end\n\n    dbcs = ConstraintHandler(dh)\n    # Add a homogenous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(dbcs, dbc)\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\n    add!(dbcs, dbc)\n    close!(dbcs)\n    t = 0.5\n    Ferrite.update!(dbcs, t)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u  = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, dbcs)\n\n    # Create sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    g = zeros(_ndofs)\n\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1e-8\n    prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\n    while true; newton_itr += 1\n        u .= un .+ Δu # Current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u)\n        normg = norm(g[Ferrite.free_dofs(dbcs)])\n        apply_zero!(K, g, dbcs)\n        ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > 30\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using cg! from IterativeSolvers.jl\n        @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n        @assert flag == 0\n        @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n        apply_zero!(ΔΔu, dbcs)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        vtk_grid(\"hyperelasticity\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Run the simulation","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"u = solve();\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/#Plain-program","page":"Hyperelasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Here follows a version of the program without any comments. The file is also available here: hyperelasticity.jl.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Ferrite, Tensors, TimerOutputs, ProgressMeter\nimport KrylovMethods, IterativeSolvers\n\nstruct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 4.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\n\nfunction assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    t = Vec{3}((0.1, 0.0, 0.0)) # Traction\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F)\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function + gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face)\n            reinit!(fv, cell, face)\n            for q_point in 1:getnquadpoints(fv)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend;\n\nfunction assemble_global!(K, f, dh, cv, fv, mp, u)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and f\n    assembler = start_assemble(K, f)\n\n    # Loop over all cells in the grid\n    @timeit \"assemble\" for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n        assemble!(assembler, global_dofs, ge, ke)\n    end\nend;\n\nfunction solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    qr = QuadratureRule{3, RefTetrahedron}(1)\n    qr_face = QuadratureRule{2, RefTetrahedron}(1)\n    cv = CellVectorValues(qr, ip)\n    fv = FaceVectorValues(qr_face, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    push!(dh, :u, 3) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t, θ = deg2rad(60.0))\n        x, y, z = X\n        return t * Vec{3}(\n            (0.0,\n            L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n            L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n            ))\n    end\n\n    dbcs = ConstraintHandler(dh)\n    # Add a homogenous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(dbcs, dbc)\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\n    add!(dbcs, dbc)\n    close!(dbcs)\n    t = 0.5\n    Ferrite.update!(dbcs, t)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u  = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, dbcs)\n\n    # Create sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    g = zeros(_ndofs)\n\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1e-8\n    prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\n    while true; newton_itr += 1\n        u .= un .+ Δu # Current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u)\n        normg = norm(g[Ferrite.free_dofs(dbcs)])\n        apply_zero!(K, g, dbcs)\n        ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > 30\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using cg! from IterativeSolvers.jl\n        @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n        @assert flag == 0\n        @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n        apply_zero!(ΔΔu, dbcs)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        vtk_grid(\"hyperelasticity\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend\n\nu = solve();","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#von-Mises-plasticity","page":"von Mises plasticity","title":"von Mises plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"(Image: Shows the von Mises stress distribution in a cantilever beam.)","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Figure 1. A coarse mesh solution of a cantilever beam subjected to a load causing plastic deformations. The initial yield limit is 200 MPa but due to hardening it increases up to approximately 240 MPa.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: plasticity.ipynb.","category":"page"},{"location":"examples/plasticity/#Introduction","page":"von Mises plasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This example illustrates the use of a nonlinear material model in Ferrite. The particular model is von Mises plasticity (also know as J₂-plasticity) with isotropic hardening. The model is fully 3D, meaning that no assumptions like plane stress or plane strain are introduced.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Also note that the theory of the model is not described here, instead one is referred to standard textbooks on material modeling.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"To illustrate the use of the plasticity model, we setup and solve a FE-problem consisting of a cantilever beam loaded at its free end. But first, we shortly describe the parts of the implementation deadling with the material modeling.","category":"page"},{"location":"examples/plasticity/#Material-modeling","page":"von Mises plasticity","title":"Material modeling","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This section describes the structs and methods used to implement the material model","category":"page"},{"location":"examples/plasticity/#Material-parameters-and-state-variables","page":"von Mises plasticity","title":"Material parameters and state variables","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Start by loading some necessary packages","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra, Printf","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"We define a J₂-plasticity-material, containing material parameters and the elastic stiffness Dᵉ (since it is constant)","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"struct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}}\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Next, we define a constructor for the material instance.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function J2Plasticity(E, ν, σ₀, H)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"note: Note\nAbove, we defined a constructor J2Plasticity(E, ν, σ₀, H) in terms of the more common material parameters E and ν - simply as a convenience for the user.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Define a struct to store the material state for a Gauss point.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"struct MaterialState{T, S <: SecondOrderTensor{3, T}}\n    # Store \"converged\" values\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Constructor for initializing a material state. Every quantity is set to zero.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function MaterialState()\n    return MaterialState(\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0)\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"For later use, during the post-processing step, we define a function to compute the von Mises effective stress.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function vonMises(σ)\n    s = dev(σ)\n    return sqrt(3.0/2.0 * s ⊡ s)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Constitutive-driver","page":"von Mises plasticity","title":"Constitutive driver","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This is the actual method which computes the stress and material tangent stiffness in a given integration point. Input is the current strain and the material state from the previous timestep.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function compute_stress_tangent(ϵ::SymmetricTensor{2, 3}, material::J2Plasticity, state::MaterialState)\n    # unpack some material parameters\n    G = material.G\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ   # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effective trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        return σᵗ, material.Dᵉ, MaterialState(state.ϵᵖ, σᵗ, state.k)\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Return new state\n        Δϵᵖ = 3/2 * μ / σₑ * s # plastic strain\n        ϵᵖ = state.ϵᵖ + Δϵᵖ    # plastic strain\n        k = state.k + μ        # hardening variable\n        return σ, D, MaterialState(ϵᵖ, σ, k)\n    end\nend","category":"page"},{"location":"examples/plasticity/#FE-problem","page":"von Mises plasticity","title":"FE-problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"What follows are methods for assembling and and solving the FE-problem.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_values(interpolation)\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for u)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    return cellvalues_u, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Add-degrees-of-freedom","page":"von Mises plasticity","title":"Add degrees of freedom","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_dofhandler(grid, interpolation)\n    dh = DofHandler(grid)\n    dim = 3\n    push!(dh, :u, dim, interpolation) # add a displacement field with 3 components\n    close!(dh)\n    return dh\nend","category":"page"},{"location":"examples/plasticity/#Boundary-conditions","page":"von Mises plasticity","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_bc(dh, grid)\n    dbcs = ConstraintHandler(dh)\n    # Clamped on the left side\n    dofs = [1, 2, 3]\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], dofs)\n    add!(dbcs, dbc)\n    close!(dbcs)\n    return dbcs\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Assembling-of-element-contributions","page":"von Mises plasticity","title":"Assembling of element contributions","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Residual vector r\nTangent stiffness K","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function doassemble(cellvalues::CellVectorValues{dim},\n                    facevalues::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, material::J2Plasticity, u, states, states_old, t) where {dim}\n    r = zeros(ndofs(dh))\n    assembler = start_assemble(K, r)\n    nu = getnbasefunctions(cellvalues)\n    re = zeros(nu)     # element residual vector\n    ke = zeros(nu, nu) # element tangent matrix\n\n    for (i, cell) in enumerate(CellIterator(dh))\n        fill!(ke, 0)\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        ue = u[eldofs]\n        state = @view states[:, i]\n        state_old = @view states_old[:, i]\n        assemble_cell!(ke, re, cell, cellvalues, facevalues, grid, material,\n                       ue, state, state_old, t)\n        assemble!(assembler, eldofs, re, ke)\n    end\n    return K, r\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Compute element contribution to the residual and the tangent.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"note: Note\nDue to symmetry, we only compute the lower half of the tangent and then symmetrize it.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function assemble_cell!(Ke, re, cell, cellvalues, facevalues, grid, material,\n                        ue, state, state_old, t)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    reinit!(cellvalues, cell)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state_old[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i # loop only over lower half\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\n\n    # Add traction as a negative contribution to the element residual `re`:\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n            reinit!(facevalues, cell, face)\n            for q_point in 1:getnquadpoints(facevalues)\n                dΓ = getdetJdV(facevalues, q_point)\n                for i in 1:n_basefuncs\n                    δu = shape_value(facevalues, q_point, i)\n                    re[i] -= (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Helper function to symmetrize the material tangent","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Define a function which solves the FE-problem.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function solve()\n    # Define material parameters\n    E = 200.0e9 # [Pa]\n    H = E/20   # [Pa]\n    ν = 0.3     # [-]\n    σ₀ = 200e6  # [Pa]\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0 # beam length [m]\n    w = 1.0  # beam width [m]\n    h = 1.0  # beam height[m]\n    n_timesteps = 10\n    u_max = zeros(n_timesteps)\n    traction_magnitude = 1.e7 * range(0.5, 1.0, length=n_timesteps)\n\n    # Create geometry, dofs and boundary conditions\n    n = 2\n    nels = (10n, n, 2n) # number of elements in each spatial direction\n    P1 = Vec((0.0, 0.0, 0.0))  # start point for geometry\n    P2 = Vec((L, w, h))        # end point for geometry\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}() # Linear tet with 3 unknowns/node\n\n    dh = create_dofhandler(grid, interpolation) # JuaFEM helper function\n    dbcs = create_bc(dh, grid) # create Dirichlet boundary-conditions\n\n    cellvalues, facevalues = create_values(interpolation)\n\n    # Pre-allocate solution vectors, etc.\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)  # solution vector\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    # Create material states. One array for each cell, where each element is an array of material-\n    # states - one for each integration point\n    nqp = getnquadpoints(cellvalues)\n    states = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n    states_old = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n    print(\"\\n Starting Netwon iterations:\\n\")\n\n    for timestep in 1:n_timesteps\n        t = timestep # actual time (used for evaluating d-bndc)\n        traction = Vec((0.0, 0.0, traction_magnitude[timestep]))\n        newton_itr = -1\n        print(\"\\n Time step @time = $timestep:\\n\")\n        update!(dbcs, t) # evaluates the D-bndc at time t\n        apply!(u, dbcs)  # set the prescribed values in the solution vector\n\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, states_old, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            print(\"Iteration: $newton_itr \\tresidual: $(@sprintf(\"%.8f\", norm_r))\\n\")\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        # Update the old states with the converged values for next timestep\n        states_old .= states\n\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # ## Postprocessing\n    # Only a vtu-file corrsponding to the last time-step is exported.\n    #\n    # The following is a quick (and dirty) way of extracting average cell data for export.\n    mises_values = zeros(getncells(grid))\n    κ_values = zeros(getncells(grid))\n    for (el, cell_states) in enumerate(eachcol(states))\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n            κ_values[el] += state.k*material.H\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n        κ_values[el] /= length(cell_states)     # average drag stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n        vtk_cell_data(vtkfile, κ_values, \"Drag stress [Pa]\")\n    end\n\n    return u_max, traction_magnitude\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Solve the FE-problem and for each time-step extract maximum displacement and the corresponding traction load. Also compute the limit-traction-load","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"u_max, traction_magnitude = solve();\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Finally we plot the load-displacement curve.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Plots\nplot(\n    vcat(0.0, u_max),                # add the origin as a point\n    vcat(0.0, traction_magnitude),\n    linewidth=2,\n    title=\"Traction-displacement\",\n    label=nothing,\n    markershape=:auto\n    )\nylabel!(\"Traction [Pa]\")\nxlabel!(\"Maximum deflection [m]\")","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Figure 2. Load-displacement-curve for the beam, showing a clear decrease in stiffness as more material starts to yield.","category":"page"},{"location":"examples/plasticity/#plasticity-plain-program","page":"von Mises plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra, Printf\n\nstruct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}}\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend;\n\nfunction J2Plasticity(E, ν, σ₀, H)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\n\nstruct MaterialState{T, S <: SecondOrderTensor{3, T}}\n    # Store \"converged\" values\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\nend\n\nfunction MaterialState()\n    return MaterialState(\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0)\nend\n\nfunction vonMises(σ)\n    s = dev(σ)\n    return sqrt(3.0/2.0 * s ⊡ s)\nend;\n\nfunction compute_stress_tangent(ϵ::SymmetricTensor{2, 3}, material::J2Plasticity, state::MaterialState)\n    # unpack some material parameters\n    G = material.G\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ   # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effective trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        return σᵗ, material.Dᵉ, MaterialState(state.ϵᵖ, σᵗ, state.k)\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Return new state\n        Δϵᵖ = 3/2 * μ / σₑ * s # plastic strain\n        ϵᵖ = state.ϵᵖ + Δϵᵖ    # plastic strain\n        k = state.k + μ        # hardening variable\n        return σ, D, MaterialState(ϵᵖ, σ, k)\n    end\nend\n\nfunction create_values(interpolation)\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for u)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    return cellvalues_u, facevalues_u\nend;\n\nfunction create_dofhandler(grid, interpolation)\n    dh = DofHandler(grid)\n    dim = 3\n    push!(dh, :u, dim, interpolation) # add a displacement field with 3 components\n    close!(dh)\n    return dh\nend\n\nfunction create_bc(dh, grid)\n    dbcs = ConstraintHandler(dh)\n    # Clamped on the left side\n    dofs = [1, 2, 3]\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], dofs)\n    add!(dbcs, dbc)\n    close!(dbcs)\n    return dbcs\nend;\n\nfunction doassemble(cellvalues::CellVectorValues{dim},\n                    facevalues::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, material::J2Plasticity, u, states, states_old, t) where {dim}\n    r = zeros(ndofs(dh))\n    assembler = start_assemble(K, r)\n    nu = getnbasefunctions(cellvalues)\n    re = zeros(nu)     # element residual vector\n    ke = zeros(nu, nu) # element tangent matrix\n\n    for (i, cell) in enumerate(CellIterator(dh))\n        fill!(ke, 0)\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        ue = u[eldofs]\n        state = @view states[:, i]\n        state_old = @view states_old[:, i]\n        assemble_cell!(ke, re, cell, cellvalues, facevalues, grid, material,\n                       ue, state, state_old, t)\n        assemble!(assembler, eldofs, re, ke)\n    end\n    return K, r\nend\n\nfunction assemble_cell!(Ke, re, cell, cellvalues, facevalues, grid, material,\n                        ue, state, state_old, t)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    reinit!(cellvalues, cell)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state_old[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i # loop only over lower half\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\n\n    # Add traction as a negative contribution to the element residual `re`:\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n            reinit!(facevalues, cell, face)\n            for q_point in 1:getnquadpoints(facevalues)\n                dΓ = getdetJdV(facevalues, q_point)\n                for i in 1:n_basefuncs\n                    δu = shape_value(facevalues, q_point, i)\n                    re[i] -= (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nfunction solve()\n    # Define material parameters\n    E = 200.0e9 # [Pa]\n    H = E/20   # [Pa]\n    ν = 0.3     # [-]\n    σ₀ = 200e6  # [Pa]\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0 # beam length [m]\n    w = 1.0  # beam width [m]\n    h = 1.0  # beam height[m]\n    n_timesteps = 10\n    u_max = zeros(n_timesteps)\n    traction_magnitude = 1.e7 * range(0.5, 1.0, length=n_timesteps)\n\n    # Create geometry, dofs and boundary conditions\n    n = 2\n    nels = (10n, n, 2n) # number of elements in each spatial direction\n    P1 = Vec((0.0, 0.0, 0.0))  # start point for geometry\n    P2 = Vec((L, w, h))        # end point for geometry\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}() # Linear tet with 3 unknowns/node\n\n    dh = create_dofhandler(grid, interpolation) # JuaFEM helper function\n    dbcs = create_bc(dh, grid) # create Dirichlet boundary-conditions\n\n    cellvalues, facevalues = create_values(interpolation)\n\n    # Pre-allocate solution vectors, etc.\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)  # solution vector\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    # Create material states. One array for each cell, where each element is an array of material-\n    # states - one for each integration point\n    nqp = getnquadpoints(cellvalues)\n    states = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n    states_old = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n    print(\"\\n Starting Netwon iterations:\\n\")\n\n    for timestep in 1:n_timesteps\n        t = timestep # actual time (used for evaluating d-bndc)\n        traction = Vec((0.0, 0.0, traction_magnitude[timestep]))\n        newton_itr = -1\n        print(\"\\n Time step @time = $timestep:\\n\")\n        update!(dbcs, t) # evaluates the D-bndc at time t\n        apply!(u, dbcs)  # set the prescribed values in the solution vector\n\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, states_old, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            print(\"Iteration: $newton_itr \\tresidual: $(@sprintf(\"%.8f\", norm_r))\\n\")\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        # Update the old states with the converged values for next timestep\n        states_old .= states\n\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # ## Postprocessing\n    # Only a vtu-file corrsponding to the last time-step is exported.\n    #\n    # The following is a quick (and dirty) way of extracting average cell data for export.\n    mises_values = zeros(getncells(grid))\n    κ_values = zeros(getncells(grid))\n    for (el, cell_states) in enumerate(eachcol(states))\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n            κ_values[el] += state.k*material.H\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n        κ_values[el] /= length(cell_states)     # average drag stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n        vtk_cell_data(vtkfile, κ_values, \"Drag stress [Pa]\")\n    end\n\n    return u_max, traction_magnitude\nend\n\nu_max, traction_magnitude = solve();\n\nusing Plots\nplot(\n    vcat(0.0, u_max),                # add the origin as a point\n    vcat(0.0, traction_magnitude),\n    linewidth=2,\n    title=\"Traction-displacement\",\n    label=nothing,\n    markershape=:auto\n    )\nylabel!(\"Traction [Pa]\")\nxlabel!(\"Maximum deflection [m]\")","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/helmholtz.jl\"","category":"page"},{"location":"examples/helmholtz/#Helmholtz-equation","page":"Helmholtz equation","title":"Helmholtz equation","text":"","category":"section"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"In this example, we want to solve a (variant of) of the Helmholtz equation. The example is inspired by an dealii step_7 on the standard square.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":" - Delta u + u = f","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"With boundary conditions given by","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"u = g_1 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"and","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"n cdot nabla u = g_2 quad x in Gamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"Here Γ₁ is the union of the top and the right boundary of the square, while Γ₂ is the union of the bottom and the left boundary.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"(Image: )","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"We will use the following weak formulation:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int nabla δu cdot nabla u dOmega\n+ int δu cdot u dOmega\n- int δu cdot f dOmega\n- int δu g_2 dGamma_2 = 0 forall δu","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"where δu is a suitable test function that satisfies:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"δu = 0 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"and u is a suitable function that satisfies:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"u = g_1 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"The example highlights the following interesting features:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"There are two kinds of boundary conditions, \"Dirichlet\" and \"Von Neumann\"\nThe example contains boundary integrals\nThe Dirichlet condition is imposed strongly and the Von Neumann condition is imposed weakly.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"using Ferrite\nusing Tensors\nusing SparseArrays\nusing LinearAlgebra\n\nconst ∇ = Tensors.gradient\nconst Δ = Tensors.hessian;\n\ngrid = generate_grid(Quadrilateral, (150, 150))\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\nqr_face = QuadratureRule{dim-1, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nfacevalues = FaceScalarValues(qr_face, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"We will set things up, so that a known analytic solution is approximately reproduced. This is a good testing strategy for PDE codes and known as the method of manufactured solutions.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"function u_ana(x::Vec{2, T}) where {T}\n    xs = (Vec{2}((-0.5,  0.5)),\n          Vec{2}((-0.5, -0.5)),\n          Vec{2}(( 0.5,  -0.5)))\n    σ = 1/8\n    s = zero(eltype(x))\n    for i in 1:3\n        s += exp(- norm(x - xs[i])^2 / σ^2)\n    end\n    return max(1e-15 * one(T), s) # Denormals, be gone\nend;\n\ndbcs = ConstraintHandler(dh)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"The (strong) Dirichlet boundary condition can be handled automatically by the Ferrite library.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"dbc = Dirichlet(:u, union(getfaceset(grid, \"top\"), getfaceset(grid, \"right\")), (x,t) -> u_ana(x))\nadd!(dbcs, dbc)\nclose!(dbcs)\nupdate!(dbcs, 0.0)\n\nK = create_sparsity_pattern(dh);\n\nfunction doassemble(cellvalues::CellScalarValues{dim}, facevalues::FaceScalarValues{dim},\n                         K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    b = 1.0\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    global_dofs = zeros(Int, ndofs_per_cell(dh))\n\n    fe = zeros(n_basefuncs) # Local force vector\n    Ke = zeros(n_basefuncs, n_basefuncs) # Local stiffness mastrix\n\n    @inbounds for (cellcount, cell) in enumerate(CellIterator(dh))\n        fill!(Ke, 0)\n        fill!(fe, 0)\n        coords = getcoordinates(cell)\n\n        reinit!(cellvalues, cell)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"First we derive the non boundary part of the variation problem from the destined solution u_ana","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int nabla δu cdot nabla u dOmega\n+ int δu cdot u dOmega\n- int δu cdot f dOmega","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            coords_qp = spatial_coordinate(cellvalues, q_point, coords)\n            f_true = -LinearAlgebra.tr(hessian(u_ana, coords_qp)) + u_ana(coords_qp)\n            for i in 1:n_basefuncs\n                δu = shape_value(cellvalues, q_point, i)\n                ∇δu = shape_gradient(cellvalues, q_point, i)\n                fe[i] += (δu * f_true) * dΩ\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇δu ⋅ ∇u + δu * u) * dΩ\n                end\n            end\n        end","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"Now we manually add the von Neumann boundary terms","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int δu g_2 dGamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"        for face in 1:nfaces(cell)\n            if onboundary(cell, face) &&\n                   ((cellcount, face) ∈ getfaceset(grid, \"left\") ||\n                    (cellcount, face) ∈ getfaceset(grid, \"bottom\"))\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    coords_qp = spatial_coordinate(facevalues, q_point, coords)\n                    n = getnormal(facevalues, q_point)\n                    g_2 = gradient(u_ana, coords_qp) ⋅ n\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:n_basefuncs\n                        δu = shape_value(facevalues, q_point, i)\n                        fe[i] += (δu * g_2) * dΓ\n                    end\n                end\n            end\n        end\n\n        celldofs!(global_dofs, cell)\n        assemble!(assembler, global_dofs, fe, Ke)\n    end\n    return K, f\nend;\n\nK, f = doassemble(cellvalues, facevalues, K, dh);\napply!(K, f, dbcs)\nu = Symmetric(K) \\ f;\n\nvtkfile = vtk_grid(\"helmholtz\", dh)\nvtk_point_data(vtkfile, dh, u)\nvtk_save(vtkfile)\nprintln(\"Helmholtz successful\")","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"In Ferrite a Grid is a collection of Nodes and Cells and is parameterized in its physical dimensionality and cell type. Nodes are points in the physical space and can be initialized by a N-Tuple, where N corresponds to the dimensions.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"n1 = Node((0.0, 0.0))","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Cells are defined based on the Node IDs. Hence, they collect IDs in a N-Tuple. Consider the following 2D mesh:","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"(Image: global mesh)","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The cells of the grid can be described in the following way","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> elements = [\n              (1,2,5,4),\n              (2,3,6,5),\n              (4,5,8,7),\n              (5,6,9,8)\n       ]","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Additionally, the data structure Grid can hold node-, face- and cellsets.  All of these three sets are defined by a dictionary that maps a string key to a Set.  For the special case of node- and cellsets the dictionary's value is of type Set{Int}, i.e. a keyword is mapped to a node or cell ID, respectively. ","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Facesets are a more elaborate construction. They map a String key to a Set{Int, Int} consisting of (global_cell_id, local_face_id). In order to understand the local_face_id properly, one has to consider the reference space of the element, which typically is spanned by a product of the interval -1 1 and in this particular example -1 1 times -1 1.  In this space a local numbering of nodes and faces exists, i.e.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"(Image: local element)","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The example shows a local face ID ordering, defined as:","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"faces(::Lagrange{2,RefCube,1}) = ((1,2), (2,3), (3,4), (4,1))","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Other face ID definitions can be found in the src files in the corresponding faces dispatch.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The highlighted face, i.e. the two lines from node ID 3 to 6 and from 6 to 9, on the right hand side of our test mesh can now be described as","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> edges = [\n           (3,6),\n           (6,9)\n       ]","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The local ID can be constructed based on elements, corresponding edges and chosen interpolation, since the face ordering is interpolation dependent.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> function compute_faceset(elements, edges, ip::Interpolation{dim}) where {dim}\n           local_faces = Ferrite.faces(ip)\n           nodes_per_face = length(local_faces[1])\n           d = Dict{NTuple{nodes_per_face, Int}, Tuple{Int, Int}}()\n           for (e, element) in enumerate(elements) # e is global element number\n               for (f, face) in enumerate(local_faces) # f is local face number\n                   # store the global nodes for the particular element, local face combination\n                   d[ntuple(i-> element[face[i]], nodes_per_face)] = (e, f)\n               end\n           end\n       \n           faces = Set{Tuple{Int, Int}}()\n           for edge in edges\n               # lookup the element, local face combination for this edge\n               push!(faces, d[edge])\n           end\n       \n           return faces\n       end\n\njulia> interpolation = Lagrange{2, RefTetrahedron, 1}()\n\njulia> compute_faceset(elements, edges, interpolation)\nSet{Tuple{Int64,Int64}} with 2 elements:\n  (2, 2)\n  (4, 2)","category":"page"},{"location":"manual/grid/#Topology","page":"Grid","title":"Topology","text":"","category":"section"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Ferrite.jl's Grid type offers experimental features w.r.t. topology information. The functions Ferrite.full_neighborhood and Ferrite.faceskeleton are the interface to obtain topological information. The Ferrite.full_neighborhood can construct lists of directly connected entities based on a given entity (CellIndex,FaceIndex,EdgeIndex,VertexIndex). The Ferrite.faceskeleton function can be used to evaluate integrals over material interfaces or computing element interface values such as jumps.","category":"page"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"QuadratureRule\nAbstractRefShape\ngetpoints\ngetweights","category":"page"},{"location":"reference/quadrature/#Ferrite.QuadratureRule","page":"Quadrature","title":"Ferrite.QuadratureRule","text":"QuadratureRule{dim,shape}([quad_rule_type::Symbol], order::Int)\n\nCreate a QuadratureRule used for integration. dim is the space dimension, shape an AbstractRefShape and order the order of the quadrature rule. quad_rule_type is an optional argument determining the type of quadrature rule, currently the :legendre and :lobatto rules are implemented.\n\nA QuadratureRule is used to approximate an integral on a domain by a weighted sum of function values at specific points:\n\nintlimits_Omega f(mathbfx) textd Omega approx sumlimits_q = 1^n_q f(mathbfx_q) w_q\n\nThe quadrature rule consists of n_q points in space mathbfx_q with corresponding weights w_q.\n\nIn Ferrite, the QuadratureRule type is mostly used as one of the components to create a CellValues or FaceValues object.\n\nCommon methods:\n\ngetpoints : the points of the quadrature rule\ngetweights : the weights of the quadrature rule\n\nExample:\n\njulia> QuadratureRule{2, RefTetrahedron}(1)\nFerrite.QuadratureRule{2,Ferrite.RefTetrahedron,Float64}([0.5], Tensors.Tensor{1,2,Float64,2}[[0.333333, 0.333333]])\n\njulia> QuadratureRule{1, RefCube}(:lobatto, 2)\nFerrite.QuadratureRule{1,Ferrite.RefCube,Float64}([1.0, 1.0], Tensors.Tensor{1,1,Float64,1}[[-1.0], [1.0]])\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.AbstractRefShape","page":"Quadrature","title":"Ferrite.AbstractRefShape","text":"Represents a reference shape which quadrature rules and interpolations are defined on. Currently, the only concrete types that subtype this type are RefCube in 1, 2 and 3 dimensions, and RefTetrahedron in 2 and 3 dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.getpoints","page":"Quadrature","title":"Ferrite.getpoints","text":"getpoints(qr::QuadratureRule)\n\nReturn the points of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{2, RefTetrahedron}(:legendre, 2);\n\njulia> getpoints(qr)\n3-element Array{Tensors.Tensor{1,2,Float64,2},1}:\n [0.166667, 0.166667]\n [0.166667, 0.666667]\n [0.666667, 0.166667]\n\n\n\n\n\n","category":"function"},{"location":"reference/quadrature/#Ferrite.getweights","page":"Quadrature","title":"Ferrite.getweights","text":"getweights(qr::QuadratureRule)\n\nReturn the weights of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{2, RefTetrahedron}(:legendre, 2);\n\njulia> getweights(qr)\n3-element Array{Float64,1}:\n 0.166667\n 0.166667\n 0.166667\n\n\n\n\n\n","category":"function"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/transient_heat_equation.jl\"","category":"page"},{"location":"examples/transient_heat_equation/#Time-Dependent-Problems","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"(Image: )","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Figure 1: Visualization of the temperature time evolution on a unit square where the prescribed temperature on the upper and lower parts of the boundary increase with time.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"tip: Tip\nThis example is also available as a Jupyter notebook: transient_heat_equation.ipynb.","category":"page"},{"location":"examples/transient_heat_equation/#Introduction","page":"Time Dependent Problems","title":"Introduction","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In this example we extend the heat equation by a time dependent term, i.e.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":" fracpartial upartial t-nabla cdot (k nabla u) = f  quad x in Omega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set f = 1 and k = 1. We define homogeneous Dirichlet boundary conditions along the left and right edge of the domain.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"u(xt) = 0 quad x in partial Omega_1","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where partial Omega_1 denotes the left and right boundary of Omega.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Further, we define heterogeneous Dirichlet boundary conditions at the top and bottom edge partial Omega_2. We choose a linearly increasing function a(t) that describes the temperature at this boundary","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"u(xt) = a(t) quad x in partial Omega_2","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"The semidiscrete weak form is given by","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"int_Omegafracpartial upartial tcdot v  dOmega + int_Omega nabla v cdot nabla u  dOmega = int_Omega v  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where v is a suitable test function. Now, we still need to discretize the time derivative. An implicit Euler scheme is applied, which yields:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"int_Omegau_n+1cdot v  dOmega + Delta tint_Omega nabla v cdot nabla u_n+1  dOmega = Delta tint_Omega v  dOmega + int_Omega u_ncdot v  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"If we assemble the discrete operators, we get the following algebraic system:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"mathbfM mathbfu_n+1 + Δt mathbfK mathbfu_n+1 = Δt mathbff + mathbfM mathbfu_n","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In this example we apply the boundary conditions to the assembled discrete operators (mass matrix mathbfM and stiffnes matrix mathbfK) only once. We utilize the fact that in finite element computations Dirichlet conditions can be applied by zero out rows and columns that correspond to a prescribed dof in the system matrix (mathbfA = Δt mathbfK + mathbfM) and setting the value of the right-hand side vector to the value of the Dirichlet condition. Thus, we only need to apply in every time step the Dirichlet condition to the right-hand side of the problem.","category":"page"},{"location":"examples/transient_heat_equation/#Commented-Program","page":"Time Dependent Problems","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"First we load Ferrite, and some other packages we need.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"using Ferrite, SparseArrays","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We create the same grid as in the heat equation example.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"grid = generate_grid(Quadrilateral, (100, 100));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Trial-and-test-functions","page":"Time Dependent Problems","title":"Trial and test functions","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Again, we define the structs that are responsible for the shape_value and shape_gradient evaluation.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"dim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Degrees-of-freedom","page":"Time Dependent Problems","title":"Degrees of freedom","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"After this, we can define the DofHandler and distribute the DOFs of the problem.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"dh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"By means of the DofHandler we can allocate the needed SparseMatrixCSC. M refers here to the so called mass matrix, which always occurs in time related terms, i.e.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"M_ij = int_Omega u_i cdot v_j  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where u_i and v_j are trial and test functions, respectively.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"K = create_sparsity_pattern(dh);\nM = create_sparsity_pattern(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We also preallocate the right hand side","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"f = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Boundary-conditions","page":"Time Dependent Problems","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In order to define the time dependent problem, we need some end time T and something that describes the linearly increasing Dirichlet boundary condition on partial Omega_2.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"max_temp = 100\nΔt = 1\nT = 200\nch = ConstraintHandler(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here, we define the boundary condition related to partial Omega_1.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"∂Ω₁ = union(getfaceset.((grid, ), [\"left\", \"right\"])...)\ndbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\nadd!(ch, dbc);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"While the next code block corresponds to the linearly increasing temperature description on partial Omega_2.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"∂Ω₂ = union(getfaceset.((grid, ), [\"top\", \"bottom\"])...)\ndbc = Dirichlet(:u, ∂Ω₂, (x, t) -> t*(max_temp/T))\nadd!(ch, dbc)\nclose!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Assembling-the-linear-system","page":"Time Dependent Problems","title":"Assembling the linear system","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"As in the heat equation example we define a doassemble! function that assembles the diffusion parts of the equation:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"function doassemble_K!(K::SparseMatrixCSC, f::Vector, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\nnothing # hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In addition to the diffusive part, we also need a function that assembles the mass matrix M.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"function doassemble_M!(M::SparseMatrixCSC, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Me = zeros(n_basefuncs, n_basefuncs)\n\n    assembler = start_assemble(M)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Me, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    Me[i, j] += (v ⋅ u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), Me)\n    end\n    return M\nend\nnothing # hide","category":"page"},{"location":"examples/transient_heat_equation/#Solution-of-the-system","page":"Time Dependent Problems","title":"Solution of the system","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We first assemble all parts in the prior allocated SparseMatrixCSC.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"K, f = doassemble_K!(K, f, cellvalues, dh)\nM = doassemble_M!(M, cellvalues, dh)\nA = (Δt .* K) + M;\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Now, we need to save all boundary condition related values of the unaltered system matrix A, which is done by get_rhs_data. The function returns a RHSData struct, which contains all needed informations to apply the boundary conditions solely on the right-hand-side vector of the problem.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"rhsdata = get_rhs_data(ch, A);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We set the initial time step, denoted by uₙ,  to mathbf0.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"uₙ = zeros(length(f));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here, we apply once the boundary conditions to the system matrix A.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"apply!(A, ch);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"To store the solution, we initialize a paraview_collection (.pvd) file.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"pvd = paraview_collection(\"transient-heat.pvd\");\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"At this point everything is set up and we can finally approach the time loop.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"for t in 0:Δt:T\n    #First of all, we need to update the Dirichlet boundary condition values.\n    update!(ch, t)\n\n    #Secondly, we compute the right-hand-side of the problem.\n    b = Δt .* f .+ M * uₙ\n    #Then, we can apply the boundary conditions of the current time step.\n    apply_rhs!(rhsdata, b, ch)\n\n    #Finally, we can solve the time step and save the solution afterwards.\n    u = A \\ b;\n\n    vtk_grid(\"transient-heat-$t\", dh) do vtk\n        vtk_point_data(vtk, dh, u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\n   #At the end of the time loop, we set the previous solution to the current one and go to the next time step.\n   uₙ .= u\nend","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In order to use the .pvd file we need to store it to the disk, which is done by:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"vtk_save(pvd);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#transient_heat_equation-plain-program","page":"Time Dependent Problems","title":"Plain program","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here follows a version of the program without any comments. The file is also available here: transient_heat_equation.jl.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"using Ferrite, SparseArrays\n\ngrid = generate_grid(Quadrilateral, (100, 100));\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\n\nK = create_sparsity_pattern(dh);\nM = create_sparsity_pattern(dh);\n\nf = zeros(ndofs(dh));\n\nmax_temp = 100\nΔt = 1\nT = 200\nch = ConstraintHandler(dh);\n\n∂Ω₁ = union(getfaceset.((grid, ), [\"left\", \"right\"])...)\ndbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\nadd!(ch, dbc);\n\n∂Ω₂ = union(getfaceset.((grid, ), [\"top\", \"bottom\"])...)\ndbc = Dirichlet(:u, ∂Ω₂, (x, t) -> t*(max_temp/T))\nadd!(ch, dbc)\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction doassemble_K!(K::SparseMatrixCSC, f::Vector, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\n\nfunction doassemble_M!(M::SparseMatrixCSC, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Me = zeros(n_basefuncs, n_basefuncs)\n\n    assembler = start_assemble(M)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Me, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    Me[i, j] += (v ⋅ u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), Me)\n    end\n    return M\nend\n\nK, f = doassemble_K!(K, f, cellvalues, dh)\nM = doassemble_M!(M, cellvalues, dh)\nA = (Δt .* K) + M;\n\nrhsdata = get_rhs_data(ch, A);\n\nuₙ = zeros(length(f));\n\napply!(A, ch);\n\npvd = paraview_collection(\"transient-heat.pvd\");\n\nfor t in 0:Δt:T\n    #First of all, we need to update the Dirichlet boundary condition values.\n    update!(ch, t)\n\n    #Secondly, we compute the right-hand-side of the problem.\n    b = Δt .* f .+ M * uₙ\n    #Then, we can apply the boundary conditions of the current time step.\n    apply_rhs!(rhsdata, b, ch)\n\n    #Finally, we can solve the time step and save the solution afterwards.\n    u = A \\ b;\n\n    vtk_grid(\"transient-heat-$t\", dh) do vtk\n        vtk_point_data(vtk, dh, u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\n   #At the end of the time loop, we set the previous solution to the current one and go to the next time step.\n   uₙ .= u\nend\n\nvtk_save(pvd);","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/landau.jl\"","category":"page"},{"location":"examples/landau/#Ginzburg-Landau-model-energy-minimization","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"(Image: landau_orig.png)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Original","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"(Image: landau_opt.png)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Optimized","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"In this example a basic Ginzburg-Landau model is solved. This example gives an idea of how the API together with ForwardDiff can be leveraged to performantly solve non standard problems on a FEM grid. A large portion of the code is there only for performance reasons, but since this usually really matters and is what takes the most time to optimize, it is included.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The key to using a method like this for minimizing a free energy function directly, rather than the weak form, as is usually done with FEM, is to split up the gradient and Hessian calculations. This means that they are performed for each cell seperately instead of for the grid as a whole.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"using ForwardDiff\nimport ForwardDiff: GradientConfig, HessianConfig, Chunk\nusing Ferrite\nusing Optim, LineSearches\nusing SparseArrays\nusing Tensors\nusing Base.Threads","category":"page"},{"location":"examples/landau/#Energy-terms","page":"Ginzburg-Landau model energy minimization","title":"Energy terms","text":"","category":"section"},{"location":"examples/landau/#th-order-Landau-free-energy","page":"Ginzburg-Landau model energy minimization","title":"4th order Landau free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function Fl(P::Vec{3, T}, α::Vec{3}) where T\n    P2 = Vec{3, T}((P[1]^2, P[2]^2, P[3]^2))\n    return (α[1] * sum(P2) +\n           α[2] * (P[1]^4 + P[2]^4 + P[3]^4)) +\n           α[3] * ((P2[1] * P2[2]  + P2[2]*P2[3]) + P2[1]*P2[3])\nend","category":"page"},{"location":"examples/landau/#Ginzburg-free-energy","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"@inline Fg(∇P, G) = 0.5(∇P ⊡ G) ⊡ ∇P","category":"page"},{"location":"examples/landau/#GL-free-energy","page":"Ginzburg-Landau model energy minimization","title":"GL free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"F(P, ∇P, params)  = Fl(P, params.α) + Fg(∇P, params.G)","category":"page"},{"location":"examples/landau/#Parameters-that-characterize-the-model","page":"Ginzburg-Landau model energy minimization","title":"Parameters that characterize the model","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"struct ModelParams{V, T}\n    α::V\n    G::T\nend","category":"page"},{"location":"examples/landau/#ThreadCache","page":"Ginzburg-Landau model energy minimization","title":"ThreadCache","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This holds the values that each thread will use during the assembly.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"struct ThreadCache{CV, T, DIM, F <: Function, GC <: GradientConfig, HC <: HessianConfig}\n    cvP              ::CV\n    element_indices  ::Vector{Int}\n    element_dofs     ::Vector{T}\n    element_gradient ::Vector{T}\n    element_hessian  ::Matrix{T}\n    element_coords   ::Vector{Vec{DIM, T}}\n    element_potential::F\n    gradconf         ::GC\n    hessconf         ::HC\nend\nfunction ThreadCache(dpc::Int, nodespercell, cvP::CellValues{DIM, T}, modelparams, elpotential) where {DIM, T}\n    element_indices  = zeros(Int, dpc)\n    element_dofs     = zeros(dpc)\n    element_gradient = zeros(dpc)\n    element_hessian  = zeros(dpc, dpc)\n    element_coords   = zeros(Vec{DIM, T}, nodespercell)\n    potfunc          = x -> elpotential(x, cvP, modelparams)\n    gradconf         = GradientConfig(potfunc, zeros(dpc), Chunk{12}())\n    hessconf         = HessianConfig(potfunc, zeros(dpc), Chunk{12}())\n    return ThreadCache(cvP, element_indices, element_dofs, element_gradient, element_hessian, element_coords, potfunc, gradconf, hessconf)\nend","category":"page"},{"location":"examples/landau/#The-Model","page":"Ginzburg-Landau model energy minimization","title":"The Model","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"everything is combined into a model.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"mutable struct LandauModel{T, DH <: DofHandler, CH <: ConstraintHandler, TC <: ThreadCache}\n    dofs          ::Vector{T}\n    dofhandler    ::DH\n    boundaryconds ::CH\n    threadindices ::Vector{Vector{Int}}\n    threadcaches  ::Vector{TC}\nend\n\nfunction LandauModel(α, G, gridsize, left::Vec{DIM, T}, right::Vec{DIM, T}, elpotential) where {DIM, T}\n    grid = generate_grid(Tetrahedron, gridsize, left, right)\n    threadindices = Ferrite.create_coloring(grid)\n\n    qr  = QuadratureRule{DIM, RefTetrahedron}(2)\n    cvP = CellVectorValues(qr, Lagrange{DIM, RefTetrahedron, 1}())\n\n    dofhandler = DofHandler(grid)\n    push!(dofhandler, :P, 3)\n    close!(dofhandler)\n\n    dofvector = zeros(ndofs(dofhandler))\n    startingconditions!(dofvector, dofhandler)\n    boundaryconds = ConstraintHandler(dofhandler)\n    #boundary conditions can be added but aren't necessary for optimization\n    #add!(boundaryconds, Dirichlet(:P, getfaceset(grid, \"left\"), (x, t) -> [0.0,0.0,0.53], [1,2,3]))\n    #add!(boundaryconds, Dirichlet(:P, getfaceset(grid, \"right\"), (x, t) -> [0.0,0.0,-0.53], [1,2,3]))\n    close!(boundaryconds)\n    update!(boundaryconds, 0.0)\n\n    apply!(dofvector, boundaryconds)\n\n    hessian = create_sparsity_pattern(dofhandler)\n    dpc = ndofs_per_cell(dofhandler)\n    cpc = length(grid.cells[1].nodes)\n    caches = [ThreadCache(dpc, cpc, copy(cvP), ModelParams(α, G), elpotential) for t=1:nthreads()]\n    return LandauModel(dofvector, dofhandler, boundaryconds, threadindices, caches)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"utility to quickly save a model","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function Ferrite.vtk_save(path, model, dofs=model.dofs)\n    vtkfile = vtk_grid(path, model.dofhandler)\n    vtk_point_data(vtkfile, model.dofhandler, dofs)\n    vtk_save(vtkfile)\nend","category":"page"},{"location":"examples/landau/#Assembly","page":"Ginzburg-Landau model energy minimization","title":"Assembly","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This macro defines most of the assembly step, since the structure is the same for the energy, gradient and Hessian calculations.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"macro assemble!(innerbody)\n    esc(quote\n        dofhandler = model.dofhandler\n        for indices in model.threadindices\n            @threads for i in indices\n                cache     = model.threadcaches[threadid()]\n                eldofs    = cache.element_dofs\n                nodeids   = dofhandler.grid.cells[i].nodes\n                for j=1:length(cache.element_coords)\n                    cache.element_coords[j] = dofhandler.grid.nodes[nodeids[j]].x\n                end\n                reinit!(cache.cvP, cache.element_coords)\n\n                celldofs!(cache.element_indices, dofhandler, i)\n                for j=1:length(cache.element_dofs)\n                    eldofs[j] = dofvector[cache.element_indices[j]]\n                end\n                $innerbody\n            end\n        end\n    end)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This calculates the total energy calculation of the grid","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function F(dofvector::Vector{T}, model) where T\n    outs = fill(zero(T), nthreads())\n    @assemble! begin\n        outs[threadid()] += cache.element_potential(eldofs)\n    end\n    return sum(outs)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The gradient calculation for each dof","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function ∇F!(∇f::Vector{T}, dofvector::Vector{T}, model::LandauModel{T}) where T\n    fill!(∇f, zero(T))\n    @assemble! begin\n        ForwardDiff.gradient!(cache.element_gradient, cache.element_potential, eldofs, cache.gradconf)\n        @inbounds assemble!(∇f, cache.element_indices, cache.element_gradient)\n    end\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The Hessian calculation for the whole grid","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function ∇²F!(∇²f::SparseMatrixCSC, dofvector::Vector{T}, model::LandauModel{T}) where T\n    assemblers = [start_assemble(∇²f) for t=1:nthreads()]\n    @assemble! begin\n        ForwardDiff.hessian!(cache.element_hessian, cache.element_potential, eldofs, cache.hessconf)\n        @inbounds assemble!(assemblers[threadid()], cache.element_indices, cache.element_hessian)\n    end\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"We can also calculate all things in one go!","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function calcall(∇²f::SparseMatrixCSC, ∇f::Vector{T}, dofvector::Vector{T}, model::LandauModel{T}) where T\n    outs = fill(zero(T), nthreads())\n    fill!(∇f, zero(T))\n    assemblers = [start_assemble(∇²f, ∇f) for t=1:nthreads()]\n    @assemble! begin\n        outs[threadid()] += cache.element_potential(eldofs)\n        ForwardDiff.hessian!(cache.element_hessian, cache.element_potential, eldofs, cache.hessconf)\n        ForwardDiff.gradient!(cache.element_gradient, cache.element_potential, eldofs, cache.gradconf)\n        @inbounds assemble!(assemblers[threadid()], cache.element_indices, cache.element_gradient, cache.element_hessian)\n    end\n    return sum(outs)\nend","category":"page"},{"location":"examples/landau/#Minimization","page":"Ginzburg-Landau model energy minimization","title":"Minimization","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Now everything can be combined to minimize the energy, and find the equilibrium configuration.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function minimize!(model; kwargs...)\n    dh = model.dofhandler\n    dofs = model.dofs\n    ∇f = fill(0.0, length(dofs))\n    ∇²f = create_sparsity_pattern(dh)\n    function g!(storage, x)\n        ∇F!(storage, x, model)\n        apply_zero!(storage, model.boundaryconds)\n    end\n    function h!(storage, x)\n        ∇²F!(storage, x, model)\n        #apply!(storage, model.boundaryconds)\n    end\n    f(x) = F(x, model)\n\n    od = TwiceDifferentiable(f, g!, h!, model.dofs, 0.0, ∇f, ∇²f)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"this way of minimizing is only beneficial when the initial guess is completely off, then a quick couple of ConjuageGradient steps brings us easily closer to the minimum. res = optimize(od, model.dofs, ConjugateGradient(linesearch=BackTracking()), Optim.Options(showtrace=true, showevery=1, g_tol=1e-20, iterations=10)) model.dofs .= res.minimizer to get the final convergence, Newton's method is more ideal since the energy landscape should be almost parabolic","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"    res = optimize(od, model.dofs, Newton(linesearch=BackTracking()), Optim.Options(show_trace=true, show_every=1, g_tol=1e-20))\n    model.dofs .= res.minimizer\n    return res\nend","category":"page"},{"location":"examples/landau/#Testing-it","page":"Ginzburg-Landau model energy minimization","title":"Testing it","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This calculates the contribution of each element to the total energy, it is also the function that will be put through ForwardDiff for the gradient and Hessian.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function element_potential(eldofs::AbstractVector{T}, cvP, params) where T\n    energy = zero(T)\n    for qp=1:getnquadpoints(cvP)\n        P  = function_value(cvP, qp, eldofs)\n        ∇P = function_gradient(cvP, qp, eldofs)\n        energy += F(P, ∇P, params) * getdetJdV(cvP, qp)\n    end\n    return energy\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"now we define some starting conditions","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function startingconditions!(dofvector, dofhandler)\n    for cell in CellIterator(dofhandler)\n        globaldofs = celldofs(cell)\n        it = 1\n        for i=1:3:length(globaldofs)\n            dofvector[globaldofs[i]]   = -2.0\n            dofvector[globaldofs[i+1]] = 2.0\n            dofvector[globaldofs[i+2]] = -2.0tanh(cell.coords[it][1]/20)\n            it += 1\n        end\n    end\nend\n\nδ(i, j) = i == j ? one(i) : zero(i)\nV2T(p11, p12, p44) = Tensor{4, 3}((i,j,k,l) -> p11 * δ(i,j)*δ(k,l)*δ(i,k) + p12*δ(i,j)*δ(k,l)*(1 - δ(i,k)) + p44*δ(i,k)*δ(j,l)*(1 - δ(i,j)))\n\nG = V2T(1.0e2, 0.0, 1.0e2)\nα = Vec{3}((-1.0, 1.0, 1.0))\nleft = Vec{3}((-75.,-25.,-2.))\nright = Vec{3}((75.,25.,2.))\nmodel = LandauModel(α, G, (50, 50, 2), left, right, element_potential)\n\nvtk_save(\"landauorig\", model)\n@time minimize!(model)\nvtk_save(\"landaufinal\", model)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"as we can see this runs very quickly even for relatively large gridsizes. The key to get high performance like this is to minimize the allocations inside the threaded loops, ideally to 0.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/linear_shell.jl\"","category":"page"},{"location":"examples/linear_shell/#Linear-shell","page":"Linear shell","title":"Linear shell","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"(Image: )","category":"page"},{"location":"examples/linear_shell/#Introduction","page":"Linear shell","title":"Introduction","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"In this example we show how shell elements can be analyzed in Ferrite.jl. The shell implemented here comes from the book \"The finite elment method - Linear static and dynamic finite element analysis\" by Hughes (1987), and a brief description of it is given at the end of this tutorial.  The first part of the tutorial explains how to set up the problem.","category":"page"},{"location":"examples/linear_shell/#Setting-up-the-problem","page":"Linear shell","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"using Ferrite\nusing ForwardDiff\n\nfunction main() #wrap everything in a function...","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"First we generate a flat rectangular mesh. There is currently no built-in function for generating shell meshes in Ferrite, so we have to create our own simple mesh generator (see the function generate_shell_grid further down in this file).","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"nels = (10,10)\nsize = (10.0, 10.0)\ngrid = generate_shell_grid(nels, size)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Here we define the bi-linear interpolation used for the geometrical description of the shell. We also create two quadrature rules for the in-plane and out-of-plane directions. Note that we use under integration for the inplane integration, to avoid shear locking.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"ip = Lagrange{2,RefCube,1}()\nqr_inplane = QuadratureRule{2,RefCube}(1)\nqr_ooplane = QuadratureRule{1,RefCube}(2)\ncv = CellScalarValues(qr_inplane, ip)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Next we distribute displacement dofs,:u = (x,y,z) and rotational dofs, :θ = (θ₁,  θ₂).","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"dh = DofHandler(grid)\npush!(dh, :u, 3, ip)\npush!(dh, :θ, 2, ip)\nclose!(dh)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"In order to apply our boundary conditions, we first need to create some edge- and vertex-sets. This is done with addedgeset! and addvertexset! (similar to addfaceset!)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"addedgeset!(grid, \"left\",  (x) -> x[1] ≈ 0.0)\naddedgeset!(grid, \"right\", (x) -> x[1] ≈ size[1])\naddvertexset!(grid, \"corner\", (x) -> x[1] ≈ 0.0 && x[2] ≈ 0.0 && x[3] ≈ 0.0)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Here we define the boundary conditions. On the left edge, we lock the displacements in the x- and z- directions, and all the rotations.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"ch = ConstraintHandler(dh)\nadd!(ch,  Dirichlet(:u, getedgeset(grid, \"left\"), (x, t) -> (0.0, 0.0), [1,3])  )\nadd!(ch,  Dirichlet(:θ, getedgeset(grid, \"left\"), (x, t) -> (0.0, 0.0), [1,2])  )","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"On the right edge, we also lock the displacements in the x- and z- directions, but apply a precribed roation.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"add!(ch,  Dirichlet(:u, getedgeset(grid, \"right\"), (x, t) -> (0.0, 0.0), [1,3])  )\nadd!(ch,  Dirichlet(:θ, getedgeset(grid, \"right\"), (x, t) -> (0.0, pi/10), [1,2])  )","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"In order to not get rigid body motion, we lock the y-displacement in one fo the corners.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"add!(ch,  Dirichlet(:θ, getvertexset(grid, \"corner\"), (x, t) -> (0.0), [2])  )\n\nclose!(ch)\nupdate!(ch, 0.0)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Next we define relevant data for the shell, such as shear correction factor and stiffness matrix for the material. In this linear shell, plane stress is assumed, ie \\\\sigma_{zz} = 0 $. Therefor, the stiffness matrix is 5x5 (opposed to the normal 6x6).","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"κ = 5/6 # Shear correction factor\nE = 210.0\nν = 0.3\na = (1-ν)/2\nC = E/(1-ν^2) * [1 ν 0   0   0;\n                ν 1 0   0   0;\n                0 0 a*κ 0   0;\n                0 0 0   a*κ 0;\n                0 0 0   0   a*κ]\n\n\ndata = (thickness = 1.0, C = C); #Named tuple\nnothing #hide","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"We now assemble the problem in standard finite element fashion","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"nnodes = getnbasefunctions(ip)\nndofs_shell = ndofs_per_cell(dh)\n\nK = create_sparsity_pattern(dh)\nf = zeros(Float64, ndofs(dh))\n\nke = zeros(ndofs_shell, ndofs_shell)\nfe = zeros(ndofs_shell)\n\ncelldofs = zeros(Int, ndofs_shell)\ncellcoords = zeros(Vec{3,Float64}, nnodes)\n\nassembler = start_assemble(K, f)\nfor cellid in 1:getncells(grid)\n    fill!(ke, 0.0)\n\n    celldofs!(celldofs, dh, cellid)\n    getcoordinates!(cellcoords, grid, cellid)\n\n    #Call the element routine\n    integrate_shell!(ke, cv, qr_ooplane, cellcoords, data)\n\n    assemble!(assembler, celldofs, fe, ke)\nend","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Apply BC and solve.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"apply!(K, f, ch)\na = K\\f","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Output results.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"vtk_grid(\"linear_shell\", dh) do vtk\n    vtk_point_data(vtk, dh, a)\nend\n\nend; #end main functions\nnothing #hide","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Below is the function that creates the shell mesh. It simply generates a 2d-quadrature mesh, and appends a third coordinate (z-direction) to the node-positions.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function generate_shell_grid(nels, size)\n    _grid = generate_grid(Quadrilateral, nels, Vec((0.0,0.0)), Vec(size))\n    nodes = [(n.x[1], n.x[2], 0.0) |> Vec{3} |> Node  for n in _grid.nodes]\n    cells = [Quadrilateral3D(cell.nodes) for cell in _grid.cells]\n\n    grid = Grid(cells, nodes)\n\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#The-shell-element","page":"Linear shell","title":"The shell element","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The shell presented here comes from the book \"The finite elment method - Linear static and dynamic finite element analysis\" by Hughes (1987). The shell is a so called degenerate shell element, meaning it is based on a continuum element. A brief describtion of the shell is given here.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"note: Note\nThis element might experience various locking phenomenas, and should only be seen as a proof of concept.","category":"page"},{"location":"examples/linear_shell/#Fiber-coordinate-system","page":"Linear shell","title":"Fiber coordinate system","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The element uses two coordinate systems. The first coordianate system, called the fiber system, is created for each element node, and is used as a reference frame for the rotations. The function below implements an algorthim that return the fiber directions, boldsymbole^f_a1, boldsymbole^f_a2 and boldsymbole^f_a3, at each node a.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function fiber_coordsys(Ps::Vector{Vec{3,Float64}})\n\n    ef1 = Vec{3,Float64}[]\n    ef2 = Vec{3,Float64}[]\n    ef3 = Vec{3,Float64}[]\n    for P in Ps\n        a = abs.(P)\n        j = 1\n        if a[1] > a[3]; a[3] = a[1]; j = 2; end\n        if a[2] > a[3]; j = 3; end\n\n        e3 = P\n        e2 = Tensors.cross(P, basevec(Vec{3}, j))\n        e2 /= norm(e2)\n        e1 = Tensors.cross(e2, P)\n\n        push!(ef1, e1)\n        push!(ef2, e2)\n        push!(ef3, e3)\n    end\n    return ef1, ef2, ef3\n\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Lamina-coordinate-system","page":"Linear shell","title":"Lamina coordinate system","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The second coordinate system is the so called Lamina Coordinate system. It is created for each integration point, and is defined to be tangent to the mid-surface. It is in this system that we enforce that plane stress assumption, i.e. sigma_zz = 0. The function below returns the rotation matrix, boldsymbolq, for this coordinate system.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function lamina_coordsys(dNdξ, ζ, x, p, h)\n\n    e1 = zero(Vec{3})\n    e2 = zero(Vec{3})\n\n    for i in 1:length(dNdξ)\n        e1 += dNdξ[i][1] * x[i] + 0.5*h*ζ * dNdξ[i][1] * p[i]\n        e2 += dNdξ[i][2] * x[i] + 0.5*h*ζ * dNdξ[i][1] * p[i]\n    end\n\n    e1 /= norm(e1)\n    e2 /= norm(e2)\n\n    ez = Tensors.cross(e1,e2)\n    ez /= norm(ez)\n\n    a = 0.5*(e1 + e2)\n    a /= norm(a)\n\n    b = Tensors.cross(ez,a)\n    b /= norm(b)\n\n    ex = sqrt(2)/2 * (a - b)\n    ey = sqrt(2)/2 * (a + b)\n\n    return Tensor{2,3}(hcat(ex,ey,ez))\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Geometrical-description","page":"Linear shell","title":"Geometrical description","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"A material point in the shell is defined as","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"boldsymbol x(xi eta zeta) = sum_a=1^N_textnodes N_a(xi eta) boldsymbolbarx_a + ζ frach2 boldsymbolbarp_a","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"where boldsymbolbarx_a are nodal positions on the mid-surface, and boldsymbolbarp_a is an vector that defines the fiber direction on the reference surface. N_a arethe shape functions.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Based on the defintion of the position vector, we create an function for obtaining the Jacobian-matrix,","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"J_ij = fracpartial x_ipartial xi_j","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function getjacobian(q, N, dNdξ, ζ, X, p, h)\n\n    J = zeros(3,3)\n    for a in 1:length(N)\n        for i in 1:3, j in 1:3\n            _dNdξ = (j==3) ? 0.0 : dNdξ[a][j]\n            _dζdξ = (j==3) ? 1.0 : 0.0\n            _N = N[a]\n\n            J[i,j] += _dNdξ * X[a][i]  +  (_dNdξ*ζ + _N*_dζdξ) * h/2 * p[a][i]\n        end\n    end\n\n    return (q' * J) |> Tensor{2,3,Float64}\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Strains","page":"Linear shell","title":"Strains","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Small deformation is assumed,","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"varepsilon_ij= frac12(fracpartial u_ipartial x_j + fracpartial u_jpartial x_i)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The displacement field is calculated as:","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"boldsymbol u = sum_a=1^N_textnodes N_a barboldsymbol u_a +\n N_a ζfrach2(theta_a2 boldsymbol e^f_a1 - theta_a1 boldsymbol e^f_a2)\n","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The gradient of the displacement (in the lamina coordinate system), then becomes:","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"fracpartial u_ipartial x_j = sum_m=1^3 q_im sum_a=1^N_textnodes fracpartial N_apartial x_j baru_am +\n fracpartial(N_a ζ)partial x_j frach2 (theta_a2 e^f_am1 - theta_a1 e^f_am2)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function strain(dofvec::Vector{T}, N, dNdx, ζ, dζdx, q, ef1, ef2, h) where T\n\n    u = reinterpret(Vec{3,T}, dofvec[1:12])\n    θ = reinterpret(Vec{2,T}, dofvec[13:20])\n\n    dudx = zeros(T, 3, 3)\n    for m in 1:3, j in 1:3\n        for a in 1:length(N)\n            dudx[m,j] += dNdx[a][j] * u[a][m] + h/2 * (dNdx[a][j]*ζ + N[a]*dζdx[j]) * (θ[a][2]*ef1[a][m] - θ[a][1]*ef2[a][m])\n        end\n    end\n\n    dudx = q*dudx\n    ε = [dudx[1,1], dudx[2,2], dudx[1,2]+dudx[2,1], dudx[2,3]+dudx[3,2], dudx[1,3]+dudx[3,1]]\n    return ε\n\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Main-element-routine","page":"Linear shell","title":"Main element routine","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Below is the main routine that calculates the stiffness matrix of the shell element. Since it is a so called degenerate shell element, the code is similar to that for an standard continuum element.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function integrate_shell!(ke, cv, qr_ooplane, X, data)\n    nnodes = getnbasefunctions(cv)\n    ndofs = nnodes*5\n    h = data.thickness\n\n    #Create the directors in each node.\n    #Note: For a more general case, the directors should\n    #be input parameters for the element routine.\n    p = zeros(Vec{3}, nnodes)\n    for i in 1:nnodes\n        a = Vec{3}((0.0, 0.0, 1.0))\n        p[i] = a/norm(a)\n    end\n\n    ef1, ef2, ef3 = fiber_coordsys(p)\n\n    for iqp in 1:getnquadpoints(cv)\n\n        dNdξ = cv.dNdξ[:,iqp]\n        N = cv.N[:,iqp]\n\n        for oqp in 1:length(qr_ooplane.weights)\n\n            ζ = qr_ooplane.points[oqp][1]\n\n            q = lamina_coordsys(dNdξ, ζ, X, p, h)\n            J = getjacobian(q, N, dNdξ, ζ, X, p, h)\n            Jinv = inv(J)\n\n            dζdx = Vec{3}((0.0, 0.0, 1.0)) ⋅ Jinv\n            dNdx = [Vec{3}((dNdξ[i][1], dNdξ[i][2], 0.0)) ⋅ Jinv for i in 1:nnodes]\n\n\n            #For simplicity, use automatic differentiation to construct the B-matrix from the strain.\n            B = ForwardDiff.jacobian(\n                (a) -> strain(a, N, dNdx, ζ, dζdx, q, ef1, ef2, h), zeros(Float64, ndofs) )\n\n            dV = det(J) * cv.qr.weights[iqp] * qr_ooplane.weights[oqp]\n            ke .+= B'*data.C*B * dV\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Run everything:","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"main()","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/fe_intro/#Introduction-to-FEM","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Here we will present a very brief introduction to partial differential equations (PDEs) and to the finite element method (FEM). Perhaps the simplest PDE of all is the (steady-state, linear) heat equation, also known as the Poisson equation. We will use this equation as a demonstrative example of the method, and demonstrate how we go from the strong form of the equation, to the weak form, and then finally to the discrete FE problem.","category":"page"},{"location":"manual/fe_intro/#Strong-form","page":"Introduction to FEM","title":"Strong form","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The strong form of the heat equation may be written as:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"- nabla cdot mathbfq(u) = f quad forall  mathbfx in Omega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where u is the unknown temperature field, mathbfq is the heat flux, f is an internal heat source, and Omega is the domain on which the equation is defined. To complete the problem we need to specify what happens at the domain boundary Gamma. This set of specifications is called boundary conditions. There are different types of boundary conditions, where the most common ones are Dirichlet – which means that the solution u is known at some part of the boundary, and Neumann – which means that the gradient of the solution, nabla u is known. Formally we write for our example","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u = u^mathrmp quad forall  mathbfx in Gamma_mathrmD\nmathbfq cdot mathbfn = q^mathrmp quad forall  mathbfx in Gamma_mathrmN","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"i.e. the temperature is prescribed to a known function u^mathrmp at the Dirichlet part of the boundary, Gamma_mathrmD, and the heat flux is prescribed to q^mathrmp at the Neumann part of the boundary, Gamma_mathrmN, where mathbfn describes the outward pointing normal vector at the boundary.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We also need a constitutive equation which links the temperature field, u, to the heat flux, mathbfq. The simplest case is to use Fourier's law","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"mathbfq(u) = -k nabla u","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where k is the conductivity of the material. For simplicity we will consider only constant conductivity k.","category":"page"},{"location":"manual/fe_intro/#Weak-form","page":"Introduction to FEM","title":"Weak form","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The solution to the equation above is usually calculated from the corresponding weak form. By multiplying the equation with an arbitrary test function delta u, integrating over the domain and using partial integration we obtain the weak form. Now our problem can be stated as:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Find u in mathbbU s.t.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"int_Omega nabla delta u cdot (k nabla u)  mathrmdOmega =\nint_Gamma_mathrmN delta u  q^mathrmp  mathrmdGamma +\nint_Omega delta u  b  mathrmdOmega quad forall  delta u in mathbbT","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where mathbbU mathbbT are suitable function spaces with sufficiently regular functions. Under very general assumptions it can be shown that the solution to the weak form is identical to the solution to the strong form.","category":"page"},{"location":"manual/fe_intro/#Finite-Element-approximation","page":"Introduction to FEM","title":"Finite Element approximation","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Using the finite element method to solve partial differential equations is usually preceded with the construction of a discretization of the domain Omega into a finite set of elements or cells. We call this geometric discretization grid (or mesh) and denote it with Omega_h. In this example the corners of the triangles are called nodes.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Next we introduce the finite element approximation u_mathrmh approx u as a sum of N nodal shape functions, where we denote each of these function by phi_i and the corresponding nodal values hatu_i. Note that shape functions are sometimes referred to as base functions or trial functions, and instead of phi_i they are sometimes denoted N_i. In this example we choose to approximate the test function in the same way. This approach is known as the Galerkin finite element method. Formally we write the evaluation of our approximations at a specific point mathbfx in our domain Omega as:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u_mathrmh(mathbfx) = sum_i=1^mathrmN phi_i(mathbfx)  hatu_iqquad\ndelta u_mathrmh(mathbfx) = sum_i=1^mathrmN phi_i(mathbfx)  delta hatu_i  ","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Since test and trial functions are usually chosen in such a way, that they build the basis of some function space (basis as in basis of a vector space), sometimes are they are also called basis functions. In the following the argument mathbfx is dropped to keep the notation compact. We may now insert these approximations in the weak form, which results in","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"sum_i^N left(sum_j^N delta hatu_i int_Omega_mathrmh nabla phi_i cdot (k nabla phi_j)  mathrmdOmega right) hatu_j =\nsum_i^N delta hatu_i int_Gamma_mathrmN phi_i  q^mathrmp  mathrmdGamma +\nsum_i^N delta hatu_i int_Omega_mathrmh phi_i  f  mathrmdOmega  ","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Since this equation must hold for arbitrary delta u_mathrmh, the equation must especially hold for the specific choice that only one of the nodal values delta hatu_i is fixed to 1 while an all other coefficients are fixed to 0. Repeating this argument for all i from 1 to N we obtain N linear equations. This way the discrete problem can be written as a system of linear equations","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlineunderlineK underlinehatu = underlinehatf  ","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where we call underlineunderlineK the (tangent) stiffness matrix, underlinehatu the solution vector with the nodal values and underlinehatf the force vector. The specific naming is for historical reasons, because the finite element method has its origins in mechanics. The elements of underlineunderlineK and underlinehatf are given by","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(underlineunderlineK)_ij =\n    int_Omega_mathrmh nabla phi_i cdot (k nabla phi_j) mathrmdOmega   \n\n(underlinehatf)_i =\n    int_Gamma_mathrmN phi_i  q^mathrmp  mathrmdGamma + int_Omega_mathrmh phi_i  f  mathrmdOmega  ","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Finally we also need to take care of the Dirichlet boundary conditions. These are enforced by setting the corresponding hatu_i to the prescribed values and eliminating the associated equations from the system. Now, solving this equation system yields the nodal values and thus an approximation to the true solution.","category":"page"},{"location":"manual/fe_intro/#Notes-on-the-implementation","page":"Introduction to FEM","title":"Notes on the implementation","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In practice, the shape functions phi_i are only non-zero on parts of the domain Omega_mathrmh. Thus, the integrals are evaluated on sub-domains, called elements or cells.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Each cell gives a contribution to the global stiffness matrix and force vector. The process of constructing the system of equations is also called assembly. For clarification, let us rewrite the formula for the stiffness matrix entries as follows:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(underlineunderlineK)_ij\n    = int_Omega_mathrmh nabla phi_i cdot (k nabla phi_j) mathrmdOmega\n    = sum_E in Omega_mathrmh int_E nabla phi_i cdot (k nabla phi_j) mathrmdOmega  ","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This formulation underlines the element-centric perspective of finite element methods and reflects how it is usually implemented in software.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Computing the element integrals by hand can become a tedious task. To avoid this issue we approximate the element integrals with a technique called numerical integration. Skipping any of the mathematical details, the basic idea is to evaluate the function under the integral at specific points and weighting the evaluations accordingly, such that their sum approximates the volume properly. A very nice feature of these techniques is, that under quite general circumstances the formula is not just an approximation, but the exact evaluation of the integral. To avoid the recomputation of the just mentioned evaluation positions of the integral for each individual element, we perform a coordinate transformation onto a so-called reference element. Formally we write","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"    int_E nabla phi_i cdot (k nabla phi_j) mathrmdOmega\n    approx sum_q nabla phi_i(textbfx_q) cdot (k(textbfx_q) nabla phi_j(textbfx_q))  w_q  textrmdet(J(textbfx_q))  ","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where J is the Jacobian of the coordinate transformation function. The computation of the transformation, weights, positions and of the Jacobi determinant is handled by Ferrite. On an intuitive level, and to explain the notation used in the implementation, we think of","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"    mathrmdOmega approx  w  textrmdet(J)","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"being the chosen approximation when changing from the integral to the finite summation.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"For an example of the implementation to solve a heat problem with Ferrite check out this thoroughly commented example.","category":"page"},{"location":"manual/fe_intro/#More-Details","page":"Introduction to FEM","title":"More Details","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We finally want to note that this quick introduction barely scratches the surface of the finite element method. Also, we presented some things in a simplified way for the sake of keeping this article short and concise. There is a large corpus of literature and online tutorials containing more details about the finite element method. To give a few recommendations there is:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Hans Petter Langtangen's Script\nWolfgang Bangerth's Lecture Series\nIntroduction to the Finite Element Method by Niels Ottosen and Hans Petersson\nThe Finite Element Method for Elliptic Problems by Philippe Ciarlet\nFinite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory by Dietrich Braess\nAn Analysis of the Finite Element Method by Gilbert Strang and George Fix\nFinite Element Procedures by Klaus-Jürgen Bathe\nThe Finite Element Method: Its Basis and Fundamentals by Olgierd Cecil Zienkiewicz, Robert Taylor and J.Z. Zhu\nHigher-Order Finite Element Methods by Pavel Šolín, Karel Segeth and Ivo Doležel","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This list is neither meant to be exhaustive, nor does the absence of a work mean that it is in any way bad or not recommendable. The ordering of the articles also has no particular meaning.","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/grid/#Grid-and-AbstractGrid","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"","category":"section"},{"location":"reference/grid/#Grid","page":"Grid & AbstractGrid","title":"Grid","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Node\nCell\nCellIndex\nVertexIndex\nEdgeIndex\nFaceIndex\nGrid","category":"page"},{"location":"reference/grid/#Ferrite.Node","page":"Grid & AbstractGrid","title":"Ferrite.Node","text":"Node{dim, T}\n\nA Node is a point in space.\n\nFields\n\nx::Vec{dim,T}: stores the coordinates\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.Cell","page":"Grid & AbstractGrid","title":"Ferrite.Cell","text":"Cell{dim,N,M} <: AbstractCell{dim,N,M}\n\nA Cell is a sub-domain defined by a collection of Nodes as it's vertices. However, a cell is not defined by the nodes but rather by the global node ids. The parameter dim refers here to the geometrical/ambient dimension, i.e. the dimension of the nodes in the grid and not the topological dimension of the cell. A Cell has N nodes and M faces.\n\nFields\n\nnodes::Ntuple{N,Int}: N-tuple that stores the node ids. The ordering defines a cell's and its subentities' orientations.\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.CellIndex","page":"Grid & AbstractGrid","title":"Ferrite.CellIndex","text":"A CellIndex wraps an Int and corresponds to a cell with that number in the mesh\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.VertexIndex","page":"Grid & AbstractGrid","title":"Ferrite.VertexIndex","text":"A VertexIndex wraps an (Int, Int) and defines a local vertex by pointing to a (cell, vert).\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.EdgeIndex","page":"Grid & AbstractGrid","title":"Ferrite.EdgeIndex","text":"A EdgeIndex wraps an (Int, Int) and defines a local edge by pointing to a (cell, edge).\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.FaceIndex","page":"Grid & AbstractGrid","title":"Ferrite.FaceIndex","text":"A FaceIndex wraps an (Int, Int) and defines a local face by pointing to a (cell, face).\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.Grid","page":"Grid & AbstractGrid","title":"Ferrite.Grid","text":"Grid{dim, C<:AbstractCell, T<:Real} <: AbstractGrid}\n\nA Grid is a collection of Cells and Nodes which covers the computational domain, together with Sets of cells, nodes and faces. There are multiple helper structures to apply boundary conditions or define subdomains. They are gathered in the cellsets, nodesets, facesets, edgesets and vertexsets. \n\nFields\n\ncells::Vector{C}: stores all cells of the grid\nnodes::Vector{Node{dim,T}}: stores the dim dimensional nodes of the grid\ncellsets::Dict{String,Set{Int}}: maps a String key to a Set of cell ids\nnodesets::Dict{String,Set{Int}}: maps a String key to a Set of global node ids\nfacesets::Dict{String,Set{FaceIndex}}: maps a String to a Set of Set{FaceIndex} (global_cell_id, local_face_id)\nedgesets::Dict{String,Set{EdgeIndex}}: maps a String to a Set of Set{EdgeIndex} (global_cell_id, local_edge_id \nvertexsets::Dict{String,Set{VertexIndex}}: maps a String key to a Set of local vertex ids\nboundary_matrix::SparseMatrixCSC{Bool,Int}: optional, only needed by onboundary to check if a cell is on the boundary, see, e.g. Helmholtz example\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Utility-Functions","page":"Grid & AbstractGrid","title":"Utility Functions","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"getcells\ngetncells\ngetnodes\ngetnnodes\nFerrite.nnodes_per_cell\ngetcellset\ngetcellsets\ngetnodeset\ngetnodesets\ngetfaceset\ngetfacesets\ngetedgeset\ngetedgesets\ngetvertexset\ngetvertexsets\ncompute_vertex_values\ntransform!\ngetcoordinates\ngetcoordinates!\nFerrite.ExclusiveTopology\nFerrite.getneighborhood\nFerrite.faceskeleton","category":"page"},{"location":"reference/grid/#Ferrite.getcells","page":"Grid & AbstractGrid","title":"Ferrite.getcells","text":"getcells(grid::AbstractGrid) \ngetcells(grid::AbstractGrid, v::Union{Int,Vector{Int}} \ngetcells(grid::AbstractGrid, setname::String)\n\nReturns either all cells::Collection{C<:AbstractCell} of a <:AbstractGrid or a subset based on an Int, Vector{Int} or String. Whereas the last option tries to call a cellset of the grid. Collection can be any indexable type, for Grid it is Vector{C<:AbstractCell}.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getncells","page":"Grid & AbstractGrid","title":"Ferrite.getncells","text":"Returns the number of cells in the <:AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnodes","page":"Grid & AbstractGrid","title":"Ferrite.getnodes","text":"getnodes(grid::AbstractGrid) \ngetnodes(grid::AbstractGrid, v::Union{Int,Vector{Int}}\ngetnodes(grid::AbstractGrid, setname::String)\n\nReturns either all nodes::Collection{N} of a <:AbstractGrid or a subset based on an Int, Vector{Int} or String. The last option tries to call a nodeset of the <:AbstractGrid. Collection{N} refers to some indexable collection where each element corresponds to a Node.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnnodes","page":"Grid & AbstractGrid","title":"Ferrite.getnnodes","text":"Returns the number of nodes in the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.nnodes_per_cell","page":"Grid & AbstractGrid","title":"Ferrite.nnodes_per_cell","text":"Returns the number of nodes of the i-th cell.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcellset","page":"Grid & AbstractGrid","title":"Ferrite.getcellset","text":"getcellset(grid::AbstractGrid, setname::String)\n\nReturns all cells as cellid in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcellsets","page":"Grid & AbstractGrid","title":"Ferrite.getcellsets","text":"getcellsets(grid::AbstractGrid)\n\nReturns all cellsets of the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnodeset","page":"Grid & AbstractGrid","title":"Ferrite.getnodeset","text":"getnodeset(grid::AbstractGrid, setname::String)\n\nReturns all nodes as nodeid in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getnodesets","page":"Grid & AbstractGrid","title":"Ferrite.getnodesets","text":"getnodesets(grid::AbstractGrid)\n\nReturns all nodesets of the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getfaceset","page":"Grid & AbstractGrid","title":"Ferrite.getfaceset","text":"getfaceset(grid::AbstractGrid, setname::String)\n\nReturns all faces as FaceIndex in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getfacesets","page":"Grid & AbstractGrid","title":"Ferrite.getfacesets","text":"getfacesets(grid::AbstractGrid)\n\nReturns all facesets of the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getedgeset","page":"Grid & AbstractGrid","title":"Ferrite.getedgeset","text":"getedgeset(grid::AbstractGrid, setname::String)\n\nReturns all edges as EdgeIndex in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getedgesets","page":"Grid & AbstractGrid","title":"Ferrite.getedgesets","text":"getedgesets(grid::AbstractGrid)\n\nReturns all edge sets of the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getvertexset","page":"Grid & AbstractGrid","title":"Ferrite.getvertexset","text":"getedgeset(grid::AbstractGrid, setname::String)\n\nReturns all vertices as VertexIndex in a Set of a given setname.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getvertexsets","page":"Grid & AbstractGrid","title":"Ferrite.getvertexsets","text":"getvertexsets(grid::AbstractGrid)\n\nReturns all vertex sets of the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.compute_vertex_values","page":"Grid & AbstractGrid","title":"Ferrite.compute_vertex_values","text":"function compute_vertex_values(grid::AbstractGrid, f::Function)\nfunction compute_vertex_values(grid::AbstractGrid, v::Vector{Int}, f::Function)    \nfunction compute_vertex_values(grid::AbstractGrid, set::String, f::Function)\n\nGiven a grid and some function f, compute_vertex_values computes all nodal values,  i.e. values at the nodes,  of the function f.  The function implements two dispatches, where only a subset of the grid's node is used.\n\n    compute_vertex_values(grid, x -> sin(x[1]) + cos([2]))\n    compute_vertex_values(grid, [9, 6, 3], x -> sin(x[1]) + cos([2])) #compute function values at nodes with id 9,6,3\n    compute_vertex_values(grid, \"right\", x -> sin(x[1]) + cos([2])) #compute function values at nodes belonging to nodeset right\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.transform!","page":"Grid & AbstractGrid","title":"Ferrite.transform!","text":"transform!(grid::Abstractgrid, f::Function)\n\nTransform all nodes of the grid based on some transformation function f.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcoordinates","page":"Grid & AbstractGrid","title":"Ferrite.getcoordinates","text":"getcoordinates(grid::AbstractGrid, cell)\n\nReturn a vector with the coordinates of the vertices of cell number cell.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.getcoordinates!","page":"Grid & AbstractGrid","title":"Ferrite.getcoordinates!","text":"getcoordinates!(x::Vector{Vec{dim,T}}, grid::AbstractGrid, cell::Int)\n\nFills the vector x with the coordinates of a cell, defined by its cell id.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.ExclusiveTopology","page":"Grid & AbstractGrid","title":"Ferrite.ExclusiveTopology","text":"ExclusiveTopology(cells::Vector{C}) where C <: AbstractCell\n\nExclusiveTopology saves topological (connectivity) data of the grid. The constructor works with an AbstractCell vector for all cells that dispatch vertices, faces and in 3D edges as well as the utility functions face_npoints and edge_npoints. The struct saves the highest dimensional neighborhood, i.e. if something is connected by a face and an  edge only the face neighborhood is saved. The lower dimensional neighborhood is recomputed, if needed.\n\nFields\n\nvertex_to_cell::Dict{Int,Vector{Int}}: global vertex id to all cells containing the vertex\ncell_neighbor::Vector{EntityNeighborhood{CellIndex}}: cellid to all connected cells\nface_neighbor::SparseMatrixCSC{EntityNeighborhood,Int}: face_neighbor[cellid,local_face_id] -> neighboring face\nvertex_neighbor::SparseMatrixCSC{EntityNeighborhood,Int}: vertex_neighbor[cellid,local_vertex_id] -> neighboring vertex\nedge_neighbor::SparseMatrixCSC{EntityNeighborhood,Int}: edge_neighbor[cellid_local_vertex_id] -> neighboring edge\nvertex_vertex_neighbor::Dict{Int,EntityNeighborhood{VertexIndex}}: global vertex id -> all connected vertices by edge or face\nface_skeleton::Vector{FaceIndex}: list of unique faces in the grid \n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#Ferrite.getneighborhood","page":"Grid & AbstractGrid","title":"Ferrite.getneighborhood","text":"getneighborhood(top::ExclusiveTopology, grid::Grid{dim,C,T}, cellidx::CellIndex, include_self=false)\ngetneighborhood(top::ExclusiveTopology, grid::Grid{dim,C,T}, faceidx::FaceIndex, include_self=false)\ngetneighborhood(top::ExclusiveTopology, grid::Grid{dim,C,T}, vertexidx::VertexIndex, include_self=false)\ngetneighborhood(top::ExclusiveTopology, grid::Grid{dim,C,T}, edgeidx::EdgeIndex, include_self=false)\n\nReturns all directly connected entities of the same type, i.e. calling the function with a VertexIndex will return a list of directly connected vertices (connected via face/edge). If include_self is true, the given *Index is included  in the returned list.\n\nwarning: Warning\nThis feature is highly experimental and very likely subjected to interface changes in the future.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.faceskeleton","page":"Grid & AbstractGrid","title":"Ferrite.faceskeleton","text":"faceskeleton(grid) -> Vector{FaceIndex}\n\nReturns an iterateable face skeleton. The skeleton consists of FaceIndex that can be used to reinit  FaceValues.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Grid-Sets-Utility","page":"Grid & AbstractGrid","title":"Grid Sets Utility","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"addcellset!\naddfaceset!\naddnodeset!","category":"page"},{"location":"reference/grid/#Ferrite.addcellset!","page":"Grid & AbstractGrid","title":"Ferrite.addcellset!","text":"addcellset!(grid::AbstractGrid, name::String, cellid::Union{Set{Int}, Vector{Int}})\naddcellset!(grid::AbstractGrid, name::String, f::function; all::Bool=true)\n\nAdds a cellset to the grid with key name. Cellsets are typically used to define subdomains of the problem, e.g. two materials in the computational domain. The MixedDofHandler can construct different fields which live not on the whole domain, but rather on a cellset. \n\naddcellset!(grid, \"left\", Set((1,3))) #add cells with id 1 and 3 to cellset left\naddcellset!(grid, \"right\", x -> norm(x[1]) < 2.0 ) #add cell to cellset right, if x[1] of each cell's node is smaller than 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addfaceset!","page":"Grid & AbstractGrid","title":"Ferrite.addfaceset!","text":"addfaceset!(grid::AbstractGrid, name::String, faceid::Union{Set{FaceIndex},Vector{FaceIndex}})\naddfaceset!(grid::AbstractGrid, name::String, f::Function; all::Bool=true)\n\nAdds a faceset to the grid with key name. A faceset maps a String key to a Set of tuples corresponding to (global_cell_id, local_face_id). Facesets are used to initialize Dirichlet structs, that are needed to specify the boundary for the ConstraintHandler.\n\naddfaceset!(gird, \"right\", Set(((2,2),(4,2))) #see grid manual example for reference\naddfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0) #see incompressible elasticity example for reference\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Ferrite.addnodeset!","page":"Grid & AbstractGrid","title":"Ferrite.addnodeset!","text":"addnodeset!(grid::AbstractGrid, name::String, nodeid::Union{Vector{Int},Set{Int}})\naddnodeset!(grid::AbstractGrid, name::String, f::Function)\n\nAdds a nodeset::Dict{String, Set{Int}} to the grid with key name. Has the same interface as addcellset.  However, instead of mapping a cell id to the String key, a set of node ids is returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#Multithreaded-Assembly","page":"Grid & AbstractGrid","title":"Multithreaded Assembly","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"create_coloring","category":"page"},{"location":"reference/grid/#Ferrite.create_coloring","page":"Grid & AbstractGrid","title":"Ferrite.create_coloring","text":"create_coloring(g::Grid, cellset::Set{Int}=Set(1:getncells(g)); alg::ColoringAlgorithm)\n\nCreate a coloring of the cells in grid g such that no neighboring cells have the same color. If only a subset of cells should be colored, the cells to color can be specified by cellset.\n\nReturns a vector of vectors with cell indexes, e.g.:\n\nret = [\n   [1, 3, 5, 10, ...], # cells for color 1\n   [2, 4, 6, 12, ...], # cells for color 2\n]\n\nTwo different algorithms are available, specified with the alg keyword argument:\n\nalg = ColoringAlgorithm.WorkStream (default): Three step algorithm from WorkStream , albeit with a greedy coloring in the second step. Generally results in more colors than ColoringAlgorithm.Greedy, however the cells are more equally distributed among the colors.\nalg = ColoringAlgorithm.Greedy: greedy algorithm that works well for structured quadrilateral grids such as e.g. quadrilateral grids from generate_grid.\n\nThe resulting colors can be visualized using vtk_cell_data_colors.\n\nnote: Cell to color mapping\nIn a previous version of Ferrite this function returned a dictionary mapping cell ID to color numbers as the first argument. If you need this mapping you can create it using the following construct:colors = create_coloring(...)\ncell_colormap = Dict{Int,Int}(\n    cellid => color for (color, cellids) in enumerate(final_colors) for cellid in cellids\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/grid/#AbstractGrid","page":"Grid & AbstractGrid","title":"AbstractGrid","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"It can be very useful to use a grid type for a certain special case, e.g. mixed cell types, adaptivity, IGA, etc. In order to define your own <: AbstractGrid you need to fulfill the AbstractGrid interface. In case that certain structures are preserved from the Ferrite.Grid type, you don't need to dispatch on your own type, but rather rely on the fallback AbstractGrid dispatch.","category":"page"},{"location":"reference/grid/#Example","page":"Grid & AbstractGrid","title":"Example","text":"","category":"section"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"As a starting point, we choose a minimal working example from the test suite:","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"struct SmallGrid{dim,N,C<:Ferrite.AbstractCell} <: Ferrite.AbstractGrid{dim}\n    nodes_test::Vector{NTuple{dim,Float64}}\n    cells_test::NTuple{N,C}\nend","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Here, the names of the fields as well as their underlying datastructure changed compared to the Grid type. This would lead to the fact, that any usage with the utility functions and DoF management will not work. So, we need to feed into the interface how to handle this subtyped datastructure. We start with the utility functions that are associated with the cells of the grid:","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Ferrite.getcells(grid::SmallGrid) = grid.cells_test\nFerrite.getcells(grid::SmallGrid, v::Union{Int, Vector{Int}}) = grid.cells_test[v]\nFerrite.getncells(grid::SmallGrid{dim,N}) where {dim,N} = N\nFerrite.getcelltype(grid::SmallGrid) = eltype(grid.cells_test)\nFerrite.getcelltype(grid::SmallGrid, i::Int) = typeof(grid.cells_test[i])","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Next, we define some helper functions that take care of the node handling.","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Ferrite.getnodes(grid::SmallGrid) = grid.nodes_test\nFerrite.getnodes(grid::SmallGrid, v::Union{Int, Vector{Int}}) = grid.nodes_test[v]\nFerrite.getnnodes(grid::SmallGrid) = length(grid.nodes_test)\nFerrite.nnodes_per_cell(grid::SmallGrid, i::Int=1) = Ferrite.nnodes(grid.cells_test[i])\nFerrite.n_faces_per_cell(grid::SmallGrid) = nfaces(eltype(grid.cells_test))","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Finally, we define getcoordinates, which is an important function, if we want to assemble a problem. The transformation from the reference space to the physical one requires information about the coordinates in order to construct the Jacobian. The return of this part is later handled over to reinit!.","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"function Ferrite.getcoordinates!(x::Vector{Vec{dim,T}}, grid::SmallGrid, cell::Int) where {dim,T}\n    for i in 1:length(x)\n        x[i] = Vec{dim,T}(grid.nodes_test[grid.cells_test[cell].nodes[i]])\n    end\nend\n\nfunction Ferrite.getcoordinates(grid::SmallGrid{dim}, cell::Int) where dim\n    nodeidx = grid.cells_test[cell].nodes\n    return [Vec{dim,Float64}(grid.nodes_test[i]) for i in nodeidx]::Vector{Vec{dim,Float64}}\nend","category":"page"},{"location":"reference/grid/","page":"Grid & AbstractGrid","title":"Grid & AbstractGrid","text":"Now, you would be able to assemble the heat equation example over the new custom SmallGrid type. Note that this particular subtype isn't able to handle boundary entity sets and so, you can't describe boundaries with it. In order to use boundaries, e.g. for Dirichlet constraints in the ConstraintHandler, you would need to dispatch the AbstractGrid sets utility functions on SmallGrid.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"PDEs can in general be subjected to a number of constraints, ","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"g_I(boldsymbola) = 0 quad I = 1 text to  n_c","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"where g are (non-linear) constraint equations, boldsymbola is a vector of the degrees of freedom, and n_c is the number of constraints. There are many ways to enforce these constraints, e.g. penalty methods and Lagrange multiplier methods. ","category":"page"},{"location":"manual/constraints/#Affine-constraints","page":"Constraints","title":"Affine constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Affine constraints can be handled directly in Ferrite. Affine (or linear) constraints can typically be expressed as:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"a_1 =  5a_2 + 3a_3 + 1 \na_4 =  2a_3 + 6a_5 \ndots","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"where a_1, a_2 etc. are system degrees of freedom. In Ferrite, we can account for such constraint using the ConstraintHandler:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"ch = ConstraintHandler(dh)\nlc1 = AffineConstraint(1, [2 => 5.0, 3 => 3.0], 1)\nlc2 = AffineConstraint(1, [3 => 2.0, 5 => 6.0], 0)\nadd!(ch, lc1)\nadd!(ch, lc2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Linear constraint will affect the sparsity pattern of the stiffness matrix, and as such, it is important to also include  the ConstraintHandler as an argument when creating the sparsity pattern:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"K = create_sparsity_pattern(dh, ch)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When solving the system, we account for the affine constraints in the same way as we account for  Dirichlet boundary conditions; by first calling apply!(K, f, ch). This will condense K and f inplace (i.e no new matrix will be created). Note however that we must also call apply! on the solution vector after  solving the system to enforce the affine constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# ...\n# Assemble K and f...\n\napply!(K, f, ch)\na = K\\f\napply!(a, ch) # enforces affine constraints\n","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/computational_homogenization.jl\"","category":"page"},{"location":"examples/computational_homogenization/#Computational-homogenization","page":"Computational homogenization","title":"Computational homogenization","text":"","category":"section"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"(Image: )","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Figure 1: von Mises stress in an RVE with 5 stiff inclusions embedded in a softer matrix material that is loaded in shear. The problem is solved by using homogeneous Dirichlet boundary conditions (left) and (strong) periodic boundary conditions (right).","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"tip: Tip\nThis example is also available as a Jupyter notebook: computational_homogenization.ipynb.","category":"page"},{"location":"examples/computational_homogenization/#Introduction","page":"Computational homogenization","title":"Introduction","text":"","category":"section"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"In this example we will solve the Representative Volume Element (RVE) problem for computational homogenization of linear elasticity and compute the effective/homogenized stiffness of an RVE with 5 stiff circular inclusions embedded in a softer matrix material (see Figure 1).","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"It is possible to obtain upper and lower bounds on the stiffness analytically, see for example Rule of mixtures. An upper bound is obtained from the Voigt model, where the strain is assumed to be the same in the two constituents,","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"mathsfE_mathrmVoigt = v_mathrmm mathsfE_mathrmm +\n(1 - v_mathrmm) mathsfE_mathrmi","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"where v_mathrmm is the volume fraction of the matrix material, and where mathsfE_mathrmm and mathsfE_mathrmi are the individual stiffness for the matrix material and the inclusions, respectively. The lower bound is obtained from the Reuss model, where the stress is assumed to be the same in the two constituents,","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"mathsfE_mathrmReuss = left(v_mathrmm mathsfE_mathrmm^-1 +\n(1 - v_mathrmm) mathsfE_mathrmi^-1 right)^-1","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"However, neither of these assumptions are, in general, very close to the \"truth\" which is why it is of interest to computationally find the homogenized properties for a given RVE.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"The canonical version of the RVE problem can be formulated as follows: For given homogenized field barboldsymbolu, barboldsymbolvarepsilon = boldsymbolvarepsilonbarboldsymbolu, find boldsymbolu in mathbbU_Box, boldsymbolt in mathbbT_Box such that","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"frac1Omega_Box int_Omega_Boxboldsymbolvarepsilondeltaboldsymbolu\n mathsfE  boldsymbolvarepsilonboldsymbolu mathrmdOmega\n- frac1Omega_Box int_Gamma_Boxdelta boldsymbolu cdot\nboldsymbolt mathrmdGamma = 0 quad\nforall delta boldsymbolu in mathbbU_Boxquad (1mathrma)\n- frac1Omega_Box int_Gamma_Boxdelta boldsymbolt cdot\nboldsymbolu mathrmdGamma = - barboldsymbolvarepsilon \nleft frac1Omega_Box int_Gamma_Boxdelta boldsymbolt otimes\nboldsymbolx - barboldsymbolx mathrmdGamma right\nquad forall delta boldsymbolt in mathbbT_Box quad (1mathrmb)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"where boldsymbolu = barboldsymbolvarepsilon cdot boldsymbolx - barboldsymbolx + boldsymbolu^mu, where Omega_Box and Omega_Box are the domain and volume of the RVE, where Gamma_Box is the boundary, and where mathbbU_Box, mathbbT_Box are set of \"sufficiently regular\" functions defined on the RVE.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"This system is not solvable without introducing extra restrictions on mathbbU_Box, mathbbT_Box. In this example we will consider the common cases of Dirichlet boundary conditions and (strong) periodic boundary conditions.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Dirichlet boundary conditions","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We can introduce the more restrictive sets of mathbbU_Box:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"beginalign*\nmathbbU_Box^mathrmD = leftboldsymbolu in mathbbU_Box boldsymbolu\n= barboldsymbolvarepsilon cdot boldsymbolx - barboldsymbolx\n mathrmon Gamma_Boxright\nmathbbU_Box^mathrmD0 = leftboldsymbolu in mathbbU_Box boldsymbolu\n= boldsymbol0 mathrmon Gamma_Boxright\nendalign*","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"and use these as trial and test sets to obtain a solvable RVE problem pertaining to Dirichlet boundary conditions. Eq. (1mathrmb) is trivially fulfilled, the second term of Eq. (1mathrma) vanishes, and we are left with the following problem: Find boldsymbolu in mathbbU_Box^mathrmD that solve","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"frac1Omega_Box int_Omega_Boxboldsymbolvarepsilondeltaboldsymbolu\n mathsfE  boldsymbolvarepsilonboldsymbolu mathrmdOmega = 0\nquad forall delta boldsymbolu in mathbbU_Box^mathrmD0","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Note that, since boldsymbolu = barboldsymbolvarepsilon cdot boldsymbolx - barboldsymbolx + boldsymbolu^mu, this problem is equivalent to solving for boldsymbolu^mu in mathbbU_Box^mathrmD0, which is what we will do in the implementation.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Periodic boundary conditions","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"The RVE problem pertaining to periodic boundary conditions is obtained by restricting boldsymbolu^mu to be periodic, and boldsymbolt anti-periodic across the RVE. Similarly as for Dirichlet boundary conditions, Eq. (1mathrmb) is directly fulfilled, and the second term in Eq. (1mathrma) vanishes, with these restrictions, and we are left with the following problem: Find boldsymbolu^mu in mathbbU_Box^mathrmP0 such that","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"frac1Omega_Box int_Omega_Boxboldsymbolvarepsilondeltaboldsymbolu\n mathsfE  (barboldsymbolvarepsilon + boldsymbolvarepsilon\nboldsymbolu^mu) mathrmdOmega = 0\nquad forall delta boldsymbolu in mathbbU_Box^mathrmP0","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"where","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"mathbbU_Box^mathrmP0 = leftboldsymbolu in mathbbU_Box\n llbracket boldsymbolu rrbracket_Box = boldsymbol0\n mathrmon Gamma_Box^+right","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"where llbracket bullet rrbracket_Box = bullet(boldsymbolx^+) - bullet(boldsymbolx^-) defines the \"jump\" over the RVE, i.e. the difference between the value on the image part Gamma_Box^+ (coordinate boldsymbolx^+) and the mirror part Gamma_Box^- (coordinate boldsymbolx^-) of the boundary. To make sure this restriction holds in a strong sense we need a periodic mesh.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Note that it would be possible to solve for the total boldsymbolu directly by instead enforcing the jump to be equal to the jump in the macroscopic part, boldsymbolu^mathrmM, i.e.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"llbracket boldsymbolu rrbracket_Box =\nllbracket boldsymbolu^mathrmM rrbracket_Box =\nllbracket barboldsymbolvarepsilon cdot boldsymbolx - barboldsymbolx\nrrbracket_Box =\nbarboldsymbolvarepsilon cdot boldsymbolx^+ - boldsymbolx^-","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Homogenization of effective properties","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"In general it is necessary to compute the homogenized stress and the stiffness on the fly, but since we in this example consider linear elasticity it is possible to compute the effective properties once and for all for a given RVE configuration. We do this by computing sensitivity fields for every independent strain component (6 in 3D, 3 in 2D). Thus, for a 2D problem, as in the implementation below, we compute sensitivities hatboldsymbolu_11, hatboldsymbolu_22, and hatboldsymbolu_12 = hatboldsymbolu_21 by using","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"barboldsymbolvarepsilon = beginpmatrix1  0 0  0endpmatrix quad\nbarboldsymbolvarepsilon = beginpmatrix0  0 0  1endpmatrix quad\nbarboldsymbolvarepsilon = beginpmatrix0  05 05  0endpmatrix","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"as the input to the RVE problem. When the sensitivies are solved we can compute the entries of the homogenized stiffness as follows","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"mathsfE_ijkl = fracpartial barsigma_ijpartial barvarepsilon_kl\n= barsigma_ij(hatboldsymbolu_kl)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"where the homogenized stress, barboldsymbolsigma(boldsymbolu), is computed as the volume average of the stress in the RVE, i.e.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"barboldsymbolsigma(boldsymbolu) =\nfrac1Omega_Box int_Omega_Box boldsymbolsigma mathrmdOmega =\nfrac1Omega_Box int_Omega_Box\nmathsfE  boldsymbolvarepsilonboldsymbolu mathrmdOmega","category":"page"},{"location":"examples/computational_homogenization/#Commented-program","page":"Computational homogenization","title":"Commented program","text":"","category":"section"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Now we will see how this can be implemented in Ferrite. What follows is a program with comments in between which describe the different steps. You can also find the same program without comments at the end of the page, see Plain program.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"using Ferrite, SparseArrays, LinearAlgebra","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We first load the mesh file periodic-rve.msh (periodic-rve-coarse.msh for a coarser mesh). The mesh is generated with gmsh, and we read it in as a Ferrite grid using the FerriteGmsh package:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"using FerriteGmsh\ngrid = saved_file_to_grid(\"periodic-rve.msh\")","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"grid = redirect_stdout(devnull) do                #hide\n    saved_file_to_grid(\"periodic-rve-coarse.msh\") #hide\nend                                               #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Next we construct the interpolation and quadrature rule, and combining them into cellvalues as usual:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"dim = 2\nip = Lagrange{dim, RefTetrahedron, 1}()\nqr = QuadratureRule{dim, RefTetrahedron}(2)\ncellvalues = CellVectorValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We define a dof handler with a displacement field :u:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"dh = DofHandler(grid)\npush!(dh, :u, 2)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Now we need to define boundary conditions. As discussed earlier we will solve the problem using (i) homogeneous Dirichlet boundary conditions, and (ii) periodic Dirichlet boundary conditions. We construct two different constraint handlers, one for each case. The Dirichlet boundary condition we have seen in many other examples. Here we simply define the condition that the field, :u, should have both components prescribed to 0 on the full boundary:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"ch_dirichlet = ConstraintHandler(dh)\ndirichlet = Dirichlet(\n    :u,\n    union(getfaceset.(Ref(grid), [\"left\", \"right\", \"top\", \"bottom\"])...),\n    (x, t) ->  [0, 0],\n    [1, 2]\n)\nadd!(ch_dirichlet, dirichlet)\nclose!(ch_dirichlet)\nupdate!(ch_dirichlet, 0.0)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"For periodic boundary conditions we use the PeriodicDirichlet constraint type, which is very similar to the Dirichlet type, but instead of a passing a faceset we pass a vector with \"face pairs\", i.e. the mapping between mirror and image parts of the boundary. In this example the \"left\" and \"bottom\" boundaries are mirrors, and the \"right\" and \"top\" boundaries are the mirrors.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"ch_periodic = ConstraintHandler(dh);\nperiodic = PeriodicDirichlet(\n    :u,\n    [\"left\" => \"right\", \"bottom\" => \"top\"],\n    [1, 2]\n)\nadd!(ch_periodic, periodic)\nclose!(ch_periodic)\nupdate!(ch_periodic, 0.0)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"This will now constrain any degrees of freedom located on the mirror boundaries to the matching degree of freedom on the image boundaries. Internally this will create a number of AffineConstraints of the form u_i = 1 * u_j + 0:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"a = AffineConstraint(u_m, [u_i => 1], 0)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"where u_m is the degree of freedom on the mirror and u_i the matching one on the image part. PeriodicDirichlet is thus simply just a more convenient way of constructing such affine constraints since it computes the degree of freedom mapping automatically.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"To simplify things we group the constraint handlers into a named tuple","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"ch = (dirichlet = ch_dirichlet, periodic = ch_periodic);\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We can now construct the sparse matrix. Note that, since we are using affine constraints, which need to modify the matrix sparsity pattern in order to account for the constraint equations, we construct the matrix for the periodic case by passing both the dof handler and the constraint handler.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"K = (\n    dirichlet = create_sparsity_pattern(dh),\n    periodic  = create_sparsity_pattern(dh, ch.periodic),\n);\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We define the fourth order elasticity tensor for the matrix material, and define the inclusions to have 10 times higher stiffness","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"λ, μ = 1e10, 7e9 # Lamé parameters\nδ(i,j) = i == j ? 1.0 : 0.0\nEm = SymmetricTensor{4, 2}(\n    (i,j,k,l) -> λ * δ(i,j) * δ(k,l) + μ * (δ(i,k) * δ(j,l) + δ(i,l) * δ(j,k))\n)\nEi = 10 * Em;\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"As mentioned above, in order to compute the apparent/homogenized stiffness we will solve the problem repeatedly with different macroscale strain tensors to compute the sensitvity of the homogenized stress, barboldsymbolsigma, w.r.t. the macroscopic strain, barboldsymbolvarepsilon. The corresponding unit strains are defined below, and will result in three different right-hand-sides:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"εᴹ = [\n      SymmetricTensor{2,2}([1.0 0.0; 0.0 0.0]), # ε_11 loading\n      SymmetricTensor{2,2}([0.0 0.0; 0.0 1.0]), # ε_22 loading\n      SymmetricTensor{2,2}([0.0 0.5; 0.5 0.0]), # ε_12/ε_21 loading\n];\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"The assembly function is nothing strange, and in particular there is no impact from the choice of boundary conditions, so the same function can be used for both cases. Since we want to solve the system 3 times, once for each macroscopic strain component, we assemble 3 right-hand-sides.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"function doassemble!(cellvalues::CellVectorValues, K::SparseMatrixCSC, dh::DofHandler, εᴹ)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    ndpc = ndofs_per_cell(dh)\n    Ke = zeros(ndpc, ndpc)\n    fe = zeros(ndpc, length(εᴹ))\n    f = zeros(ndofs(dh), length(εᴹ))\n    assembler = start_assemble(K)\n\n    for cell in CellIterator(dh)\n\n        E = cellid(cell) in getcellset(dh.grid, \"inclusions\") ? Ei : Em\n        reinit!(cellvalues, cell)\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            for i in 1:n_basefuncs\n                δεi = shape_symmetric_gradient(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    δεj = shape_symmetric_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (δεi ⊡ E ⊡ δεj) * dΩ\n                end\n                for (rhs, ε) in enumerate(εᴹ)\n                    σᴹ = E ⊡ ε\n                    fe[i, rhs] += ( - δεi ⊡ σᴹ) * dΩ\n               end\n            end\n        end\n\n        cdofs = celldofs(cell)\n        assemble!(assembler, cdofs, Ke)\n        f[cdofs, :] .+= fe\n    end\n    return f\nend;\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We can now assemble the system. The assembly function modifies the matrix in-place, but return the right hand side(s) which we collect in another named tuple.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"rhs = (\n    dirichlet = doassemble!(cellvalues, K.dirichlet, dh, εᴹ),\n    periodic  = doassemble!(cellvalues, K.periodic,  dh, εᴹ),\n);\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"The next step is to solve the systems. Since application of boundary conditions, using the apply! function, modifies both the matrix and the right hand sides we can not use it directly in this case since we want to reuse the matrix again for the next right hand sides. We could of course re-assemble the matrix for every right hand side, but that would not be very efficient. Instead we will use the get_rhs_data function, together with apply_rhs! in a later step. This will extract the necessary data from the matrix such that we can apply it for all the different right hand sides. Note that we call apply! with just the matrix and no right hand side.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"rhsdata = (\n    dirichlet = get_rhs_data(ch.dirichlet, K.dirichlet),\n    periodic  = get_rhs_data(ch.periodic,  K.periodic),\n)\n\napply!(K.dirichlet, ch.dirichlet)\napply!(K.periodic,  ch.periodic)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We can now solve the problem(s). Note that we only use apply_rhs! in the loops below. The boundary conditions are already applied to the matrix above, so we only need to modify the right hand side.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"u = (\n    dirichlet = Vector{Float64}[],\n    periodic  = Vector{Float64}[],\n)\n\nfor i in 1:size(rhs.dirichlet, 2)\n    rhs_i = @view rhs.dirichlet[:, i]                  # Extract this RHS\n    apply_rhs!(rhsdata.dirichlet, rhs_i, ch.dirichlet) # Apply BC\n    u_i = cholesky(Symmetric(K.dirichlet)) \\ rhs_i     # Solve\n    apply!(u_i, ch.dirichlet)                          # Apply BC on the solution\n    push!(u.dirichlet, u_i)                            # Save the solution vector\nend\n\nfor i in 1:size(rhs.periodic, 2)\n    rhs_i = @view rhs.periodic[:, i]                   # Extract this RHS\n    apply_rhs!(rhsdata.periodic, rhs_i, ch.periodic)   # Apply BC\n    u_i = cholesky(Symmetric(K.periodic)) \\ rhs_i      # Solve\n    apply!(u_i, ch.periodic)                           # Apply BC on the solution\n    push!(u.periodic, u_i)                             # Save the solution vector\nend","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"When the solution(s) are known we can compute the averaged stress, barboldsymbolsigma in the RVE. We define a function that does this, and also returns the von Mise stress in every quadrature point for visualization.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"function compute_stress(cellvalues::CellVectorValues, dh::DofHandler, u, εᴹ)\n    σvM_qpdata = zeros(getnquadpoints(cellvalues), getncells(dh.grid))\n    σ̄Ω = zero(SymmetricTensor{2,2})\n    Ω = 0.0 # Total volume\n    for cell in CellIterator(dh)\n        E = cellid(cell) in getcellset(dh.grid, \"inclusions\") ? Ei : Em\n        reinit!(cellvalues, cell)\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            εμ = function_symmetric_gradient(cellvalues, q_point, u[celldofs(cell)])\n            σ = E ⊡ (εᴹ + εμ)\n            σvM_qpdata[q_point, cellid(cell)] = sqrt(3/2 * dev(σ) ⊡ dev(σ))\n            Ω += dΩ # Update total volume\n            σ̄Ω += σ * dΩ # Update integrated stress\n        end\n    end\n    σ̄ = σ̄Ω / Ω\n    return σvM_qpdata, σ̄\nend;\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We now compute the homogenized stress and von Mise stress for all cases","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"σ̄ = (\n    dirichlet = SymmetricTensor{2,2}[],\n    periodic  = SymmetricTensor{2,2}[],\n)\nσ = (\n     dirichlet = Vector{Float64}[],\n     periodic  = Vector{Float64}[],\n)\n\nprojector = L2Projector(ip, grid)\n\nfor i in 1:3\n    σ_qp, σ̄_i = compute_stress(cellvalues, dh, u.dirichlet[i], εᴹ[i])\n    proj = project(projector, σ_qp, qr; project_to_nodes=false)\n    push!(σ.dirichlet, proj)\n    push!(σ̄.dirichlet, σ̄_i)\nend\n\nfor i in 1:3\n    σ_qp, σ̄_i = compute_stress(cellvalues, dh, u.periodic[i], εᴹ[i])\n    proj = project(projector, σ_qp, qr; project_to_nodes=false)\n    push!(σ.periodic, proj)\n    push!(σ̄.periodic, σ̄_i)\nend","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"The remaining thing is to compute the homogenized stiffness. As mentioned in the introduction we can find all the components from the average stress of the sensitivity fields that we have solved for","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"mathsfE_ijkl = barsigma_ij(hatboldsymbolu_kl)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"So we have now already computed all the components, and just need to gather the data in a fourth order tensor:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"E_dirichlet = SymmetricTensor{4,2}((i, j, k, l) -> begin\n    if k == l == 1\n        σ̄.dirichlet[1][i, j] # ∂σ∂ε_**11\n    elseif k == l == 2\n        σ̄.dirichlet[2][i, j] # ∂σ∂ε_**22\n    else\n        σ̄.dirichlet[3][i, j] # ∂σ∂ε_**12 and ∂σ∂ε_**21\n    end\nend)\n\nE_periodic = SymmetricTensor{4,2}((i, j, k, l) -> begin\n    if k == l == 1\n        σ̄.periodic[1][i, j]\n    elseif k == l == 2\n        σ̄.periodic[2][i, j]\n    else\n        σ̄.periodic[3][i, j]\n    end\nend);\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We can check that the result are what we expect, namely that the stiffness with Dirichlet boundary conditions is higher than when using periodic boundary conditions, and that the Reuss assumption is an lower bound, and the Voigt assumption a upper bound. We first compute the volume fraction of the matrix, and then the Voigt and Reuss bounds:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"function matrix_volume_fraction(grid, cellvalues)\n    V  = 0.0 # Total volume\n    Vm = 0.0 # Volume of the matrix\n    for c in CellIterator(grid)\n        reinit!(cellvalues, c)\n        is_matrix = !(cellid(c) in getcellset(grid, \"inclusions\"))\n        for qp in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, qp)\n            V += dΩ\n            if is_matrix\n                Vm += dΩ\n            end\n        end\n    end\n    return Vm / V\nend\n\nvm = matrix_volume_fraction(grid, cellvalues)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"E_voigt = vm * Em + (1-vm) * Ei\nE_reuss = inv(vm * inv(Em) + (1-vm) * inv(Ei));\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"We can now compare the different computed stiffness tensors. We expect E_mathrmReuss leq E_mathrmPeriodicBC leq E_mathrmDirichletBC leq E_mathrmVoigt. A simple thing to compare are the eigenvalues of the tensors. Here we look at the first eigenvalue:","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"ev = (first ∘ eigvals).((E_reuss, E_periodic, E_dirichlet, E_voigt))\nround.(ev; digits=-8)","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Finally, we export the solution and the stress field to a VTK file. For the export we also compute the macroscopic part of the displacement.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"chM = ConstraintHandler(dh)\nadd!(chM, Dirichlet(:u, Set(1:getnnodes(grid)), (x, t) -> εᴹ[Int(t)] ⋅ x, [1, 2]))\nclose!(chM)\nuM = zeros(ndofs(dh))\n\nvtk_grid(\"homogenization\", dh) do vtk\n    for i in 1:3\n        # Compute macroscopic solution\n        update!(chM, i)\n        apply!(uM, chM)\n        # Dirichlet\n        vtk_point_data(vtk, dh, uM + u.dirichlet[i], \"_dirichlet_$i\")\n        vtk_point_data(vtk, projector, σ.dirichlet[i], \"σvM_dirichlet_$i\")\n        # Periodic\n        vtk_point_data(vtk, dh, uM + u.periodic[i], \"_periodic_$i\")\n        vtk_point_data(vtk, projector, σ.periodic[i], \"σvM_periodic_$i\")\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/computational_homogenization/#homogenization-plain-program","page":"Computational homogenization","title":"Plain program","text":"","category":"section"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"Here follows a version of the program without any comments. The file is also available here: computational_homogenization.jl.","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"using Ferrite, SparseArrays, LinearAlgebra\n\nusing FerriteGmsh\n# grid = saved_file_to_grid(\"periodic-rve-coarse.msh\")\ngrid = saved_file_to_grid(\"periodic-rve.msh\")\n\ndim = 2\nip = Lagrange{dim, RefTetrahedron, 1}()\nqr = QuadratureRule{dim, RefTetrahedron}(2)\ncellvalues = CellVectorValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 2)\nclose!(dh);\n\nch_dirichlet = ConstraintHandler(dh)\ndirichlet = Dirichlet(\n    :u,\n    union(getfaceset.(Ref(grid), [\"left\", \"right\", \"top\", \"bottom\"])...),\n    (x, t) ->  [0, 0],\n    [1, 2]\n)\nadd!(ch_dirichlet, dirichlet)\nclose!(ch_dirichlet)\nupdate!(ch_dirichlet, 0.0)\n\nch_periodic = ConstraintHandler(dh);\nperiodic = PeriodicDirichlet(\n    :u,\n    [\"left\" => \"right\", \"bottom\" => \"top\"],\n    [1, 2]\n)\nadd!(ch_periodic, periodic)\nclose!(ch_periodic)\nupdate!(ch_periodic, 0.0)\n\nch = (dirichlet = ch_dirichlet, periodic = ch_periodic);\n\nK = (\n    dirichlet = create_sparsity_pattern(dh),\n    periodic  = create_sparsity_pattern(dh, ch.periodic),\n);\n\nλ, μ = 1e10, 7e9 # Lamé parameters\nδ(i,j) = i == j ? 1.0 : 0.0\nEm = SymmetricTensor{4, 2}(\n    (i,j,k,l) -> λ * δ(i,j) * δ(k,l) + μ * (δ(i,k) * δ(j,l) + δ(i,l) * δ(j,k))\n)\nEi = 10 * Em;\n\nεᴹ = [\n      SymmetricTensor{2,2}([1.0 0.0; 0.0 0.0]), # ε_11 loading\n      SymmetricTensor{2,2}([0.0 0.0; 0.0 1.0]), # ε_22 loading\n      SymmetricTensor{2,2}([0.0 0.5; 0.5 0.0]), # ε_12/ε_21 loading\n];\n\nfunction doassemble!(cellvalues::CellVectorValues, K::SparseMatrixCSC, dh::DofHandler, εᴹ)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    ndpc = ndofs_per_cell(dh)\n    Ke = zeros(ndpc, ndpc)\n    fe = zeros(ndpc, length(εᴹ))\n    f = zeros(ndofs(dh), length(εᴹ))\n    assembler = start_assemble(K)\n\n    for cell in CellIterator(dh)\n\n        E = cellid(cell) in getcellset(dh.grid, \"inclusions\") ? Ei : Em\n        reinit!(cellvalues, cell)\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            for i in 1:n_basefuncs\n                δεi = shape_symmetric_gradient(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    δεj = shape_symmetric_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (δεi ⊡ E ⊡ δεj) * dΩ\n                end\n                for (rhs, ε) in enumerate(εᴹ)\n                    σᴹ = E ⊡ ε\n                    fe[i, rhs] += ( - δεi ⊡ σᴹ) * dΩ\n               end\n            end\n        end\n\n        cdofs = celldofs(cell)\n        assemble!(assembler, cdofs, Ke)\n        f[cdofs, :] .+= fe\n    end\n    return f\nend;\n\nrhs = (\n    dirichlet = doassemble!(cellvalues, K.dirichlet, dh, εᴹ),\n    periodic  = doassemble!(cellvalues, K.periodic,  dh, εᴹ),\n);\n\nrhsdata = (\n    dirichlet = get_rhs_data(ch.dirichlet, K.dirichlet),\n    periodic  = get_rhs_data(ch.periodic,  K.periodic),\n)\n\napply!(K.dirichlet, ch.dirichlet)\napply!(K.periodic,  ch.periodic)\n\nu = (\n    dirichlet = Vector{Float64}[],\n    periodic  = Vector{Float64}[],\n)\n\nfor i in 1:size(rhs.dirichlet, 2)\n    rhs_i = @view rhs.dirichlet[:, i]                  # Extract this RHS\n    apply_rhs!(rhsdata.dirichlet, rhs_i, ch.dirichlet) # Apply BC\n    u_i = cholesky(Symmetric(K.dirichlet)) \\ rhs_i     # Solve\n    apply!(u_i, ch.dirichlet)                          # Apply BC on the solution\n    push!(u.dirichlet, u_i)                            # Save the solution vector\nend\n\nfor i in 1:size(rhs.periodic, 2)\n    rhs_i = @view rhs.periodic[:, i]                   # Extract this RHS\n    apply_rhs!(rhsdata.periodic, rhs_i, ch.periodic)   # Apply BC\n    u_i = cholesky(Symmetric(K.periodic)) \\ rhs_i      # Solve\n    apply!(u_i, ch.periodic)                           # Apply BC on the solution\n    push!(u.periodic, u_i)                             # Save the solution vector\nend\n\nfunction compute_stress(cellvalues::CellVectorValues, dh::DofHandler, u, εᴹ)\n    σvM_qpdata = zeros(getnquadpoints(cellvalues), getncells(dh.grid))\n    σ̄Ω = zero(SymmetricTensor{2,2})\n    Ω = 0.0 # Total volume\n    for cell in CellIterator(dh)\n        E = cellid(cell) in getcellset(dh.grid, \"inclusions\") ? Ei : Em\n        reinit!(cellvalues, cell)\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            εμ = function_symmetric_gradient(cellvalues, q_point, u[celldofs(cell)])\n            σ = E ⊡ (εᴹ + εμ)\n            σvM_qpdata[q_point, cellid(cell)] = sqrt(3/2 * dev(σ) ⊡ dev(σ))\n            Ω += dΩ # Update total volume\n            σ̄Ω += σ * dΩ # Update integrated stress\n        end\n    end\n    σ̄ = σ̄Ω / Ω\n    return σvM_qpdata, σ̄\nend;\n\nσ̄ = (\n    dirichlet = SymmetricTensor{2,2}[],\n    periodic  = SymmetricTensor{2,2}[],\n)\nσ = (\n     dirichlet = Vector{Float64}[],\n     periodic  = Vector{Float64}[],\n)\n\nprojector = L2Projector(ip, grid)\n\nfor i in 1:3\n    σ_qp, σ̄_i = compute_stress(cellvalues, dh, u.dirichlet[i], εᴹ[i])\n    proj = project(projector, σ_qp, qr; project_to_nodes=false)\n    push!(σ.dirichlet, proj)\n    push!(σ̄.dirichlet, σ̄_i)\nend\n\nfor i in 1:3\n    σ_qp, σ̄_i = compute_stress(cellvalues, dh, u.periodic[i], εᴹ[i])\n    proj = project(projector, σ_qp, qr; project_to_nodes=false)\n    push!(σ.periodic, proj)\n    push!(σ̄.periodic, σ̄_i)\nend\n\nE_dirichlet = SymmetricTensor{4,2}((i, j, k, l) -> begin\n    if k == l == 1\n        σ̄.dirichlet[1][i, j] # ∂σ∂ε_**11\n    elseif k == l == 2\n        σ̄.dirichlet[2][i, j] # ∂σ∂ε_**22\n    else\n        σ̄.dirichlet[3][i, j] # ∂σ∂ε_**12 and ∂σ∂ε_**21\n    end\nend)\n\nE_periodic = SymmetricTensor{4,2}((i, j, k, l) -> begin\n    if k == l == 1\n        σ̄.periodic[1][i, j]\n    elseif k == l == 2\n        σ̄.periodic[2][i, j]\n    else\n        σ̄.periodic[3][i, j]\n    end\nend);\n\nfunction matrix_volume_fraction(grid, cellvalues)\n    V  = 0.0 # Total volume\n    Vm = 0.0 # Volume of the matrix\n    for c in CellIterator(grid)\n        reinit!(cellvalues, c)\n        is_matrix = !(cellid(c) in getcellset(grid, \"inclusions\"))\n        for qp in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, qp)\n            V += dΩ\n            if is_matrix\n                Vm += dΩ\n            end\n        end\n    end\n    return Vm / V\nend\n\nvm = matrix_volume_fraction(grid, cellvalues)\n\nE_voigt = vm * Em + (1-vm) * Ei\nE_reuss = inv(vm * inv(Em) + (1-vm) * inv(Ei));\n\nev = (first ∘ eigvals).((E_reuss, E_periodic, E_dirichlet, E_voigt))\nround.(ev; digits=-8)\n\nchM = ConstraintHandler(dh)\nadd!(chM, Dirichlet(:u, Set(1:getnnodes(grid)), (x, t) -> εᴹ[Int(t)] ⋅ x, [1, 2]))\nclose!(chM)\nuM = zeros(ndofs(dh))\n\nvtk_grid(\"homogenization\", dh) do vtk\n    for i in 1:3\n        # Compute macroscopic solution\n        update!(chM, i)\n        apply!(uM, chM)\n        # Dirichlet\n        vtk_point_data(vtk, dh, uM + u.dirichlet[i], \"_dirichlet_$i\")\n        vtk_point_data(vtk, projector, σ.dirichlet[i], \"σvM_dirichlet_$i\")\n        # Periodic\n        vtk_point_data(vtk, dh, uM + u.periodic[i], \"_periodic_$i\")\n        vtk_point_data(vtk, projector, σ.periodic[i], \"σvM_periodic_$i\")\n    end\nend;","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"","category":"page"},{"location":"examples/computational_homogenization/","page":"Computational homogenization","title":"Computational homogenization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"using Ferrite\ngrid = generate_grid(Triangle, (2, 2))\ndh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\nu = rand(ndofs(dh)); σ = rand(getncells(grid))","category":"page"},{"location":"manual/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"When the problem is solved, and the solution vector u is known we typically want to visualize it. The simplest way to do this is to write the solution to a VTK-file, which can be viewed in e.g. Paraview. To write VTK-files, Ferrite uses, and extends, functions from the WriteVTK.jl package to simplify the exporting.","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"First we need to create a file, based on the grid. This is done with the vtk_grid function:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", grid)\n# hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Next we have to add data to the file. We may add different kinds of data; point data using vtk_point_data or cell data using vtk_cell_data. Point data is data for each nodal coordinate in the grid, for example our solution vector. Point data can be either scalars or vectors. Cell data is – as the name suggests – data for each cell. This can be for example the stress. As an example, lets add a solution vector u as point data, and a vector with stress for each cell, σ, as cell data:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_point_data(vtk, u, \"my-point-data\")\nvtk_cell_data(vtk,  σ, \"my-cell-data\")\n# hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Finally, we need to save the file to disk, using vtk_save","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Alternatively, all of the above can be done using a do block:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", grid) do vtk\n    vtk_point_data(vtk, u, \"my-point-data\")\n    vtk_cell_data(vtk, σ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"For other functionality, and more information refer to the WriteVTK.jl README. In particular, for exporting the solution at multiple time steps, the section on PVD files is useful.","category":"page"},{"location":"manual/export/#Exporting-with-DofHandler","page":"Export","title":"Exporting with DofHandler","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"There is an even more convenient way to export a solution vector u – using the DofHandler. The DofHandler already contains all of the information needed, such as the names of our fields and if they are scalar or vector fields. But most importantly the DofHandler knows about the numbering and distribution of degrees of freedom, and thus knows how to \"distribute\" the solution vector on the grid. For example, lets say we have a DofHandler dh and a solution vector u:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", dh)\nvtk_point_data(vtk, dh, u)\nvtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"or with a do-block:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\n    vtk_cell_data(vtk, σ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"When vtk_point_data is used with a DofHandler all of the fields will be written to the VTK file, and the names will be determined by the fieldname symbol that was used when the field was added to the DofHandler.","category":"page"},{"location":"manual/export/#Exporting-Boundary-Conditions","page":"Export","title":"Exporting Boundary Conditions","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"There is also a vtk_point_data which accepts a ConstraintHandler. This method is useful to verify that the boundary conditions are applied where they are supposed to. For a ConstraintHandler ch we can export the boundary conditions as","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"boundary-conditions\", grid) do vtk\n    vtk_point_data(vtk, ch)\nend","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"This will export zero-valued fields with ones on the parts where the boundary conditions are active.","category":"page"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/dofhandler/#Degrees-of-Freedom","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Degrees of freedom (dofs) are distributed by the DofHandler or the MixedDofHandler.","category":"page"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"DofHandler\nMixedDofHandler","category":"page"},{"location":"reference/dofhandler/#Ferrite.DofHandler","page":"Degrees of Freedom","title":"Ferrite.DofHandler","text":"DofHandler(grid::Grid)\n\nConstruct a DofHandler based on grid.\n\nOperates slightly faster than MixedDofHandler. Supports:\n\nGrids with a single concrete cell type.\nOne or several fields on the whole domaine.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.MixedDofHandler","page":"Degrees of Freedom","title":"Ferrite.MixedDofHandler","text":"MixedDofHandler(grid::Grid)\n\nConstruct a MixedDofHandler based on grid. Supports:\n\nGrids with or without concrete element type (E.g. \"mixed\" grids with several different element types.)\nOne or several fields, which can live on the whole domain or on subsets of the Grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Adding-fields-to-the-DofHandlers","page":"Degrees of Freedom","title":"Adding fields to the DofHandlers","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"push!(::DofHandler, ::Symbol, ::Int, ::Interpolation)\npush!(::MixedDofHandler, ::FieldHandler)\nField\nFieldHandler\nclose!(::MixedDofHandler)","category":"page"},{"location":"reference/dofhandler/#Base.push!-Tuple{DofHandler, Symbol, Int64, Interpolation}","page":"Degrees of Freedom","title":"Base.push!","text":"push!(dh::AbstractDofHandler, name::Symbol, dim::Int[, ip::Interpolation])\n\nAdd a dim-dimensional Field called name which is approximated by ip to dh.\n\nThe field is added to all cells of the underlying grid. In case no interpolation ip is given, the default interpolation of the grid's celltype is used.  If the grid uses several celltypes, push!(dh::MixedDofHandler, fh::FieldHandler) must be used instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Base.push!-Tuple{MixedDofHandler, FieldHandler}","page":"Degrees of Freedom","title":"Base.push!","text":"push!(dh::MixedDofHandler, fh::FieldHandler)\n\nAdd all fields of the FieldHandler fh to dh.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Ferrite.Field","page":"Degrees of Freedom","title":"Ferrite.Field","text":"Field(name::Symbol, interpolation::Interpolation, dim::Int)\n\nConstruct dim-dimensional Field called name which is approximated by interpolation.\n\nThe interpolation is used for distributing the degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.FieldHandler","page":"Degrees of Freedom","title":"Ferrite.FieldHandler","text":"FieldHandler(fields::Vector{Field}, cellset::Set{Int})\n\nConstruct a FieldHandler based on an array of Fields and assigns it a set of cells.\n\nA FieldHandler must fullfill the following requirements:\n\nAll Cells in cellset are of the same type.\nEach field only uses a single interpolation on the cellset.\nEach cell belongs only to a single FieldHandler, i.e. all fields on a cell must be added within the same FieldHandler.\n\nNotice that a FieldHandler can hold several fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/dofhandler/#Ferrite.close!-Tuple{MixedDofHandler}","page":"Degrees of Freedom","title":"Ferrite.close!","text":"close!(dh::AbstractDofHandler)\n\nCloses dh and creates degrees of freedom for each cell.\n\nIf there are several fields, the dofs are added in the following order: For a MixedDofHandler, go through each FieldHandler in the order they were added. For each field in the FieldHandler or in the DofHandler (again, in the order the fields were added), create dofs for the cell. This means that dofs on a particular cell, the dofs will be numbered according to the fields; first dofs for field 1, then field 2, etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Common-methods","page":"Degrees of Freedom","title":"Common methods","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"ndofs\ndof_range\nFerrite.nfields(::MixedDofHandler)\nFerrite.getfieldnames(::MixedDofHandler)\nFerrite.getfielddim(::MixedDofHandler, ::Symbol)","category":"page"},{"location":"reference/dofhandler/#Ferrite.ndofs","page":"Degrees of Freedom","title":"Ferrite.ndofs","text":"ndofs(dh::AbstractDofHandler)\n\nReturn the number of degrees of freedom in dh\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.dof_range","page":"Degrees of Freedom","title":"Ferrite.dof_range","text":"dof_range(dh:DofHandler, field_name)\n\nReturn the local dof range for field_name. Example:\n\njulia> grid = generate_grid(Triangle, (3, 3))\nGrid{2, Triangle, Float64} with 18 Triangle cells and 16 nodes\n\njulia> dh = DofHandler(grid); push!(dh, :u, 3); push!(dh, :p, 1); close!(dh);\n\njulia> dof_range(dh, :u)\n1:9\n\njulia> dof_range(dh, :p)\n10:12\n\n\n\n\n\n","category":"function"},{"location":"reference/dofhandler/#Ferrite.nfields-Tuple{MixedDofHandler}","page":"Degrees of Freedom","title":"Ferrite.nfields","text":"nfields(dh::MixedDofHandler)\n\nReturns the number of unique fields defined.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Ferrite.getfieldnames-Tuple{MixedDofHandler}","page":"Degrees of Freedom","title":"Ferrite.getfieldnames","text":"getfieldnames(dh::MixedDofHandler)\n\nReturns the union of all the fields. Can be used as an iterable over all the fields in the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#Ferrite.getfielddim-Tuple{MixedDofHandler, Symbol}","page":"Degrees of Freedom","title":"Ferrite.getfielddim","text":"getfielddim(dh::MixedDofHandler, name::Symbol)\n\nReturns the dimension of a specific field, given by name. Note that it will return the dimension of the first field found among the FieldHandlers.\n\n\n\n\n\n","category":"method"},{"location":"reference/dofhandler/#CellIterator","page":"Degrees of Freedom","title":"CellIterator","text":"","category":"section"},{"location":"reference/dofhandler/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"CellIterator","category":"page"},{"location":"reference/dofhandler/#Ferrite.CellIterator","page":"Degrees of Freedom","title":"Ferrite.CellIterator","text":"CellIterator(grid::Grid)\nCellIterator(dh::DofHandler)\nCellIterator(mdh::MixedDofHandler)\n\nReturn a CellIterator to conveniently loop over all the cells in a grid.\n\nExamples\n\nfor cell in CellIterator(dh)      # dh::DofHandler\n    coords = getcoordinates(cell) # get the coordinates\n    dofs = celldofs(cell)         # get the dofs for this cell\n    reinit!(cv, cell)             # reinit! the FE-base with a CellIterator\nend\n\nHere, cell::CellIterator. Looking at a specific cell (instead of  looping over all), e.g. nr 10, can be done by\n\ncell = CellIterator(dh)     # Refers to cell nr. 1 upon creation\nreinit!(cell, 10)           # Update to cell nr. 10\ndofs = celldofs(cell)       # Get the dofs for cell nr. 10\n\n\n\n\n\n","category":"type"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/heat_equation.jl\"","category":"page"},{"location":"examples/heat_equation/#Heat-Equation","page":"Heat Equation","title":"Heat Equation","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Figure 1: Temperature field on the unit square with an internal uniform heat source solved with homogeneous Dirichlet boundary conditions on the boundary.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"tip: Tip\nThis example is also available as a Jupyter notebook: heat_equation.ipynb.","category":"page"},{"location":"examples/heat_equation/#Introduction","page":"Heat Equation","title":"Introduction","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The heat equation is the \"Hello, world!\" equation of finite elements. Here we solve the equation on a unit square, with a uniform internal source. The strong form of the (linear) heat equation is given by","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":" -nabla cdot (k nabla u) = f  quad textbfx in Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set f = 1 and k = 1. We will consider homogeneous Dirichlet boundary conditions such that","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"u(textbfx) = 0 quad textbfx in partial Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where partial Omega denotes the boundary of Omega.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The resulting weak form is given by","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"int_Omega nabla delta u cdot nabla u  dOmega = int_Omega delta u  dOmega quad forall delta u in mathbbT","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where delta u is a test function and mathbbT is a suitable test function space.","category":"page"},{"location":"examples/heat_equation/#Commented-Program","page":"Heat Equation","title":"Commented Program","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"First we load Ferrite, and some other packages we need","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, SparseArrays","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We start  generating a simple grid with 20x20 quadrilateral elements using generate_grid. The generator defaults to the unit square, so we don't need to specify the corners of the domain.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"grid = generate_grid(Quadrilateral, (20, 20));\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Trial-and-test-functions","page":"Heat Equation","title":"Trial and test functions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"A CellValues facilitates the process of evaluating values and gradients of test and trial functions (among other things). Since the problem is a scalar problem we will use a CellScalarValues object. To define this we need to specify an interpolation space for the shape functions. We use Lagrange functions (both for interpolating the function and the geometry) based on the reference \"cube\". We also define a quadrature rule based on the same reference cube. We combine the interpolation and the quadrature rule to a CellScalarValues object.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Degrees-of-freedom","page":"Heat Equation","title":"Degrees of freedom","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we need to define a DofHandler, which will take care of numbering and distribution of degrees of freedom for our approximated fields. We create the DofHandler and then add a single field called u. Lastly we close! the DofHandler, it is now that the dofs are distributed for all the elements.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now that we have distributed all our dofs we can create our tangent matrix, using create_sparsity_pattern. This function returns a sparse matrix with the correct elements stored.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"K = create_sparsity_pattern(dh)","category":"page"},{"location":"examples/heat_equation/#Boundary-conditions","page":"Heat Equation","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"In Ferrite constraints like Dirichlet boundary conditions are handled by a ConstraintHandler.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"ch = ConstraintHandler(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we need to add constraints to ch. For this problem we define homogeneous Dirichlet boundary conditions on the whole boundary, i.e. the union of all the face sets on the boundary.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"∂Ω = union(getfaceset.((grid, ), [\"left\", \"right\", \"top\", \"bottom\"])...);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we are set up to define our constraint. We specify which field the condition is for, and our combined face set ∂Ω. The last argument is a function which takes the spatial coordinate textbfx and the current time t and returns the prescribed value. In this case it is trivial – no matter what textbfx and t we return 0. When we have specified our constraint we add! it to ch.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dbc = Dirichlet(:u, ∂Ω, (x, t) -> 0)\nadd!(ch, dbc);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We also need to close! and update! our boundary conditions. When we call close! the dofs which will be constrained by the boundary conditions are calculated and stored in our ch object. Since the boundary conditions are, in this case, independent of time we can update! them directly with e.g. t = 0.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"close!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Assembling-the-linear-system","page":"Heat Equation","title":"Assembling the linear system","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we have all the pieces needed to assemble the linear system, K u = f. We define a function, doassemble to do the assembly, which takes our cellvalues, the sparse matrix and our DofHandler as input arguments. The function returns the assembled stiffness matrix, and the force vector. Note that here f and u correspond to underlinehatf and underlinehatu from the introduction, since they represent the discretized versions. However, through the code we use f and u instead to reflect the strong connection between the weak form and the Ferrite implementation.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function doassemble(cellvalues::CellScalarValues{dim}, K::SparseMatrixCSC, dh::DofHandler) where {dim}","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We allocate the element stiffness matrix and element force vector just once before looping over all the cells instead of allocating them every time in the loop.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we define the global force vector f and use that and the stiffness matrix K and create an assembler. The assembler is just a thin wrapper around f and K and some extra storage to make the assembling faster.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It is now time to loop over all the cells in our grid. We do this by iterating over a CellIterator. The iterator caches some useful things for us, for example the nodal coordinates for the cell, and the local degrees of freedom.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    for cell in CellIterator(dh)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Always remember to reset the element stiffness matrix and force vector since we reuse them for all elements.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        fill!(Ke, 0)\n        fill!(fe, 0)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"For each cell we also need to reinitialize the cached values in cellvalues.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        reinit!(cellvalues, cell)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It is now time to loop over all the quadrature points in the cell and assemble the contribution to Ke and fe. The integration weight can be queried from cellvalues by getdetJdV.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"For each quadrature point we loop over all the (local) shape functions. We need the value and gradient of the test function δu and also the gradient of the trial function u. We get all of these from cellvalues. Please note that the variables δu, ∇δu and ∇u are actually phi_i(textbfx_q), nabla phi_i(textbfx_q) and nabla phi_j(textbfx_q), i.e. the evaluation of the trial and test functions. However, to underline the strong parallel between the weak form and the implementation, this example uses the symbols appearing in the weak form.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"            for i in 1:n_basefuncs\n                δu  = shape_value(cellvalues, q_point, i)\n                ∇δu = shape_gradient(cellvalues, q_point, i)\n                fe[i] += δu * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n                end\n            end\n        end","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The last step in the element loop is to assemble Ke and fe into the global K and f with assemble!.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Solution-of-the-system","page":"Heat Equation","title":"Solution of the system","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The last step is to solve the system. First we call doassemble to obtain the global stiffness matrix K and force vector f.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"K, f = doassemble(cellvalues, K, dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To account for the boundary conditions we use the apply! function. This modifies elements in K and f respectively, such that we can get the correct solution vector u by using \\.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"apply!(K, f, ch)\nu = K \\ f;\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Exporting-to-VTK","page":"Heat Equation","title":"Exporting to VTK","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To visualize the result we export the grid and our field u to a VTK-file, which can be viewed in e.g. ParaView.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vtk_grid(\"heat_equation\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\nend","category":"page"},{"location":"examples/heat_equation/#heat_equation-plain-program","page":"Heat Equation","title":"Plain program","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Here follows a version of the program without any comments. The file is also available here: heat_equation.jl.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, SparseArrays\n\ngrid = generate_grid(Quadrilateral, (20, 20));\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\n\nK = create_sparsity_pattern(dh)\n\nch = ConstraintHandler(dh);\n\n∂Ω = union(getfaceset.((grid, ), [\"left\", \"right\", \"top\", \"bottom\"])...);\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> 0)\nadd!(ch, dbc);\n\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction doassemble(cellvalues::CellScalarValues{dim}, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n\n    for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                δu  = shape_value(cellvalues, q_point, i)\n                ∇δu = shape_gradient(cellvalues, q_point, i)\n                fe[i] += δu * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\n\nK, f = doassemble(cellvalues, K, dh);\n\napply!(K, f, ch)\nu = K \\ f;\n\nvtk_grid(\"heat_equation\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\nend","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it Ferrite.","category":"page"},{"location":"manual/boundary_conditions/#Dirichlet-Boundary-Conditions","page":"Boundary Conditions","title":"Dirichlet Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At a Dirichlet boundary the solution is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To be able to tell which degrees of freedom we should constrain we need the DofHandler.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ch = ConstraintHandler(dh)","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"TBW","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"note: Examples\nThe following commented examples makes use of Dirichlet boundary conditions:Heat Equation\nTODO","category":"page"},{"location":"manual/boundary_conditions/#Neumann-Boundary-Conditions","page":"Boundary Conditions","title":"Neumann Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At the Neumann part of the boundary we know something about the gradient of the solution.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"As an example, the following code snippet can be included in the element routine, to evaluate the boundary integral:","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"for face in 1:nfaces(cell)\n    if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"Neumann Boundary\")\n        reinit!(facevalues, cell, face)\n        for q_point in 1:getnquadpoints(facevalues)\n            dΓ = getdetJdV(facevalues, q_point)\n            for i in 1:getnbasefunctions(facevalues)\n                δu = shape_value(facevalues, q_point, i)\n                fe[i] += δu * b * dΓ\n            end\n        end\n    end\nend","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We start by looping over all the faces of the cell, next we have to check if this particular face is located on the boundary, and then also check that the face is located on our face-set called \"Neumann Boundary\". If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize facevalues for this face, using reinit!. When reinit!ing facevalues we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"note: Examples\nThe following commented examples makes use of Neumann boundary conditions:TODO","category":"page"},{"location":"manual/boundary_conditions/#Periodic-boundary-conditions","page":"Boundary Conditions","title":"Periodic boundary conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Periodic boundary conditions ensure that the solution is periodic. This is common in multiscale modeling and computational homogenization when solving the finite element problem on the subscale. The subscale problem is then solved on a Representative Volume Element (RVE), or Statistical Volume Element (SVE), typically on a cubical domain, to find the fluctuation field u^mu with a known macroscopic field u^mathrmM as input. Periodic boundary conditions is one choice for such a setup, and ensures that the fluctuation is periodic.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"A periodic Dirichlet boundary condition is described by","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"llbracket u rrbracket = 0 quad mathrmon quad Gamma^+","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"where llbracket bullet rrbracket = bullet(x^+) - bullet(x^-) is the \"jump operator\", and x^+ and x^- coordinates on the image, Gamma^+, and mirror, Gamma^-, part of the boundary. Thus, this condition ensure that the jump, or difference, in the solution between the image and mirror boundary is the zero – the solution becomes periodic.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In Ferrite periodic Dirichlet boundary conditions can be added to the ConstraintHandler by adding a PeriodicDirichlet as follows:","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"# Create a constraint handler from the dof handler\nch = ConstraintHandler(dofhandler)\n\n# Construct the periodic constraint for field :u\npdbc = PeriodicDirichlet(:u, [\"left\" => \"right\", \"bottom\" => \"top\"])\n\n# Add the constraint to the constraint handler\nadd!(ch, pdbc)\n\n# If no more constraints should be added we can close\nclose!(ch)","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This adds a constraint on the field :u that ensures that the solution on the mirror boundary face sets (\"left\" and \"bottom\") mirrors the solution on the image boundary face sets (\"right\" and \"top\").","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The constraint is imposed in a strong sense, so note that this requires (i) a periodic domain and (ii) a periodic mesh such that corresponding element sides can be found on the image and mirror parts of the boundary, respectively.","category":"page"},{"location":"manual/boundary_conditions/#Heterogeneous-\"periodic\"-constraint","page":"Boundary Conditions","title":"Heterogeneous \"periodic\" constraint","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Instead of solving the just the fluctuation field on the RVE it is possible to solve for the full field. For example, in the multi-scale setup described above, where the solution in the RVE is constructed as","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u = u^mathrmM + u^mu","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"it is possible to solve for u rather than just u^mu. In order to still ensure a periodic fluctuation the constraint can instead be described by","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"llbracket u rrbracket = llbracket u^mathrmM rrbracket\nquad mathrmon quad Gamma^+","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The PeriodicDirichlet constraint can be used for this too, although the constraint in this case is not technically periodic as applied to u, but ensures periodicity on the fluctuation u^mu. This is done by passing a function to PeriodicDirichlet, similar to Dirichlet, which, given the coordinate boldsymbolx and time t, computes the prescribed values of u^mathrmM on the boundary.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"As an example, consider the case where the macroscopic solution is constructed as follows (first order homogenization):","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u^mathrmM = baru + boldsymbolnabla baru cdot boldsymbolx - barboldsymbolx","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"where baru is the homogenized field from the macroscale, and barboldsymbolx the centre coordinate of the RVE. This corresponds to the following constraint in Ferrite:","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"# Construct the \"periodic\" constraint\npdbc = PeriodicDirichlet(\n    :u,\n    [\"left\" => \"right\", \"bottom\" => \"top\"],\n    (x, t) -> ū + ∇ū ⋅ (x - x̄)\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"#Ferrite.jl","page":"Home","title":"Ferrite.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple finite element toolbox written in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ferrite is a finite element toolbox that provides functionalities to implement finite element analysis in Julia. The aim is to be general and to keep mathematical abstractions. The main functionalities of the package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Facilitate integration using different quadrature rules.\nDefine different finite element interpolations.\nEvaluate shape functions, derivatives of shape functions etc. for the different interpolations and quadrature rules.\nEvaluate functions and derivatives in the finite element space.\nGenerate simple grids.\nExport grids and solutions to VTK.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to get started with Ferrite is to look at the documented examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nFerrite is still under development. If you find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the Ferrite GitHub page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install Ferrite from the Pkg REPL (press ] in the Julia REPL to enter pkg> mode):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Ferrite","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nAlternative installation method:julia> import Pkg; Pkg.add(\"Ferrite\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ferrite","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/assembly/#man-assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"When the local stiffness matrix and force vector have been calculated they should be assembled into the global stiffness matrix and the global force vector. This is just a matter of adding the local matrix and vector to the global one, at the correct place. Consider e.g. assembling the local stiffness matrix ke and the local force vector fe into the global K and f respectively. These should be assembled into the row/column which corresponds to the degrees of freedom for the cell:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K[celldofs, celldofs] += ke\nf[celldofs]           += fe","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"where celldofs is the vector containing the degrees of freedom for the cell. The method above is very inefficient – it is especially costly to index into the sparse matrix K directly. Therefore we will instead use an Assembler that will help with the assembling of both the global stiffness matrix and the global force vector. It is also often convenient to create the sparse matrix just once, and reuse the allocated matrix. This is useful for e.g. iterative solvers or time dependent problems where the sparse matrix structure, or Sparsity Pattern will stay the same in every iteration/ time step.","category":"page"},{"location":"manual/assembly/#Sparsity-Pattern","page":"Assembly","title":"Sparsity Pattern","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler we can obtain the corresponding sparse matrix by using the create_sparsity_pattern function. This will setup a SparseMatrixCSC with stored values on all the places corresponding to the degree of freedom numbering in the DofHandler. This means that when we assemble into the global stiffness matrix there is no need to change the internal representation of the sparse matrix since the sparse structure will not change.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Often the finite element problem is symmetric and will result in a symmetric sparse matrix. This information is often something that the sparse solver can take advantage of. If the solver only needs half the matrix there is no need to assemble both halves. For this purpose there is a create_symmetric_sparsity_pattern function that will only create the upper half of the matrix, and return a Symmetric wrapped SparseMatrixCSC.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler dh we can obtain the (symmetric) sparsity pattern as","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nK = create_symmetric_sparsity_pattern(dh)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"The returned sparse matrix will be used together with an Assembler, which assembles efficiently into the matrix, without modifying the internal representation.","category":"page"},{"location":"manual/assembly/#Assembler","page":"Assembly","title":"Assembler","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Assembling efficiently into the sparse matrix requires some extra workspace. This workspace is allocated in an Assembler. start_assemble is used to create an Assembler:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"A = start_assemble(K)\nA = start_assemble(K, f)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"where K is the global stiffness matrix, and f the global force vector. It is optional to pass the force vector to the assembler – sometimes there is no need to assemble a global force vector.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"The assemble! function is used to assemble element contributions to the assembler. For example, to assemble the element tangent stiffness ke and the element force vector fe to the assembler A, the following code can be used:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"assemble!(A, celldofs, ke)\nassemble!(A, celldofs, ke, fe)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"which perform the following operations in an efficient manner:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K[celldofs, celldofs] += ke\nf[celldofs]           += fe","category":"page"},{"location":"manual/assembly/#Pseudo-code-for-efficient-assembly","page":"Assembly","title":"Pseudo-code for efficient assembly","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Quite often the same sparsity pattern can be reused multiple times. For example:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"For time-dependent problems the pattern can be reused for all timesteps\nFor non-linear problems the pattern can be reused for all iterations","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"In such cases it is enough to construct the global matrix K once. Below is some pseudo-code for how to do this for a time-dependent problem:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nf = zeros(ndofs(dh))\n\nfor t in 1:timesteps\n    A = start_assemble(K, f) # start_assemble zeroes K and f\n    for cell in CellIterator(dh)\n        ke, fe = element_routine(...)\n        assemble!(A, celldofs(cell), ke, fe)\n    end\n    # Apply boundary conditions and solve for u(t)\n    # ...\nend","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/quasi_incompressible_hyperelasticity.jl\"","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Nearly-Incompressible-Hyperelasticity","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"(Image: )","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: quasi_incompressible_hyperelasticity.ipynb","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Introduction","page":"Nearly Incompressible Hyperelasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"In this example we study quasi- or nearly-incompressible hyperelasticity using the stable Taylor-Hood approximation. In spirit, this example is the nonlinear analogue of incompressible_elasticity and the incompressible analogue of hyperelasticity. Much of the code therefore follows from the above two examples. The problem is formulated in the undeformed or reference configuration with the displacement mathbfu and pressure p being the unknown fields. We now briefly outline the formulation. Consider the standard hyperelasticity problem","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  mathbfu = argmin_mathbfvinmathcalK(Omega)Pi(mathbfv)quad textwherequad Pi(mathbfv)  = int_Omega Psi(mathbfv)  mathrmdOmega ","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"where mathcalK(Omega) is a suitable function space.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"For clarity of presentation we ignore any non-zero surface tractions and body forces and instead consider only applied displacements (i.e. non-homogeneous dirichlet boundary conditions). Moreover we stick our attention to the standard Neo-Hookean stored energy density","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"    Psi(mathbfu) = fracmu2left(I_1 - 3 right) - mu log(J) + fraclambda2left( J - 1right)^2","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"where I_1 = mathrmtr(mathbfC) = mathrmtr(mathbfF^mathrmT mathbfF) = F_ijF_ij and J = det(mathbfF) denote the standard invariants of the deformation gradient tensor mathbfF = mathbfI+nabla_mathbfX mathbfu. The above problem is ill-posed in the limit of incompressibility (or near-incompressibility), namely when","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"    lambdamu rightarrow +infty","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"In order to alleviate the problem, we consider the partial legendre transform of the strain energy density Psi with respect to J = det(mathbfF), namely","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  widehatPsi(mathbfu p) = sup_J left p(J - 1) - fracmu2left(I_1 - 3 right) + mu log(J) - fraclambda2left( J - 1right)^2 right","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The supremum, say J^star, can be calculated in closed form by the first order optimailty condition partialwidehatPsipartial J = 0. This gives","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  J^star(p) = fraclambda + p + sqrt(lambda + p)^2 + 4 lambda mu (2 lambda)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Furthermore, taking the partial legendre transform of widehatPsi once again, gives us back the original problem, i.e.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"    Psi(mathbfu) = Psi^star(mathbfu p) = sup_p left p(J - 1) - p(J^star - 1) + fracmu2left(I_1 - 3 right) - mu log(J^star) + fraclambda2left( J^star - 1right)^2 right","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Therefore our original hyperelasticity problem can now be reformulated as","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  inf_mathbfuinmathcalK(Omega)sup_p int_OmegaPsi^star (mathbfu p)  mathrmdOmega","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The total (modified) energy Pi^star can then be written as","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  Pi^star(mathbfu p) = int_Omega p (J - J^star)  mathrmdOmega + int_Omega fracmu2 left( I_1 - 3right)  mathrmdOmega - int_Omega mulog(J^star) mathrmdOmega + int_Omega fraclambda2left( J^star - 1 right)^2 mathrmdOmega","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The Euler-Lagrange equations corresponding to the above energy give us our governing PDEs in the weak form, namely","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  int_Omega fracpartialPsi^starpartial mathbfFdelta mathbfF  mathrmdOmega = 0","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  int_Omega fracpartial Psi^starpartial pdelta p  mathrmdOmega = 0","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"where delta mathrmF = delta mathrmgrad_0(mathbfu) = mathrmgrad_0(delta mathbfu) and delta mathbfu and delta p denote arbitrary variations with respect to displacement and pressure (or the test functions). See the references below for a more detailed explanation of the above mathematical trick. Now, in order to apply Newton's method to the above problem, we further need to linearize the above equations and calculate the respective hessians (or tangents), namely, partial^2Psi^starpartial mathbfF^2, partial^2Psi^starpartial p^2 and partial^2Psi^starpartial mathbfFpartial p which, using Tensors.jl, can be determined conveniently using automatic differentiation (see the code below). Hence we only need to define the above potential. The remaineder of the example follows similarly.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#References","page":"Nearly Incompressible Hyperelasticity","title":"References","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"A paradigm for higher-order polygonal elements in finite elasticity using a gradient correction scheme, CMAME 2016, 306, 216–251\nApproximation of incompressible large deformation elastic problems: some unresolved issues, Computational Mechanics, 2013","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Implementation","page":"Nearly Incompressible Hyperelasticity","title":"Implementation","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We now get to the actual code. First, we import the respective packages","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"using Ferrite, Tensors, ProgressMeter\nusing BlockArrays, SparseArrays, LinearAlgebra","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and the corresponding struct to store our material properties.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"struct NeoHooke\n    μ::Float64\n    λ::Float64\nend","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We then create a function to generate a simple test mesh on which to compute FE solution. We also mark the boundaries to later assign Dirichlet boundary conditions","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function importTestGrid()\n    grid = generate_grid(Tetrahedron, (5, 5, 5), zero(Vec{3}), ones(Vec{3}));\n    addfaceset!(grid, \"myBottom\", x -> norm(x[2]) ≈ 0.0);\n    addfaceset!(grid, \"myBack\", x -> norm(x[3]) ≈ 0.0);\n    addfaceset!(grid, \"myRight\", x -> norm(x[1]) ≈ 1.0);\n    addfaceset!(grid, \"myLeft\", x -> norm(x[1]) ≈ 0.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The function to create corresponding cellvalues for the displacement field u and pressure p follows in a similar fashion from the incompressible_elasticity example","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(4)\n    face_qr = QuadratureRule{2,RefTetrahedron}(4)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We now create the function for Ψ*","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function Ψ(F, p, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(tdot(F))\n    J = det(F)\n    Js = (λ + p + sqrt((λ + p)^2. + 4. * λ * μ ))/(2. * λ)\n    return p * (Js - J) + μ / 2 * (Ic - 3) - μ * log(Js) + λ / 2 * (Js - 1)^2\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and it's derivatives (required in computing the jacobian and hessian respectively)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function constitutive_driver(F, p, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂F², ∂Ψ∂F = Tensors.hessian(y -> Ψ(y, p, mp), F, :all)\n    ∂²Ψ∂p², ∂Ψ∂p = Tensors.hessian(y -> Ψ(F, y, mp), p, :all)\n    ∂²Ψ∂F∂p = Tensors.gradient(q -> Tensors.gradient(y -> Ψ(y, q, mp), F), p)\n    return ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The functions to create the DofHandler and ConstraintHandler (to assign corresponding boundary conditions) follow likewise from the incompressible elasticity example, namely","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 3, ipu) # displacement dim = 3\n    push!(dh, :p, 1, ipp) # pressure dim = 1\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We are simulating a uniaxial tensile loading of a unit cube. Hence we apply a displacement field (:u) in x direction on the right face. The left, bottom and back faces are fixed in the x, y and z components of the displacement so as to emulate the uniaxial nature of the loading.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myLeft\"), (x,t) -> zero(Vec{1}), [1]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBottom\"), (x,t) -> zero(Vec{1}), [2]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBack\"), (x,t) -> zero(Vec{1}), [3]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myRight\"), (x,t) -> t*ones(Vec{1}), [1]))\n    close!(dbc)\n    Ferrite.update!(dbc, 0.0)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Also, since we are considering incompressible hyperelasticity, an interesting quantity that we can compute is the deformed volume of the solid. It is easy to show that this is equal to ∫J*dΩ where J=det(F). This can be done at the level of each element (cell)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function calculate_element_volume(cell, cellvalues_u, ue)\n    reinit!(cellvalues_u, cell)\n    evol::Float64=0.0;\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        F = one(∇u) + ∇u\n        J = det(F)\n        evol += J * dΩ\n    end\n    return evol\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and then assembled over all the cells (elements)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function calculate_volume_deformed_mesh(w, dh::DofHandler, cellvalues_u)\n    evol::Float64 = 0.0;\n    @inbounds for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        nu = getnbasefunctions(cellvalues_u)\n        global_dofs_u = global_dofs[1:nu]\n        ue = w[global_dofs_u]\n        δevol = calculate_element_volume(cell, cellvalues_u, ue)\n        evol += δevol;\n    end\n    return evol\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The function to assemble the element stiffness matrix for each element in the mesh now has a block structure like in incompressible_elasticity.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function assemble_element!(Ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n    # Reinitialize cell values, and reset output arrays\n    ublock, pblock = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n    fill!(Ke, 0.0)\n    fill!(fe, 0.0)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        # Compute deformation gradient F\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        p = function_value(cellvalues_p, qp, pe)\n        F = one(∇u) + ∇u\n\n        # Compute first Piola-Kirchhoff stress and tangent modulus\n        ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p = constitutive_driver(F, p, mp)\n\n        # Loop over the `u`-test functions to calculate the `u`-`u` and `u`-`p` blocks\n        for i in 1:n_basefuncs_u\n            # gradient of the test function\n            ∇δui = shape_gradient(cellvalues_u, qp, i)\n            # Add contribution to the residual from this test function\n            fe[BlockIndex((ublock), (i))] += ( ∇δui ⊡ ∂Ψ∂F) * dΩ\n\n            ∇δui∂S∂F = ∇δui ⊡ ∂²Ψ∂F²\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, ublock), (i, j))] += ( ∇δui∂S∂F ⊡ ∇δuj ) * dΩ\n            end\n            # Loop over the `p`-test functions\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, pblock), (i, j))] += ( ∂²Ψ∂F∂p ⊡ ∇δui ) * δp * dΩ\n            end\n        end\n        # Loop over the `p`-test functions to calculate the `p-`u` and `p`-`p` blocks\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, qp, i)\n            fe[BlockIndex((pblock), (i))] += ( δp * ∂Ψ∂p) * dΩ\n\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n                Ke[BlockIndex((pblock, ublock), (i, j))] += ∇δuj ⊡ ∂²Ψ∂F∂p * δp * dΩ\n            end\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                Ke[BlockIndex((pblock, pblock), (i, j))] += δp * ∂²Ψ∂p² * δp * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The only thing that changes in the assembly of the global stiffness matrix is slicing the corresponding element dofs for the displacement (see global_dofsu) and pressure (global_dofsp).","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function assemble_global!(K::SparseMatrixCSC, f, cellvalues_u::CellVectorValues{dim},\n                         cellvalues_p::CellScalarValues{dim}, dh::DofHandler, mp::NeoHooke, w) where {dim}\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    # start_assemble resets K and f\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    assembler = start_assemble(K, f)\n    # Loop over all cells in the grid\n    for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        global_dofsu = global_dofs[1:nu]; # first nu dofs are displacement\n        global_dofsp = global_dofs[nu + 1:end]; # last np dofs are pressure\n        @assert size(global_dofs, 1) == nu + np # sanity check\n        ue = w[global_dofsu] # displacement dofs for the current cell\n        pe = w[global_dofsp] # pressure dofs for the current cell\n        assemble_element!(ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n        assemble!(assembler, global_dofs, fe, ke)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We now define a main function solve. For nonlinear quasistatic problems we often like to parameterize the solution in terms of a pseudo time like parameter, which in this case is used to gradually apply the boundary displacement on the right face. Also for definitenessm we consider λ/μ = 10⁴","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function solve(interpolation_u, interpolation_p)\n\n    # import the mesh\n    grid = importTestGrid()\n\n    # Material parameters\n    μ = 1.\n    λ = 1.E4 * μ\n    mp = NeoHooke(μ, λ)\n\n    # Create the DofHandler and CellValues\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # Create the DirichletBCs\n    dbc = create_bc(dh)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    w  = zeros(_ndofs)\n    ΔΔw = zeros(_ndofs)\n    apply!(w, dbc)\n\n    # Create the sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    f = zeros(_ndofs)\n\n    # We run the simulation parameterized by a time like parameter. `Tf` denotes the final value\n    # of this parameter, and Δt denotes its increment in each step\n    Tf = 2.0;\n    Δt = 0.1;\n    NEWTON_TOL = 1e-8\n\n    pvd = paraview_collection(\"hyperelasticity_incomp_mixed.pvd\");\n    for t ∈ 0.0:Δt:Tf\n        # Perform Newton iterations\n        Ferrite.update!(dbc, t)\n        apply!(w, dbc)\n        newton_itr = -1\n        prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving @ time $t of $Tf;\")\n        fill!(ΔΔw, 0.0);\n        while true; newton_itr += 1\n            assemble_global!(K, f, cellvalues_u, cellvalues_p, dh, mp, w)\n            norm_res = norm(f[Ferrite.free_dofs(dbc)])\n            apply_zero!(K, f, dbc)\n            # Only display output at specific load steps\n            if t%(5*Δt) == 0\n                ProgressMeter.update!(prog, norm_res; showvalues = [(:iter, newton_itr)])\n            end\n            if norm_res < NEWTON_TOL\n                break\n            elseif newton_itr > 30\n                error(\"Reached maximum Newton iterations, aborting\")\n            end\n            # Compute the incremental `dof`-vector (both displacement and pressure)\n            ΔΔw .= K\\f;\n\n            apply_zero!(ΔΔw, dbc)\n            w .-= ΔΔw\n        end;\n\n        # Save the solution fields\n        vtk_grid(\"hyperelasticity_incomp_mixed_$t.vtu\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, w)\n            vtk_save(vtkfile)\n            pvd[t] = vtkfile\n        end\n    end;\n    vtk_save(pvd);\n    vol_def = calculate_volume_deformed_mesh(w, dh, cellvalues_u);\n    print(\"Deformed volume is $vol_def\")\n    return vol_def;\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We can now test the solution using the Taylor-Hood approximation","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"quadratic = Lagrange{3, RefTetrahedron, 2}()\nlinear = Lagrange{3, RefTetrahedron, 1}()\nvol_def = solve(quadratic, linear)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The deformed volume is indeed close to 1 (as should be for a nearly incompressible material).","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Plain-program","page":"Nearly Incompressible Hyperelasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Here follows a version of the program without any comments. The file is also available here: quasi_incompressible_hyperelasticity.jl.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"using Ferrite, Tensors, ProgressMeter\nusing BlockArrays, SparseArrays, LinearAlgebra\n\nstruct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction importTestGrid()\n    grid = generate_grid(Tetrahedron, (5, 5, 5), zero(Vec{3}), ones(Vec{3}));\n    addfaceset!(grid, \"myBottom\", x -> norm(x[2]) ≈ 0.0);\n    addfaceset!(grid, \"myBack\", x -> norm(x[3]) ≈ 0.0);\n    addfaceset!(grid, \"myRight\", x -> norm(x[1]) ≈ 1.0);\n    addfaceset!(grid, \"myLeft\", x -> norm(x[1]) ≈ 0.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(4)\n    face_qr = QuadratureRule{2,RefTetrahedron}(4)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction Ψ(F, p, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(tdot(F))\n    J = det(F)\n    Js = (λ + p + sqrt((λ + p)^2. + 4. * λ * μ ))/(2. * λ)\n    return p * (Js - J) + μ / 2 * (Ic - 3) - μ * log(Js) + λ / 2 * (Js - 1)^2\nend;\n\nfunction constitutive_driver(F, p, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂F², ∂Ψ∂F = Tensors.hessian(y -> Ψ(y, p, mp), F, :all)\n    ∂²Ψ∂p², ∂Ψ∂p = Tensors.hessian(y -> Ψ(F, y, mp), p, :all)\n    ∂²Ψ∂F∂p = Tensors.gradient(q -> Tensors.gradient(y -> Ψ(y, q, mp), F), p)\n    return ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 3, ipu) # displacement dim = 3\n    push!(dh, :p, 1, ipp) # pressure dim = 1\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myLeft\"), (x,t) -> zero(Vec{1}), [1]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBottom\"), (x,t) -> zero(Vec{1}), [2]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBack\"), (x,t) -> zero(Vec{1}), [3]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myRight\"), (x,t) -> t*ones(Vec{1}), [1]))\n    close!(dbc)\n    Ferrite.update!(dbc, 0.0)\n    return dbc\nend;\n\nfunction calculate_element_volume(cell, cellvalues_u, ue)\n    reinit!(cellvalues_u, cell)\n    evol::Float64=0.0;\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        F = one(∇u) + ∇u\n        J = det(F)\n        evol += J * dΩ\n    end\n    return evol\nend;\n\nfunction calculate_volume_deformed_mesh(w, dh::DofHandler, cellvalues_u)\n    evol::Float64 = 0.0;\n    @inbounds for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        nu = getnbasefunctions(cellvalues_u)\n        global_dofs_u = global_dofs[1:nu]\n        ue = w[global_dofs_u]\n        δevol = calculate_element_volume(cell, cellvalues_u, ue)\n        evol += δevol;\n    end\n    return evol\nend;\n\nfunction assemble_element!(Ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n    # Reinitialize cell values, and reset output arrays\n    ublock, pblock = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n    fill!(Ke, 0.0)\n    fill!(fe, 0.0)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        # Compute deformation gradient F\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        p = function_value(cellvalues_p, qp, pe)\n        F = one(∇u) + ∇u\n\n        # Compute first Piola-Kirchhoff stress and tangent modulus\n        ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p = constitutive_driver(F, p, mp)\n\n        # Loop over the `u`-test functions to calculate the `u`-`u` and `u`-`p` blocks\n        for i in 1:n_basefuncs_u\n            # gradient of the test function\n            ∇δui = shape_gradient(cellvalues_u, qp, i)\n            # Add contribution to the residual from this test function\n            fe[BlockIndex((ublock), (i))] += ( ∇δui ⊡ ∂Ψ∂F) * dΩ\n\n            ∇δui∂S∂F = ∇δui ⊡ ∂²Ψ∂F²\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, ublock), (i, j))] += ( ∇δui∂S∂F ⊡ ∇δuj ) * dΩ\n            end\n            # Loop over the `p`-test functions\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, pblock), (i, j))] += ( ∂²Ψ∂F∂p ⊡ ∇δui ) * δp * dΩ\n            end\n        end\n        # Loop over the `p`-test functions to calculate the `p-`u` and `p`-`p` blocks\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, qp, i)\n            fe[BlockIndex((pblock), (i))] += ( δp * ∂Ψ∂p) * dΩ\n\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n                Ke[BlockIndex((pblock, ublock), (i, j))] += ∇δuj ⊡ ∂²Ψ∂F∂p * δp * dΩ\n            end\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                Ke[BlockIndex((pblock, pblock), (i, j))] += δp * ∂²Ψ∂p² * δp * dΩ\n            end\n        end\n    end\nend;\n\nfunction assemble_global!(K::SparseMatrixCSC, f, cellvalues_u::CellVectorValues{dim},\n                         cellvalues_p::CellScalarValues{dim}, dh::DofHandler, mp::NeoHooke, w) where {dim}\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    # start_assemble resets K and f\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    assembler = start_assemble(K, f)\n    # Loop over all cells in the grid\n    for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        global_dofsu = global_dofs[1:nu]; # first nu dofs are displacement\n        global_dofsp = global_dofs[nu + 1:end]; # last np dofs are pressure\n        @assert size(global_dofs, 1) == nu + np # sanity check\n        ue = w[global_dofsu] # displacement dofs for the current cell\n        pe = w[global_dofsp] # pressure dofs for the current cell\n        assemble_element!(ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n        assemble!(assembler, global_dofs, fe, ke)\n    end\nend;\n\nfunction solve(interpolation_u, interpolation_p)\n\n    # import the mesh\n    grid = importTestGrid()\n\n    # Material parameters\n    μ = 1.\n    λ = 1.E4 * μ\n    mp = NeoHooke(μ, λ)\n\n    # Create the DofHandler and CellValues\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # Create the DirichletBCs\n    dbc = create_bc(dh)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    w  = zeros(_ndofs)\n    ΔΔw = zeros(_ndofs)\n    apply!(w, dbc)\n\n    # Create the sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    f = zeros(_ndofs)\n\n    # We run the simulation parameterized by a time like parameter. `Tf` denotes the final value\n    # of this parameter, and Δt denotes its increment in each step\n    Tf = 2.0;\n    Δt = 0.1;\n    NEWTON_TOL = 1e-8\n\n    pvd = paraview_collection(\"hyperelasticity_incomp_mixed.pvd\");\n    for t ∈ 0.0:Δt:Tf\n        # Perform Newton iterations\n        Ferrite.update!(dbc, t)\n        apply!(w, dbc)\n        newton_itr = -1\n        prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving @ time $t of $Tf;\")\n        fill!(ΔΔw, 0.0);\n        while true; newton_itr += 1\n            assemble_global!(K, f, cellvalues_u, cellvalues_p, dh, mp, w)\n            norm_res = norm(f[Ferrite.free_dofs(dbc)])\n            apply_zero!(K, f, dbc)\n            # Only display output at specific load steps\n            if t%(5*Δt) == 0\n                ProgressMeter.update!(prog, norm_res; showvalues = [(:iter, newton_itr)])\n            end\n            if norm_res < NEWTON_TOL\n                break\n            elseif newton_itr > 30\n                error(\"Reached maximum Newton iterations, aborting\")\n            end\n            # Compute the incremental `dof`-vector (both displacement and pressure)\n            ΔΔw .= K\\f;\n\n            apply_zero!(ΔΔw, dbc)\n            w .-= ΔΔw\n        end;\n\n        # Save the solution fields\n        vtk_grid(\"hyperelasticity_incomp_mixed_$t.vtu\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, w)\n            vtk_save(vtkfile)\n            pvd[t] = vtkfile\n        end\n    end;\n    vtk_save(pvd);\n    vol_def = calculate_volume_deformed_mesh(w, dh, cellvalues_u);\n    print(\"Deformed volume is $vol_def\")\n    return vol_def;\nend;\n\nquadratic = Lagrange{3, RefTetrahedron, 2}()\nlinear = Lagrange{3, RefTetrahedron, 1}()\nvol_def = solve(quadratic, linear)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"This page was generated using Literate.jl.","category":"page"}]
}
