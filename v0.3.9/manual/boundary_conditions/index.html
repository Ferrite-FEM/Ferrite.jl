<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Conditions · Ferrite.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../fe_intro/">Introduction to FEM</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li class="is-active"><a class="tocitem" href>Boundary Conditions</a><ul class="internal"><li><a class="tocitem" href="#Dirichlet-Boundary-Conditions"><span>Dirichlet Boundary Conditions</span></a></li><li><a class="tocitem" href="#Neumann-Boundary-Conditions"><span>Neumann Boundary Conditions</span></a></li><li><a class="tocitem" href="#Periodic-boundary-conditions"><span>Periodic boundary conditions</span></a></li></ul></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../export/">Export</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/heat_equation/">Heat Equation</a></li><li><a class="tocitem" href="../../examples/postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../../examples/helmholtz/">Helmholtz equation</a></li><li><a class="tocitem" href="../../examples/incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="tocitem" href="../../examples/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../examples/threaded_assembly/">Threaded Assembly</a></li><li><a class="tocitem" href="../../examples/plasticity/">von Mises plasticity</a></li><li><a class="tocitem" href="../../examples/transient_heat_equation/">Time Dependent Problems</a></li><li><a class="tocitem" href="../../examples/landau/">Ginzburg-Landau model energy minimization</a></li><li><a class="tocitem" href="../../examples/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../examples/quasi_incompressible_hyperelasticity/">Nearly Incompressible Hyperelasticity</a></li><li><a class="tocitem" href="../../examples/ns_vs_diffeq/">Incompressible Navier-Stokes Equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../examples/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../examples/stokes-flow/">Stokes flow</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Boundary Conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Conditions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/manual/boundary_conditions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h1><p>Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it <code>Ferrite</code>.</p><h2 id="Dirichlet-Boundary-Conditions"><a class="docs-heading-anchor" href="#Dirichlet-Boundary-Conditions">Dirichlet Boundary Conditions</a><a id="Dirichlet-Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-Boundary-Conditions" title="Permalink"></a></h2><p>At a Dirichlet boundary the unknown field is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To handle Dirichlet boundary conditions in Ferrite we use the <a href="../../reference/boundary_conditions/#Ferrite.ConstraintHandler"><code>ConstraintHandler</code></a>. A constraint handler is created from a DoF handler:</p><pre><code class="language-julia hljs">ch = ConstraintHandler(dh)</code></pre><p>We can now create Dirichlet constraints and add them to the constraint handler. To create a Dirichlet constraint we need to specify a field name, a part of the boundary, and a function for computing the prescribed value. Example:</p><pre><code class="language-julia hljs">dbc1 = Dirichlet(
    :u,                       # Name of the field
    getfaceset(grid, &quot;left&quot;), # Part of the boundary
    (x, t) -&gt; 1.0 * t,        # Function mapping coordinate and time to a prescribed value
)</code></pre><p>The field name is given as a symbol, just like when the field was added to the dof handler, the part of the boundary where this constraint is active is given as a face set, and the function computing the prescribed value should accept two input arguments (coordinate <code>x</code> and time <code>t</code>) and return the prescribed value.</p><div class="admonition is-info"><header class="admonition-header">Multiple sets</header><div class="admonition-body"><p>To apply a constraint on multiple face sets in the grid you can use <code>union</code> to join them, for example</p><pre><code class="language-julia hljs">left_right = union(getfaceset(grid, &quot;left&quot;), getfaceset(grid, &quot;right&quot;))</code></pre><p>creates a new face set containing all faces in the <code>&quot;left&quot;</code> and &quot;<code>right</code>&quot; face sets, which can be passed to the <code>Dirichlet</code> constructor.</p></div></div><p>By default the constraint is added to the first component of the given field. To add the constraint to multiple components a fourth argument with the components should be passed to the constructor. Here is an example where a constraint is added to component 1 and 3 of a vector field <code>:u</code>:</p><pre><code class="language-julia hljs">dbc2 = Dirichlet(
    :u,                       # Name of the field
    getfaceset(grid, &quot;left&quot;), # Part of the boundary
    (x, t) -&gt; [0.0, 0.0],     # Function mapping coordinate and time to a prescribed value
    [1, 3],                   # Components
)</code></pre><p>Note that the return value of the function must match with the components – in the example above we prescibe components 1 and 3 to 0 so we return a vector of length 2.</p><p>Adding the constraints to the constraint handler is done with <a href="../../reference/boundary_conditions/#Ferrite.add!"><code>add!</code></a>:</p><pre><code class="language-julia hljs">add!(ch, dbc1)
add!(ch, dbc2)</code></pre><p>Finally, just like for the dof handler, we need to use <a href="../../reference/boundary_conditions/#Ferrite.close!"><code>close!</code></a> to finalize the constraint handler. Internally this will then compute the degrees-of-freedom that match the constraints we added.</p><p>Since the constraints can in general depend on time we also need to need to call <a href="manual/@ref"><code>update!</code></a> with the current time in order to compute the prescribed values. The same constraint handler can then be used for all time steps by calling <code>update!</code> with the proper time, e.g.:</p><pre><code class="language-julia hljs">for t in 0.0:0.1:1.0
    update!(ch, t) # Compute prescribed values for this t
    # Solve for time t...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You <em>must</em> call <code>update!</code>, even if your constraints does not depend on time (as <code>dbc2</code> above), e.g. <code>update!(ch, 0.0)</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>Most examples make use of Dirichlet boundary conditions, for example <a href="../../examples/heat_equation/#Heat-Equation">Heat Equation</a>.</p></div></div><h2 id="Neumann-Boundary-Conditions"><a class="docs-heading-anchor" href="#Neumann-Boundary-Conditions">Neumann Boundary Conditions</a><a id="Neumann-Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Neumann-Boundary-Conditions" title="Permalink"></a></h2><p>At the Neumann part of the boundary we know something about the gradient of the solution.</p><p>As an example, the following code snippet can be included in the element routine, to evaluate the boundary integral:</p><pre><code class="language-julia hljs">for face in 1:nfaces(cell)
    if (cellid(cell), face) ∈ getfaceset(grid, &quot;Neumann Boundary&quot;)
        reinit!(facevalues, cell, face)
        for q_point in 1:getnquadpoints(facevalues)
            dΓ = getdetJdV(facevalues, q_point)
            for i in 1:getnbasefunctions(facevalues)
                δu = shape_value(facevalues, q_point, i)
                fe[i] += δu * b * dΓ
            end
        end
    end
end</code></pre><p>We start by looping over all the faces of the cell, next we check if this particular face is located on our faceset of interest called <code>&quot;Neumann Boundary&quot;</code>. If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize <code>facevalues</code> for this face, using <a href="../../reference/fevalues/#Ferrite.reinit!"><code>reinit!</code></a>. When <code>reinit!</code>ing <code>facevalues</code> we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.</p><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>The following commented examples makes use of Neumann boundary conditions:</p><ul><li>TODO</li></ul></div></div><h2 id="Periodic-boundary-conditions"><a class="docs-heading-anchor" href="#Periodic-boundary-conditions">Periodic boundary conditions</a><a id="Periodic-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-boundary-conditions" title="Permalink"></a></h2><p>Periodic boundary conditions ensure that the solution is periodic across two boundaries. To define the periodicity we first define the image boundary <span>$\Gamma^+$</span> and the mirror boundary <span>$\Gamma^-$</span>. We also define a (unique) coordinate mapping between the image and the mirror: <span>$\varphi:\ \Gamma^+\, \rightarrow\, \Gamma^-$</span>. With the mapping we can, for every coordinate on the image, compute the corresponding coordinate on the mirror:</p><p class="math-container">\[\boldsymbol{x}^- = \varphi(\boldsymbol{x}^+),\quad \boldsymbol{x}^- \in \Gamma^-,\,
\boldsymbol{x}^+ \in \Gamma^+.\]</p><p>We now want to ensure that the solution on the image <span>$\Gamma^+$</span> is mirrored on the mirror <span>$\Gamma^-$</span>. This periodicity constraint can thus be described by</p><p class="math-container">\[u(\boldsymbol{x}^-) = u(\boldsymbol{x}^+).\]</p><p>Sometimes this is written as</p><p class="math-container">\[\llbracket u \rrbracket = 0,\]</p><p>where <span>$\llbracket \bullet \rrbracket := \bullet(\boldsymbol{x}^+) - \bullet(\boldsymbol{x}^-)$</span> is the &quot;jump operator&quot;. Thus, this condition ensure that the jump, or difference, in the solution between the image and mirror boundary is the zero – the solution becomes periodic. For a vector valued problem the periodicity constraint can in general be written as</p><p class="math-container">\[\boldsymbol{u}(\boldsymbol{x}^-) = \boldsymbol{R} \cdot \boldsymbol{u}(\boldsymbol{x}^+)
\quad \Leftrightarrow \quad \llbracket \boldsymbol{u} \rrbracket =
\boldsymbol{R} \cdot \boldsymbol{u}(\boldsymbol{x}^+) - \boldsymbol{u}(\boldsymbol{x}^-) =
\boldsymbol{0}\]</p><p>where <span>$\boldsymbol{R}$</span> is a rotation matrix. If the mapping between mirror and image is simply a translation (e.g. sides of a cube) this matrix will be the identity matrix.</p><p>In <code>Ferrite</code> this type of periodic Dirichlet boundary conditions can be added to the <code>ConstraintHandler</code> by constructing an instance of <a href="../../reference/boundary_conditions/#Ferrite.PeriodicDirichlet"><code>PeriodicDirichlet</code></a>. This is usually done it two steps. First we compute the mapping between mirror and image faces using <a href="../../reference/boundary_conditions/#Ferrite.collect_periodic_faces"><code>collect_periodic_faces</code></a>. Here we specify the mirror set and image sets (the sets are usually known or can be constructed easily ) and the mapping <span>$\varphi$</span>. Second we construct the constraint using the <code>PeriodicDirichlet</code> constructor. Here we specify which components of the function that should be constrained, and the rotation matrix <span>$\boldsymbol{R}$</span> (when needed). When adding the constraint to the <code>ConstraintHandler</code> the resulting dof-mapping is computed.</p><p>Here is a simple example where periodicity is enforced for components 1 and 2 of the field <code>:u</code> between the mirror boundary set <code>&quot;left&quot;</code> and the image boundary set <code>&quot;right&quot;</code>. Note that no rotation matrix is needed here since the mirror and image are parallel, just shifted in the <span>$x$</span>-direction (as seen by the mapping <code>φ</code>):</p><pre><code class="language-julia hljs"># Create a constraint handler from the dof handler
ch = ConstraintHandler(dofhandler)

# Compute the face mapping
φ(x) = x - Vec{2}((1.0, 0.0))
face_mapping = collect_periodic_faces(grid, &quot;left&quot;, &quot;right&quot;, φ)

# Construct the periodic constraint for field :u
pdbc = PeriodicDirichlet(:u, face_mapping, [1, 2])

# Add the constraint to the constraint handler
add!(ch, pdbc)

# If no more constraints should be added we can close
close!(ch)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>PeriodicDirichlet</code> constraints are imposed in a strong sense, so note that this requires a periodic mesh such that it is possible to compute the face mapping between faces on the mirror and boundary.</p></div></div><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>Periodic boundary conditions are used in the following examples <a href="../../examples/computational_homogenization/#Computational-homogenization">Computational homogenization</a>, <a href="../../examples/stokes-flow/#Stokes-flow">Stokes flow</a>.</p></div></div><h4 id="Heterogeneous-&quot;periodic&quot;-constraint"><a class="docs-heading-anchor" href="#Heterogeneous-&quot;periodic&quot;-constraint">Heterogeneous &quot;periodic&quot; constraint</a><a id="Heterogeneous-&quot;periodic&quot;-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Heterogeneous-&quot;periodic&quot;-constraint" title="Permalink"></a></h4><p>It is also possible to define constraints of the form</p><p class="math-container">\[\llbracket u \rrbracket = \llbracket f \rrbracket
\quad \Leftrightarrow \quad
u(\boldsymbol{x}^+) - u(\boldsymbol{x}^-) =
f(\boldsymbol{x}^+) - f(\boldsymbol{x}^-),\]</p><p>where <span>$f$</span> is a prescribed function. Although the constraint in this case is not technically periodic, <code>PeriodicDirichlet</code> can be used for this too. This is done by passing a function to <code>PeriodicDirichlet</code>, similar to <code>Dirichlet</code>, which, given the coordinate <span>$\boldsymbol{x}$</span> and time <code>t</code>, computes the prescribed values of <span>$f$</span> on the boundary.</p><p>Here is an example of how to implement this type of boundary condition, for a known function <code>f</code>:</p><pre><code class="language-julia hljs">pdbc = PeriodicDirichlet(
    :u,
    face_mapping,
    (x, t) -&gt; f(x),
    [1, 2],
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One application for this type of boundary conditions is multiscale modeling and computational homogenization when solving the finite element problem for the subscale. In this case the unknown <span>$u$</span> is split into a macroscopic part <span>$u^{\mathrm{M}}$</span> and a microscopic/fluctuation part <span>$u^\mu$</span>, i.e. <span>$u = u^{\mathrm{M}} + u^{\mu}$</span>. Periodicity is then usually enforced for the fluctuation part, i.e. <span>$\llbracket u^\mu \rrbracket = 0$</span>. The equivalent constraint for <span>$u$</span> then becomes <span>$\llbracket u \rrbracket = \llbracket u^{\mathrm{M}} \rrbracket$</span>.</p><p>As an example, consider first order homogenization where the macroscopic part is constructed as <span>$u^{\mathrm{M}} = \bar{u} + \boldsymbol{\nabla} \bar{u} \cdot [\boldsymbol{x} - \bar{\boldsymbol{x}}]$</span> for known <span>$\bar{u}$</span> and <span>$\boldsymbol{\nabla} \bar{u}$</span>. This could be implemented as</p><pre><code class="language-julia hljs">pdbc = PeriodicDirichlet(
    :u,
    face_mapping,
    (x, t) -&gt; ū + ∇ū  ⋅ (x - x̄)
)</code></pre></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../assembly/">« Assembly</a><a class="docs-footer-nextpage" href="../constraints/">Constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 20 October 2022 12:52">Thursday 20 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
