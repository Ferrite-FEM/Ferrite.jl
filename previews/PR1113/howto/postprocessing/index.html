<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Post processing and visualization · Ferrite.jl</title><meta name="title" content="Post processing and visualization · Ferrite.jl"/><meta property="og:title" content="Post processing and visualization · Ferrite.jl"/><meta property="twitter:title" content="Post processing and visualization · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/howto/postprocessing/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/howto/postprocessing/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/howto/postprocessing/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Tutorials overview</a></li><li><a class="tocitem" href="../../tutorials/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../tutorials/linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../../tutorials/incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../../tutorials/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../tutorials/plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../../tutorials/transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../../tutorials/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../tutorials/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../tutorials/porous_media/">Porous media</a></li><li><a class="tocitem" href="../../tutorials/ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/reactive_surface/">Reactive surface</a></li><li><a class="tocitem" href="../../tutorials/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../tutorials/dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Topic guide overview</a></li><li><a class="tocitem" href="../../topics/fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../../topics/reference_shapes/">Reference shapes</a></li><li><a class="tocitem" href="../../topics/FEValues/">FEValues</a></li><li><a class="tocitem" href="../../topics/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../topics/sparse_matrix/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../topics/assembly/">Assembly</a></li><li><a class="tocitem" href="../../topics/boundary_conditions/">Boundary and initial conditions</a></li><li><a class="tocitem" href="../../topics/constraints/">Constraints</a></li><li><a class="tocitem" href="../../topics/grid/">Grid</a></li><li><a class="tocitem" href="../../topics/export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/sparsity_pattern/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">How-to guide overview</a></li><li class="is-active"><a class="tocitem" href>Post processing and visualization</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Exporting-to-VTK"><span>Exporting to VTK</span></a></li><li><a class="tocitem" href="#Point-evaluation"><span>Point evaluation</span></a></li><li><a class="tocitem" href="#postprocessing-plain-program"><span>Plain program</span></a></li></ul></li><li><a class="tocitem" href="../threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../cited-literature/">Cited literature</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How-to guides</a></li><li class="is-active"><a href>Post processing and visualization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Post processing and visualization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate-howto/postprocessing.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="howto-postprocessing"><a class="docs-heading-anchor" href="#howto-postprocessing">Post processing and visualization</a><a id="howto-postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#howto-postprocessing" title="Permalink"></a></h1><p><img src="../heat_square_fluxes.png" alt/></p><p><em>Figure 1</em>: Heat flux computed from the solution to the heat equation on the unit square, see previous example: <a href="../../tutorials/heat_equation/#tutorial-heat-equation">Heat equation</a>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/Ferrite-FEM/Ferrite.jl/blob/gh-pages/previews/PR1113/howto/postprocessing.ipynb"><code>postprocessing.ipynb</code></a>.</p></div></div><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>After running a simulation, we usually want to visualize the results in different ways. The <code>L2Projector</code> and the <code>PointEvalHandler</code> build a pipeline for doing so. With the <code>L2Projector</code>, integration point quantities can be projected to the nodes. The <code>PointEvalHandler</code> enables evaluation of the finite element approximated function in any coordinate in the domain. Thus with the combination of both functionalities, both nodal quantities and integration point quantities can be evaluated in any coordinate, allowing for example cut-planes through 3D structures or cut-lines through 2D-structures.</p><p>This example continues from the Heat equation example, where the temperature field was determined on a square domain. In this example, we first compute the heat flux in each integration point (based on the solved temperature field) and then we do an L2-projection of the fluxes to the nodes of the mesh. By doing this, we can more easily visualize integration points quantities. Finally, we visualize the temperature field and the heat fluxes along a cut-line.</p><p>The L2-projection is defined as follows: Find projection <span>$q(\boldsymbol{x}) \in U_h(\Omega)$</span> such that</p><p class="math-container">\[\int v q \ \mathrm{d}\Omega = \int v d \ \mathrm{d}\Omega \quad \forall v \in U_h(\Omega),\]</p><p>where <span>$d$</span> is the quadrature data to project. Since the flux is a vector the projection function will be solved with multiple right hand sides, e.g. with <span>$d = q_x$</span> and <span>$d = q_y$</span> for this 2D problem. In this example, we use standard Lagrange interpolations, and the finite element space <span>$U_h$</span> is then a subset of the <span>$H^1$</span> space (continuous functions).</p><p>Ferrite has functionality for doing much of this automatically, as displayed in the code below. In particular <a href="../../reference/export/#Ferrite.L2Projector-Tuple{Ferrite.AbstractGrid}"><code>L2Projector</code></a> for assembling the left hand side, and <a href="../../reference/export/#Ferrite.project"><code>project</code></a> for assembling the right hand sides and solving for the projection.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>Start by simply running the Heat equation example to solve the problem</p><pre><code class="language-julia hljs">include(&quot;../tutorials/heat_equation.jl&quot;);</code></pre><p>Next we define a function that computes the heat flux for each integration point in the domain. Fourier&#39;s law is adopted, where the conductivity tensor is assumed to be isotropic with unit conductivity <span>$\lambda = 1 ⇒ q = - \nabla u$</span>, where <span>$u$</span> is the temperature.</p><pre><code class="language-julia hljs">function compute_heat_fluxes(cellvalues::CellValues, dh::DofHandler, a::AbstractVector{T}) where {T}

    n = getnbasefunctions(cellvalues)
    cell_dofs = zeros(Int, n)
    nqp = getnquadpoints(cellvalues)

    # Allocate storage for the fluxes to store
    q = [Vec{2, T}[] for _ in 1:getncells(dh.grid)]

    for (cell_num, cell) in enumerate(CellIterator(dh))
        q_cell = q[cell_num]
        celldofs!(cell_dofs, dh, cell_num)
        aᵉ = a[cell_dofs]
        reinit!(cellvalues, cell)

        for q_point in 1:nqp
            q_qp = - function_gradient(cellvalues, q_point, aᵉ)
            push!(q_cell, q_qp)
        end
    end
    return q
end</code></pre><p>Now call the function to get all the fluxes.</p><pre><code class="language-julia hljs">q_gp = compute_heat_fluxes(cellvalues, dh, u);</code></pre><p>Next, create an <a href="../../reference/export/#Ferrite.L2Projector-Tuple{Ferrite.AbstractGrid}"><code>L2Projector</code></a> using the same interpolation as was used to approximate the temperature field. On instantiation, the projector assembles the coefficient matrix <code>M</code> and computes the Cholesky factorization of it. By doing so, the projector can be reused without having to invert <code>M</code> every time.</p><pre><code class="language-julia hljs">projector = L2Projector(ip, grid);</code></pre><p>Project the integration point values to the nodal values</p><pre><code class="language-julia hljs">q_projected = project(projector, q_gp, qr);</code></pre><h2 id="Exporting-to-VTK"><a class="docs-heading-anchor" href="#Exporting-to-VTK">Exporting to VTK</a><a id="Exporting-to-VTK-1"></a><a class="docs-heading-anchor-permalink" href="#Exporting-to-VTK" title="Permalink"></a></h2><p>To visualize the heat flux, we export the projected field <code>q_projected</code> to a VTK-file, which can be viewed in e.g. <a href="https://www.paraview.org/">ParaView</a>. The result is also visualized in <em>Figure 1</em>.</p><pre><code class="language-julia hljs">VTKGridFile(&quot;heat_equation_flux&quot;, grid) do vtk
    write_projection(vtk, projector, q_projected, &quot;q&quot;)
end;</code></pre><h2 id="Point-evaluation"><a class="docs-heading-anchor" href="#Point-evaluation">Point evaluation</a><a id="Point-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Point-evaluation" title="Permalink"></a></h2><p><img src="../heat_square_pointevaluation.png" alt/></p><p><em>Figure 2</em>: Visualization of the cut line where we want to compute the temperature and heat flux.</p><p>Consider a cut-line through the domain like the black line in <em>Figure 2</em> above. We will evaluate the temperature and the heat flux distribution along a horizontal line.</p><pre><code class="language-julia hljs">points = [Vec((x, 0.75)) for x in range(-1.0, 1.0, length = 101)];</code></pre><p>First, we need to generate a <code>PointEvalHandler</code>. This will find and store the cells containing the input points.</p><pre><code class="language-julia hljs">ph = PointEvalHandler(grid, points);</code></pre><p>After the L2-Projection, the heat fluxes <code>q_projected</code> are stored in the DoF-ordering determined by the projector&#39;s internal DoFHandler, so to evaluate the flux <code>q</code> at our points we give the <code>PointEvalHandler</code>, the <code>L2Projector</code> and the values <code>q_projected</code>.</p><pre><code class="language-julia hljs">q_points = evaluate_at_points(ph, projector, q_projected);</code></pre><p>We can also extract the field values, here the temperature, right away from the result vector of the simulation, that is stored in <code>u</code>. These values are stored in the order of our initial DofHandler so the input is not the <code>PointEvalHandler</code>, the original <code>DofHandler</code>, the dof-vector <code>u</code>, and (optionally for single-field problems) the name of the field. From the <code>L2Projection</code>, the values are stored in the order of the degrees of freedom.</p><pre><code class="language-julia hljs">u_points = evaluate_at_points(ph, dh, u, :u);</code></pre><p>Now, we can plot the temperature and flux values with the help of any plotting library, e.g. Plots.jl. To do this, we need to import the package:</p><pre><code class="language-julia hljs">import Plots</code></pre><p>Firstly, we are going to plot the temperature values along the given line.</p><pre><code class="language-julia hljs">Plots.plot(getindex.(points, 1), u_points, xlabel = &quot;x (coordinate)&quot;, ylabel = &quot;u (temperature)&quot;, label = nothing)</code></pre><img src="8ead3fba.svg" alt="Example block output"/><p><em>Figure 3</em>: Temperature along the cut line from <em>Figure 2</em>.</p><p>Secondly, the horizontal heat flux (i.e. the first component of the heat flux vector) is plotted.</p><pre><code class="language-julia hljs">Plots.plot(getindex.(points, 1), getindex.(q_points, 1), xlabel = &quot;x (coordinate)&quot;, ylabel = &quot;q_x (flux in x-direction)&quot;, label = nothing)</code></pre><img src="ee920fc5.svg" alt="Example block output"/><p><em>Figure 4</em>: <span>$x$</span>-component of the flux along the cut line from <em>Figure 2</em>.</p><h2 id="postprocessing-plain-program"><a class="docs-heading-anchor" href="#postprocessing-plain-program">Plain program</a><a id="postprocessing-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#postprocessing-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../postprocessing.jl"><code>postprocessing.jl</code></a>.</p><pre><code class="language-julia hljs">include(&quot;../tutorials/heat_equation.jl&quot;);

function compute_heat_fluxes(cellvalues::CellValues, dh::DofHandler, a::AbstractVector{T}) where {T}

    n = getnbasefunctions(cellvalues)
    cell_dofs = zeros(Int, n)
    nqp = getnquadpoints(cellvalues)

    # Allocate storage for the fluxes to store
    q = [Vec{2, T}[] for _ in 1:getncells(dh.grid)]

    for (cell_num, cell) in enumerate(CellIterator(dh))
        q_cell = q[cell_num]
        celldofs!(cell_dofs, dh, cell_num)
        aᵉ = a[cell_dofs]
        reinit!(cellvalues, cell)

        for q_point in 1:nqp
            q_qp = - function_gradient(cellvalues, q_point, aᵉ)
            push!(q_cell, q_qp)
        end
    end
    return q
end

q_gp = compute_heat_fluxes(cellvalues, dh, u);

projector = L2Projector(ip, grid);

q_projected = project(projector, q_gp, qr);

VTKGridFile(&quot;heat_equation_flux&quot;, grid) do vtk
    write_projection(vtk, projector, q_projected, &quot;q&quot;)
end;

points = [Vec((x, 0.75)) for x in range(-1.0, 1.0, length = 101)];

ph = PointEvalHandler(grid, points);

q_points = evaluate_at_points(ph, projector, q_projected);

u_points = evaluate_at_points(ph, dh, u, :u);

import Plots

Plots.plot(getindex.(points, 1), u_points, xlabel = &quot;x (coordinate)&quot;, ylabel = &quot;u (temperature)&quot;, label = nothing)

Plots.plot(getindex.(points, 1), getindex.(q_points, 1), xlabel = &quot;x (coordinate)&quot;, ylabel = &quot;q_x (flux in x-direction)&quot;, label = nothing)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« How-to guide overview</a><a class="docs-footer-nextpage" href="../threaded_assembly/">Multi-threaded assembly »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 2 December 2024 12:15">Monday 2 December 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
