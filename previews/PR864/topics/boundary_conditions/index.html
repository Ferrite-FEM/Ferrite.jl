<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary and initial conditions · Ferrite.jl</title><meta name="title" content="Boundary and initial conditions · Ferrite.jl"/><meta property="og:title" content="Boundary and initial conditions · Ferrite.jl"/><meta property="twitter:title" content="Boundary and initial conditions · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/boundary_conditions/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/boundary_conditions/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/boundary_conditions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Tutorials overview</a></li><li><a class="tocitem" href="../../tutorials/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../tutorials/linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../../tutorials/incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../../tutorials/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../tutorials/plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../../tutorials/transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../../tutorials/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../tutorials/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../tutorials/porous_media/">Porous media</a></li><li><a class="tocitem" href="../../tutorials/ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/reactive_surface/">Reactive surface</a></li><li><a class="tocitem" href="../../tutorials/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../tutorials/dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Topic guide overview</a></li><li><a class="tocitem" href="../fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../reference_shapes/">Reference shapes</a></li><li><a class="tocitem" href="../FEValues/">FEValues</a></li><li><a class="tocitem" href="../degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../sparse_matrix/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li class="is-active"><a class="tocitem" href>Boundary and initial conditions</a><ul class="internal"><li><a class="tocitem" href="#Dirichlet-boundary-conditions"><span>Dirichlet boundary conditions</span></a></li><li><a class="tocitem" href="#Neumann-boundary-conditions"><span>Neumann boundary conditions</span></a></li><li><a class="tocitem" href="#Periodic-boundary-conditions"><span>Periodic boundary conditions</span></a></li><li><a class="tocitem" href="#Initial-conditions"><span>Initial conditions</span></a></li></ul></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/sparsity_pattern/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../cited-literature/">Cited literature</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Topic guides</a></li><li class="is-active"><a href>Boundary and initial conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary and initial conditions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/topics/boundary_conditions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-and-initial-conditions"><a class="docs-heading-anchor" href="#Boundary-and-initial-conditions">Boundary and initial conditions</a><a id="Boundary-and-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-and-initial-conditions" title="Permalink"></a></h1><p>Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it in Ferrite.</p><p>While boundary conditions can be applied directly to nodes, vertices, edges, or faces, they are most commonly applied to <a href="../reference_shapes/#Reference-shapes">facets</a>. Each facet is described by a <a href="../../reference/grid/#Ferrite.FacetIndex"><code>FacetIndex</code></a>. When adding boundary conditions to points instead, vertices are preferred over nodes.</p><h2 id="Dirichlet-boundary-conditions"><a class="docs-heading-anchor" href="#Dirichlet-boundary-conditions">Dirichlet boundary conditions</a><a id="Dirichlet-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-boundary-conditions" title="Permalink"></a></h2><p>At a Dirichlet boundary the unknown field is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To handle Dirichlet boundary conditions in Ferrite we use the <a href="../../reference/boundary_conditions/#Ferrite.ConstraintHandler"><code>ConstraintHandler</code></a>. A constraint handler is created from a DoF handler:</p><pre><code class="language-julia hljs">ch = ConstraintHandler(dh)</code></pre><p>We can now create Dirichlet constraints and add them to the constraint handler. To create a Dirichlet constraint we need to specify a field name, a part of the boundary, and a function for computing the prescribed value. Example:</p><pre><code class="language-julia hljs">dbc1 = Dirichlet(
    :u,                        # Name of the field
    getfacetset(grid, &quot;left&quot;), # Part of the boundary
    x -&gt; 1.0,                  # Function mapping coordinate to a prescribed value
)</code></pre><p>The field name is given as a symbol, just like when the field was added to the dof handler, the part of the boundary where this constraint is active is given as a facet set, and the function computing the prescribed value should be of the form <code>f(x)</code> or <code>f(x, t)</code> (coordinate <code>x</code> and time <code>t</code>) and return the prescribed value(s).</p><div class="admonition is-info"><header class="admonition-header">Multiple sets</header><div class="admonition-body"><p>To apply a constraint on multiple facet sets in the grid you can use <code>union</code> to join them, for example</p><pre><code class="language-julia hljs">left_right = union(getfacetset(grid, &quot;left&quot;), getfacetset(grid, &quot;right&quot;))</code></pre><p>creates a new facetset containing all facets in the <code>&quot;left&quot;</code> and &quot;<code>right</code>&quot; facetsets, which can be passed to the <code>Dirichlet</code> constructor.</p></div></div><p>By default the constraint is added to all components of the given field. To add the constraint to selected components a fourth argument with the components should be passed to the constructor. Here is an example where a constraint is added to component 1 and 3 of a vector field <code>:u</code>:</p><pre><code class="language-julia hljs">dbc2 = Dirichlet(
    :u,                        # Name of the field
    getfacetset(grid, &quot;left&quot;), # Part of the boundary
    x -&gt; [0.0, 0.0],           # Function mapping coordinate to prescribed values
    [1, 3],                    # Components
)</code></pre><p>Note that the return value of the function must match with the components – in the example above we prescribe components 1 and 3 to 0 so we return a vector of length 2.</p><p>Adding the constraints to the constraint handler is done with <a href="../../reference/boundary_conditions/#Ferrite.add!"><code>add!</code></a>:</p><pre><code class="language-julia hljs">add!(ch, dbc1)
add!(ch, dbc2)</code></pre><p>Finally, just like for the dof handler, we need to use <a href="../../reference/boundary_conditions/#Ferrite.close!"><code>close!</code></a> to finalize the constraint handler. Internally this will then compute the degrees-of-freedom that match the constraints we added.</p><p>If one or more of the constraints depend on time, i.e. they are specified as <code>f(x, t)</code>, the prescribed values can be recomputed in each new time step by calling <a href="../../reference/boundary_conditions/#Ferrite.update!"><code>update!</code></a> with the proper time, e.g.:</p><pre><code class="language-julia hljs">for t in 0.0:0.1:1.0
    update!(ch, t) # Compute prescribed values for this t
    # Solve for time t...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>Most examples make use of Dirichlet boundary conditions, for example <a href="../../tutorials/heat_equation/#tutorial-heat-equation">Heat Equation</a>.</p></div></div><h2 id="Neumann-boundary-conditions"><a class="docs-heading-anchor" href="#Neumann-boundary-conditions">Neumann boundary conditions</a><a id="Neumann-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Neumann-boundary-conditions" title="Permalink"></a></h2><p>At the Neumann part of the boundary we know something about the gradient of the solution. Two different methods for applying these are described below. For complete examples that use Neumann boundary conditions, please see</p><ul><li><a href="../../tutorials/plasticity/#tutorial-plasticity">von-Mises-plasticity</a></li><li><a href="../../tutorials/hyperelasticity/#tutorial-hyperelasticity">Hyperelasticity</a></li></ul><h3 id="Using-the-FacetIterator"><a class="docs-heading-anchor" href="#Using-the-FacetIterator">Using the <code>FacetIterator</code></a><a id="Using-the-FacetIterator-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-FacetIterator" title="Permalink"></a></h3><p>A Neumann boundary contribution can be added by iterating over the relevant <code>facetset</code> by using the <a href="../../reference/dofhandler/#Ferrite.FacetIterator"><code>FacetIterator</code></a>. For a scalar field, this can be done as</p><pre><code class="language-julia hljs">grid = generate_grid(Quadrilateral, (3,3))
dh = DofHandler(grid); push!(dh, :u, 1); close!(dh)
fv = FacetValues(QuadratureRule{RefQuadrilateral}(2), Lagrange{RefQuadrilateral, 1}())
f = zeros(ndofs(dh))
fe = zeros(ndofs_per_cell(dh))
qn = 1.0    # Normal flux
for fc in FacetIterator(dh, getfacetset(grid, &quot;right&quot;))
    reinit!(fv, fc)
    fill!(fe, 0)
    for q_point in 1:getnquadpoints(fv)
        dΓ = getdetJdV(fv, q_point)
        for i in 1:getnbasefunctions(fv)
            δu = shape_value(fv, q_point, i)
            fe[i] += δu * qn * dΓ
        end
    end
    assemble!(f, celldofs(fc), fe)
end</code></pre><p>Alternatively, it is possible to add the values directly to the global <code>f</code> (without going through the local <code>fe</code> vector and then using <code>assemble!</code>):</p><pre><code class="language-julia hljs"># ...
dofs = celldofs(fc)
for i in 1:getnbasefunctions(fv)
    f[dofs[i]] += δu * qn * dΓ
end</code></pre><h3 id="In-the-element-routine"><a class="docs-heading-anchor" href="#In-the-element-routine">In the element routine</a><a id="In-the-element-routine-1"></a><a class="docs-heading-anchor-permalink" href="#In-the-element-routine" title="Permalink"></a></h3><p>Alternatively, the following code snippet can be included in the element routine, to evaluate the boundary integral:</p><pre><code class="language-julia hljs">for facet in 1:nfacets(cell)
    if (cellid(cell), facet) ∈ getfacetset(grid, &quot;Neumann Boundary&quot;)
        reinit!(facetvalues, cell, facet)
        for q_point in 1:getnquadpoints(facetvalues)
            dΓ = getdetJdV(facetvalues, q_point)
            for i in 1:getnbasefunctions(facetvalues)
                δu = shape_value(facetvalues, q_point, i)
                fe[i] += δu * qn * dΓ
            end
        end
    end
end</code></pre><p>We start by looping over all the facets of the cell, next we check if this particular facet is located on our facetset of interest called <code>&quot;Neumann Boundary&quot;</code>. If we have determined that the current facet is indeed on the boundary and in our facetset, then we reinitialize <code>FacetValues</code> for this facet, using <a href="../../reference/fevalues/#Ferrite.reinit!"><code>reinit!</code></a>. When <code>reinit!</code>ing <code>FacetValues</code> we also need to give the facet number in addition to the cell. Next we simply loop over the quadrature points of the facet, and then loop over all the test functions and assemble the contribution to the force vector.</p><h2 id="Periodic-boundary-conditions"><a class="docs-heading-anchor" href="#Periodic-boundary-conditions">Periodic boundary conditions</a><a id="Periodic-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-boundary-conditions" title="Permalink"></a></h2><p>Periodic boundary conditions ensure that the solution is periodic across two boundaries. To define the periodicity we first define the image boundary <span>$\Gamma^+$</span> and the mirror boundary <span>$\Gamma^-$</span>. We also define a (unique) coordinate mapping between the image and the mirror: <span>$\varphi:\ \Gamma^+\, \rightarrow\, \Gamma^-$</span>. With the mapping we can, for every coordinate on the image, compute the corresponding coordinate on the mirror:</p><p class="math-container">\[\boldsymbol{x}^- = \varphi(\boldsymbol{x}^+),\quad \boldsymbol{x}^- \in \Gamma^-,\,
\boldsymbol{x}^+ \in \Gamma^+.\]</p><p>We now want to ensure that the solution on the image <span>$\Gamma^+$</span> is mirrored on the mirror <span>$\Gamma^-$</span>. This periodicity constraint can thus be described by</p><p class="math-container">\[u(\boldsymbol{x}^-) = u(\boldsymbol{x}^+).\]</p><p>Sometimes this is written as</p><p class="math-container">\[\llbracket u \rrbracket = 0,\]</p><p>where <span>$\llbracket \bullet \rrbracket := \bullet(\boldsymbol{x}^+) - \bullet(\boldsymbol{x}^-)$</span> is the &quot;jump operator&quot;. Thus, this condition ensure that the jump, or difference, in the solution between the image and mirror boundary is the zero – the solution becomes periodic. For a vector valued problem the periodicity constraint can in general be written as</p><p class="math-container">\[\boldsymbol{u}(\boldsymbol{x}^-) = \boldsymbol{R} \cdot \boldsymbol{u}(\boldsymbol{x}^+)
\quad \Leftrightarrow \quad \llbracket \boldsymbol{u} \rrbracket =
\boldsymbol{R} \cdot \boldsymbol{u}(\boldsymbol{x}^+) - \boldsymbol{u}(\boldsymbol{x}^-) =
\boldsymbol{0}\]</p><p>where <span>$\boldsymbol{R}$</span> is a rotation matrix. If the mapping between mirror and image is simply a translation (e.g. sides of a cube) this matrix will be the identity matrix.</p><p>In Ferrite this type of periodic Dirichlet boundary conditions can be added to the <code>ConstraintHandler</code> by constructing an instance of <a href="../../reference/boundary_conditions/#Ferrite.PeriodicDirichlet"><code>PeriodicDirichlet</code></a>. This is usually done it two steps. First we compute the mapping between mirror and image facets using <a href="../../reference/boundary_conditions/#Ferrite.collect_periodic_facets"><code>collect_periodic_facets</code></a>. Here we specify the mirror set and image sets (the sets are usually known or can be constructed easily ) and the mapping <span>$\varphi$</span>. Second we construct the constraint using the <code>PeriodicDirichlet</code> constructor. Here we specify which components of the function that should be constrained, and the rotation matrix <span>$\boldsymbol{R}$</span> (when needed). When adding the constraint to the <code>ConstraintHandler</code> the resulting dof-mapping is computed.</p><p>Here is a simple example where periodicity is enforced for components 1 and 2 of the field <code>:u</code> between the mirror boundary set <code>&quot;left&quot;</code> and the image boundary set <code>&quot;right&quot;</code>. Note that no rotation matrix is needed here since the mirror and image are parallel, just shifted in the <span>$x$</span>-direction (as seen by the mapping <code>φ</code>):</p><pre><code class="language-julia hljs"># Create a constraint handler from the dof handler
ch = ConstraintHandler(dofhandler)

# Compute the facet mapping
φ(x) = x - Vec{2}((1.0, 0.0))
face_mapping = collect_periodic_facets(grid, &quot;left&quot;, &quot;right&quot;, φ)

# Construct the periodic constraint for field :u
pdbc = PeriodicDirichlet(:u, face_mapping, [1, 2])

# Add the constraint to the constraint handler
add!(ch, pdbc)

# If no more constraints should be added we can close
close!(ch)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>PeriodicDirichlet</code> constraints are imposed in a strong sense, so note that this requires a periodic mesh such that it is possible to compute the facet mapping between facets on the mirror and boundary.</p></div></div><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>Periodic boundary conditions are used in the following examples <a href="../../tutorials/computational_homogenization/#tutorial-computational-homogenization">Computational homogenization</a>, <a href="../../tutorials/stokes-flow/#tutorial-stokes-flow">Stokes flow</a>.</p></div></div><h4 id="Heterogeneous-&quot;periodic&quot;-constraint"><a class="docs-heading-anchor" href="#Heterogeneous-&quot;periodic&quot;-constraint">Heterogeneous &quot;periodic&quot; constraint</a><a id="Heterogeneous-&quot;periodic&quot;-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Heterogeneous-&quot;periodic&quot;-constraint" title="Permalink"></a></h4><p>It is also possible to define constraints of the form</p><p class="math-container">\[\llbracket u \rrbracket = \llbracket f \rrbracket
\quad \Leftrightarrow \quad
u(\boldsymbol{x}^+) - u(\boldsymbol{x}^-) =
f(\boldsymbol{x}^+) - f(\boldsymbol{x}^-),\]</p><p>where <span>$f$</span> is a prescribed function. Although the constraint in this case is not technically periodic, <code>PeriodicDirichlet</code> can be used for this too. This is done by passing a function to <code>PeriodicDirichlet</code>, similar to <code>Dirichlet</code>, which, given the coordinate <span>$\boldsymbol{x}$</span> and time <code>t</code>, computes the prescribed values of <span>$f$</span> on the boundary.</p><p>Here is an example of how to implement this type of boundary condition, for a known function <code>f</code>:</p><pre><code class="language-julia hljs">pdbc = PeriodicDirichlet(
    :u,
    face_mapping,
    (x, t) -&gt; f(x),
    [1, 2],
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One application for this type of boundary conditions is multiscale modeling and computational homogenization when solving the finite element problem for the subscale. In this case the unknown <span>$u$</span> is split into a macroscopic part <span>$u^{\mathrm{M}}$</span> and a microscopic/fluctuation part <span>$u^\mu$</span>, i.e. <span>$u = u^{\mathrm{M}} + u^{\mu}$</span>. Periodicity is then usually enforced for the fluctuation part, i.e. <span>$\llbracket u^\mu \rrbracket = 0$</span>. The equivalent constraint for <span>$u$</span> then becomes <span>$\llbracket u \rrbracket = \llbracket u^{\mathrm{M}} \rrbracket$</span>.</p><p>As an example, consider first order homogenization where the macroscopic part is constructed as <span>$u^{\mathrm{M}} = \bar{u} + \boldsymbol{\nabla} \bar{u} \cdot [\boldsymbol{x} - \bar{\boldsymbol{x}}]$</span> for known <span>$\bar{u}$</span> and <span>$\boldsymbol{\nabla} \bar{u}$</span>. This could be implemented as</p><pre><code class="language-julia hljs">pdbc = PeriodicDirichlet(
    :u,
    face_mapping,
    (x, t) -&gt; ū + ∇ū  ⋅ (x - x̄)
)</code></pre></div></div><h2 id="Initial-conditions"><a class="docs-heading-anchor" href="#Initial-conditions">Initial conditions</a><a id="Initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-conditions" title="Permalink"></a></h2><p>When solving time-dependent problems, initial conditions, different from zero, may be required. For finite element formulations of ODE-type, i.e. <span>$\boldsymbol{u}&#39;(t) = \boldsymbol{f}(\boldsymbol{u}(t),t)$</span>, where <span>$\boldsymbol{u}(t)$</span> are the degrees of freedom, initial conditions can be specified by the <a href="../../reference/boundary_conditions/#Ferrite.apply_analytical!"><code>apply_analytical!</code></a> function. For example, specify the initial pressure as a function of the y-coordinate</p><pre><code class="language-julia hljs">ρ = 1000; g = 9.81    # density [kg/m³] and gravity [N/kg]
grid = generate_grid(Quadrilateral, (10,10))
dh = DofHandler(grid); add!(dh, :u, 2); add!(dh, :p, 1); close!(dh)
u = zeros(ndofs(dh))
apply_analytical!(u, dh, :p, x -&gt; ρ * g * x[2])</code></pre><p>See also <a href="../../tutorials/transient_heat_equation/#tutorial-transient-heat-equation">Transient heat equation</a> for one example.</p><div class="admonition is-info"><header class="admonition-header">Consistency</header><div class="admonition-body"><p><code>apply_analytical!</code> does not enforce consistency of the applied solution with the system of equations. Some problems, like for example differential-algebraic systems of equations (DAEs) need extra care during initialization. We refer to the paper <a href="https://dx.doi.org/10.1137/S1064827595289996">&quot;Consistent Initial Condition Calculation for Differential-Algebraic Systems&quot; by Brown et al.</a> for more details on this matter.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../assembly/">« Assembly</a><a class="docs-footer-nextpage" href="../constraints/">Constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 18:15">Tuesday 5 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
