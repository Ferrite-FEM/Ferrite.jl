<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FEValues · Ferrite.jl</title><meta name="title" content="FEValues · Ferrite.jl"/><meta property="og:title" content="FEValues · Ferrite.jl"/><meta property="twitter:title" content="FEValues · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/FEValues/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/FEValues/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/FEValues/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Tutorials overview</a></li><li><a class="tocitem" href="../../tutorials/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../tutorials/linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../../tutorials/incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../../tutorials/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../tutorials/plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../../tutorials/transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../../tutorials/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../tutorials/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../tutorials/porous_media/">Porous media</a></li><li><a class="tocitem" href="../../tutorials/ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/reactive_surface/">Reactive surface</a></li><li><a class="tocitem" href="../../tutorials/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../tutorials/dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Topic guide overview</a></li><li><a class="tocitem" href="../fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../reference_shapes/">Reference shapes</a></li><li class="is-active"><a class="tocitem" href>FEValues</a><ul class="internal"><li><a class="tocitem" href="#mapping_theory"><span>Mapping of finite elements</span></a></li><li><a class="tocitem" href="#SimpleCellValues"><span>Walkthrough: Creating <code>SimpleCellValues</code></span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li></ul></li><li><a class="tocitem" href="../degrees_of_freedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../sparse_matrix/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary and initial conditions</a></li><li><a class="tocitem" href="../constraints/">Affine constraints</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of freedom</a></li><li><a class="tocitem" href="../../reference/sparsity_pattern/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../cited-literature/">Cited literature</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Topic guides</a></li><li class="is-active"><a href>FEValues</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FEValues</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/topics/FEValues.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="fevalues_topicguide"><a class="docs-heading-anchor" href="#fevalues_topicguide">FEValues</a><a id="fevalues_topicguide-1"></a><a class="docs-heading-anchor-permalink" href="#fevalues_topicguide" title="Permalink"></a></h1><p>A key type of object in Ferrite is the so-called <code>FEValues</code>, where the most common ones are <code>CellValues</code> and <code>FacetValues</code>. These objects are used inside the element routines and are used to query the integration weights, shape function values and gradients, and much more; see <a href="../../reference/fevalues/#Ferrite.CellValues"><code>CellValues</code></a> and <a href="../../reference/fevalues/#Ferrite.FacetValues"><code>FacetValues</code></a>. For these values to be correct, it is necessary to reinitialize these for the current cell by using the <a href="../../reference/fevalues/#Ferrite.reinit!"><code>reinit!</code></a> function. This function maps the values from the reference cell to the actual cell, a process described in detail below, see <a href="#mapping_theory">Mapping of finite elements</a>. After that, we show an implementation of a <a href="#SimpleCellValues"><code>SimpleCellValues</code></a> type to illustrate how <code>CellValues</code> work for the most standard case, excluding the generalizations and optimization that complicates the actual code.</p><h2 id="mapping_theory"><a class="docs-heading-anchor" href="#mapping_theory">Mapping of finite elements</a><a id="mapping_theory-1"></a><a class="docs-heading-anchor-permalink" href="#mapping_theory" title="Permalink"></a></h2><p>The shape functions and gradients stored in an <code>FEValues</code> object, are reinitialized for each cell by calling the <code>reinit!</code> function. The main part of this calculation, considers how to map the values and derivatives of the shape functions, defined on the reference cell, to the actual cell.</p><p>The geometric mapping of a finite element from the reference coordinates to the real coordinates is shown in the following illustration.</p><p><img src="https://raw.githubusercontent.com/Ferrite-FEM/Ferrite.jl/gh-pages/assets/fe_mapping.svg" alt="mapping_figure"/></p><p>This mapping is given by the geometric shape functions, <span>$\hat{N}_i^g(\boldsymbol{\xi})$</span>, such that</p><p class="math-container">\[\begin{align*}
    \boldsymbol{x}(\boldsymbol{\xi}) =&amp; \sum_{\alpha=1}^N \hat{\boldsymbol{x}}_\alpha \hat{N}_\alpha^g(\boldsymbol{\xi}) \\
    \boldsymbol{J} :=&amp; \frac{\mathrm{d}\boldsymbol{x}}{\mathrm{d}\boldsymbol{\xi}} = \sum_{\alpha=1}^N \hat{\boldsymbol{x}}_\alpha \otimes \frac{\mathrm{d} \hat{N}_\alpha^g}{\mathrm{d}\boldsymbol{\xi}}\\
    \boldsymbol{\mathcal{H}} :=&amp;
    \frac{\mathrm{d} \boldsymbol{J}}{\mathrm{d} \boldsymbol{\xi}} = \sum_{\alpha=1}^N \hat{\boldsymbol{x}}_\alpha \otimes \frac{\mathrm{d}^2 \hat{N}^g_\alpha}{\mathrm{d} \boldsymbol{\xi}^2}
\end{align*}\]</p><p>where the defined <span>$\boldsymbol{J}$</span> is the jacobian of the mapping, and in some cases we will also need the corresponding hessian, <span>$\boldsymbol{\mathcal{H}}$</span> (3rd order tensor).</p><p>We require that the mapping from reference coordinates to real coordinates is <a href="https://en.wikipedia.org/wiki/Diffeomorphism">diffeomorphic</a>, meaning that we can express <span>$\boldsymbol{x} = \boldsymbol{x}(\boldsymbol{\xi}(\boldsymbol{x}))$</span>, such that</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d}\boldsymbol{x}}{\mathrm{d}\boldsymbol{x}} = \boldsymbol{I} &amp;= \frac{\mathrm{d}\boldsymbol{x}}{\mathrm{d}\boldsymbol{\xi}} \cdot \frac{\mathrm{d}\boldsymbol{\xi}}{\mathrm{d}\boldsymbol{x}}
    \quad\Rightarrow\quad
    \frac{\mathrm{d}\boldsymbol{\xi}}{\mathrm{d}\boldsymbol{x}} = \left[\frac{\mathrm{d}\boldsymbol{x}}{\mathrm{d}\boldsymbol{\xi}}\right]^{-1} = \boldsymbol{J}^{-1}
\end{align*}\]</p><p>Depending on the function interpolation, we may want different types of mappings to conserve certain properties of the fields. This results in the different mapping types described below.</p><h3 id="Identity-mapping"><a class="docs-heading-anchor" href="#Identity-mapping">Identity mapping</a><a id="Identity-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Identity-mapping" title="Permalink"></a></h3><p><code>Ferrite.IdentityMapping</code></p><p>For scalar fields, we always use scalar base functions. For tensorial fields (non-scalar, e.g. vector-fields), the base functions can be constructed from scalar base functions, by using e.g. <code>VectorizedInterpolation</code>. From the perspective of the mapping, however, each component is mapped as an individual scalar base function. And for scalar base functions, we only require that the value of the base function is invariant to the element shape (real coordinate), and only depends on the reference coordinate, i.e.</p><p class="math-container">\[\begin{align*}
    N(\boldsymbol{x}) &amp;= \hat{N}(\boldsymbol{\xi}(\boldsymbol{x}))\nonumber \\
    \mathrm{grad}(N(\boldsymbol{x})) &amp;= \frac{\mathrm{d}\hat{N}}{\mathrm{d}\boldsymbol{\xi}} \cdot \boldsymbol{J}^{-1}
\end{align*}\]</p><p>Second order gradients of the shape functions are computed as</p><p class="math-container">\[\begin{align*}
    \mathrm{grad}(\mathrm{grad}(N(\boldsymbol{x}))) = \frac{\mathrm{d}^2 N}{\mathrm{d}\boldsymbol{x}^2} = \boldsymbol{J}^{-T} \cdot \frac{\mathrm{d}^2\hat{N}}{\mathrm{d}\boldsymbol{\xi}^2} \cdot \boldsymbol{J}^{-1} -  \boldsymbol{J}^{-T} \cdot\mathrm{grad}(N) \cdot \boldsymbol{\mathcal{H}}  \cdot \boldsymbol{J}^{-1}
\end{align*}\]</p><details class="admonition is-details"><summary class="admonition-header">Derivation</summary><div class="admonition-body"><p>The gradient of the shape functions is obtained using the chain rule:</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d} N}{\mathrm{d}x_i} = \frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r}\frac{\mathrm{d} \xi_r}{\mathrm{d} x_i} = \frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r} J^{-1}_{ri}
\end{align*}\]</p><p>For the second order gradients, we first use the product rule on the equation above:</p><p class="math-container">\[\begin{align}
    \frac{\mathrm{d}^2 N}{\mathrm{d}x_i \mathrm{d}x_j} = \frac{\mathrm{d}}{\mathrm{d}x_j}\left[\frac{\mathrm{d} \hat N}{\mathrm{d}   \xi_r}\right] J^{-1}_{ri} + \frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r} \frac{\mathrm{d}J^{-1}_{ri}}{\mathrm{d}x_j}
\end{align}\]</p><p>Using the fact that <span>$\frac{\mathrm{d}\hat{f}(\boldsymbol{\xi})}{\mathrm{d}x_j} = \frac{\mathrm{d}\hat{f}(\boldsymbol{\xi})}{\mathrm{d}\xi_s} J^{-1}_{sj}$</span>, the first term in the equation above can be expressed as:</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d}}{\mathrm{d}x_j}\left[\frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r}\right] J^{-1}_{ri} = J^{-1}_{sj}\frac{\mathrm{d}}{\mathrm{d}\xi_s}\left[\frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r}\right] J^{-1}_{ri} = J^{-1}_{sj}\left[\frac{\mathrm{d}^2 \hat N}{\mathrm{d} \xi_s\mathrm{d} \xi_r}\right] J^{-1}_{ri}
\end{align*}\]</p><p>The second term can be written as:</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r}\frac{\mathrm{d}J^{-1}_{ri}}{\mathrm{d}x_j} = \frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r}\left[\frac{\mathrm{d}J^{-1}_{ri}}{\mathrm{d}\xi_s}\right]J^{-1}_{sj} = \frac{\mathrm{d} \hat N}{\mathrm{d} \xi_r}\left[- J^{-1}_{rk}\mathcal{H}_{kps} J^{-1}_{pi}\right] J^{-1}_{sj} = - \frac{\mathrm{d} \hat N}{\mathrm{d} x_k}\mathcal{H}_{kps} J^{-1}_{pi}J^{-1}_{sj}
\end{align*}\]</p><p>where we have used that the inverse of the jacobian can be computed as:</p><p class="math-container">\[\begin{align*}
0 = \frac{\mathrm{d}}{\mathrm{d}\xi_s} (J_{kr} J^{-1}_{ri} ) = \frac{\mathrm{d}J_{kp}}{\mathrm{d}\xi_s} J^{-1}_{pi}  + J_{kr} \frac{\mathrm{d}J^{-1}_{ri}}{\mathrm{d}\xi_s} = 0 \quad \Rightarrow \\
\end{align*}\]</p><p class="math-container">\[\begin{align*}
\frac{\mathrm{d}J^{-1}_{ri}}{\mathrm{d}\xi_s} = - J^{-1}_{rk}\frac{\mathrm{d}J_{kp}}{\mathrm{d}\xi_s} J^{-1}_{pi} = - J^{-1}_{rk}\mathcal{H}_{kps} J^{-1}_{pi}\\
\end{align*}\]</p></div></details><h3 id="Covariant-Piola-mapping,-H(curl)"><a class="docs-heading-anchor" href="#Covariant-Piola-mapping,-H(curl)">Covariant Piola mapping, H(curl)</a><a id="Covariant-Piola-mapping,-H(curl)-1"></a><a class="docs-heading-anchor-permalink" href="#Covariant-Piola-mapping,-H(curl)" title="Permalink"></a></h3><p><code>Ferrite.CovariantPiolaMapping</code></p><p>The covariant Piola mapping of a vectorial base function preserves the tangential components. For the value, the mapping is defined as</p><p class="math-container">\[\begin{align*}
    \boldsymbol{N}(\boldsymbol{x}) = \boldsymbol{J}^{-\mathrm{T}} \cdot \hat{\boldsymbol{N}}(\boldsymbol{\xi}(\boldsymbol{x}))
\end{align*}\]</p><p>which yields the gradient,</p><p class="math-container">\[\begin{align*}
    \mathrm{grad}(\boldsymbol{N}(\boldsymbol{x})) &amp;= \boldsymbol{J}^{-T} \cdot \frac{\mathrm{d} \hat{\boldsymbol{N}}}{\mathrm{d} \boldsymbol{\xi}} \cdot \boldsymbol{J}^{-1} - \boldsymbol{J}^{-T} \cdot \left[\hat{\boldsymbol{N}}(\boldsymbol{\xi}(\boldsymbol{x}))\cdot \boldsymbol{J}^{-1} \cdot \boldsymbol{\mathcal{H}}\cdot \boldsymbol{J}^{-1}\right]
\end{align*}\]</p><details class="admonition is-details"><summary class="admonition-header">Derivation</summary><div class="admonition-body"><p>Expressing the gradient, <span>$\mathrm{grad}(\boldsymbol{N})$</span>, in index notation,</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d} N_i}{\mathrm{d} x_j} &amp;= \frac{\mathrm{d}}{\mathrm{d} x_j} \left[J^{-\mathrm{T}}_{ik} \hat{N}_k\right] = \frac{\mathrm{d} J^{-\mathrm{T}}_{ik}}{\mathrm{d} x_j} \hat{N}_k + J^{-\mathrm{T}}_{ik}  \frac{\mathrm{d} \hat{N}_k}{\mathrm{d} \xi_l} J_{lj}^{-1}
\end{align*}\]</p><p>Except for a few elements, <span>$\boldsymbol{J}$</span> varies as a function of <span>$\boldsymbol{x}$</span>. The derivative can be calculated as</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d} J^{-\mathrm{T}}_{ik}}{\mathrm{d} x_j} &amp;= \frac{\mathrm{d} J^{-\mathrm{T}}_{ik}}{\mathrm{d} J_{mn}} \frac{\mathrm{d} J_{mn}}{\mathrm{d} x_j} = - J_{km}^{-1} J_{in}^{-T} \frac{\mathrm{d} J_{mn}}{\mathrm{d} x_j} \nonumber \\
    \frac{\mathrm{d} J_{mn}}{\mathrm{d} x_j} &amp;= \mathcal{H}_{mno} J_{oj}^{-1}
\end{align*}\]</p></div></details><h3 id="Contravariant-Piola-mapping,-H(div)"><a class="docs-heading-anchor" href="#Contravariant-Piola-mapping,-H(div)">Contravariant Piola mapping, H(div)</a><a id="Contravariant-Piola-mapping,-H(div)-1"></a><a class="docs-heading-anchor-permalink" href="#Contravariant-Piola-mapping,-H(div)" title="Permalink"></a></h3><p><code>Ferrite.ContravariantPiolaMapping</code></p><p>The covariant Piola mapping of a vectorial base function preserves the normal components. For the value, the mapping is defined as</p><p class="math-container">\[\begin{align*}
    \boldsymbol{N}(\boldsymbol{x}) = \frac{\boldsymbol{J}}{\det(\boldsymbol{J})} \cdot \hat{\boldsymbol{N}}(\boldsymbol{\xi}(\boldsymbol{x}))
\end{align*}\]</p><p>This gives the gradient</p><p class="math-container">\[\begin{align*}
    \mathrm{grad}(\boldsymbol{N}(\boldsymbol{x})) = [\boldsymbol{\mathcal{H}}\cdot\boldsymbol{J}^{-1}] : \frac{[\boldsymbol{I} \underline{\otimes} \boldsymbol{I}] \cdot \hat{\boldsymbol{N}}}{\det(\boldsymbol{J})}
    - \left[\frac{\boldsymbol{J} \cdot \hat{\boldsymbol{N}}}{\det(\boldsymbol{J})}\right] \otimes \left[\boldsymbol{J}^{-T} : \boldsymbol{\mathcal{H}} \cdot \boldsymbol{J}^{-1}\right]
    + \boldsymbol{J} \cdot \frac{\mathrm{d} \hat{\boldsymbol{N}}}{\mathrm{d} \boldsymbol{\xi}} \cdot \frac{\boldsymbol{J}^{-1}}{\det(\boldsymbol{J})}
\end{align*}\]</p><details class="admonition is-details"><summary class="admonition-header">Derivation</summary><div class="admonition-body"><p>Expressing the gradient, <span>$\mathrm{grad}(\boldsymbol{N})$</span>, in index notation,</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d} N_i}{\mathrm{d} x_j} &amp;= \frac{\mathrm{d}}{\mathrm{d} x_j} \left[\frac{J_{ik}}{\det(\boldsymbol{J})} \hat{N}_k\right] =\nonumber\\
    &amp;= \frac{\mathrm{d} J_{ik}}{\mathrm{d} x_j} \frac{\hat{N}_k}{\det(\boldsymbol{J})}
    - \frac{\mathrm{d} \det(\boldsymbol{J})}{\mathrm{d} x_j} \frac{J_{ik} \hat{N}_k}{\det(\boldsymbol{J})^2}
    + \frac{J_{ik}}{\det(\boldsymbol{J})}  \frac{\mathrm{d} \hat{N}_k}{\mathrm{d} \xi_l} J_{lj}^{-1} \\
    &amp;= \mathcal{H}_{ikl} J^{-1}_{lj} \frac{\hat{N}_k}{\det(\boldsymbol{J})}
    - J^{-T}_{mn} \mathcal{H}_{mnl} J^{-1}_{lj} \frac{J_{ik} \hat{N}_k}{\det(\boldsymbol{J})}
    + \frac{J_{ik}}{\det(\boldsymbol{J})}  \frac{\mathrm{d} \hat{N}_k}{\mathrm{d} \xi_l} J_{lj}^{-1}
\end{align*}\]</p></div></details><h2 id="SimpleCellValues"><a class="docs-heading-anchor" href="#SimpleCellValues">Walkthrough: Creating <code>SimpleCellValues</code></a><a id="SimpleCellValues-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleCellValues" title="Permalink"></a></h2><p>In the following, we walk through how to create a <code>SimpleCellValues</code> type which works similar to Ferrite&#39;s <code>CellValues</code>, but is not performance optimized and not as general. The main purpose is to explain how the <code>CellValues</code> works for the standard case of <code>IdentityMapping</code> described above. Please note that several internal functions are used, and these may change without a major version increment. Please see the <a href="../../devdocs/#Developer-documentation">Developer documentation</a> for their documentation.</p><p>We start by including Ferrite and Test (to check our implementation).</p><pre><code class="language-julia hljs">using Ferrite, Test</code></pre><p>Then, we define a simple version of the cell values object, which only supports</p><ul><li>Scalar interpolations</li><li>Identity mapping from reference to physical cell.</li><li>The cell shape has the same dimension as the physical space (excludes so-called embedded cells).</li></ul><pre><code class="language-julia hljs">struct SimpleCellValues{T, dim} &lt;: Ferrite.AbstractCellValues
    # Precalculated shape values, N[i, q_point] where i is the
    # shape function number and q_point the integration point
    N::Matrix{T}
    # Precalculated shape gradients in the reference domain, dNdξ[i, q_point]
    dNdξ::Matrix{Vec{dim, T}}
    # Cache for shape gradients in the physical domain, dNdx[i, q_point]
    dNdx::Matrix{Vec{dim, T}}
    # Precalculated geometric shape values, M[j, q_point] where j is the
    # geometric shape function number
    M::Matrix{T}
    # Precalculated geometric shape gradients, dMdξ[j, q_point]
    dMdξ::Matrix{Vec{dim, T}}
    # Given quadrature weights in the reference domain, weights[q_point]
    weights::Vector{T}
    # Cache for quadrature weights in the physical domain, detJdV[q_point], i.e.
    # det(J)*weight[q_point], where J is the jacobian of the geometric mapping
    # at the quadrature point, q_point.
    detJdV::Vector{T}
end;</code></pre><p>Next, we create a constructor with the same input as <code>CellValues</code></p><pre><code class="language-julia hljs">function SimpleCellValues(qr::QuadratureRule, ip_fun::Interpolation, ip_geo::Interpolation)
    dim = Ferrite.getrefdim(ip_fun)
    # Quadrature weights and coordinates (in reference cell)
    weights = Ferrite.getweights(qr)
    n_qpoints = length(weights)
    T = eltype(weights)

    # Function interpolation
    n_func_basefuncs = getnbasefunctions(ip_fun)
    N = zeros(T, n_func_basefuncs, n_qpoints)
    dNdx = zeros(Vec{dim, T}, n_func_basefuncs, n_qpoints)
    dNdξ = zeros(Vec{dim, T}, n_func_basefuncs, n_qpoints)

    # Geometry interpolation
    n_geom_basefuncs = getnbasefunctions(ip_geo)
    M = zeros(T, n_geom_basefuncs, n_qpoints)
    dMdξ = zeros(Vec{dim, T}, n_geom_basefuncs, n_qpoints)

    # Precalculate function and geometric shape values and gradients
    for (qp, ξ) in pairs(Ferrite.getpoints(qr))
        for i in 1:n_func_basefuncs
            dNdξ[i, qp], N[i, qp] = Ferrite.reference_shape_gradient_and_value(ip_fun, ξ, i)
        end
        for i in 1:n_geom_basefuncs
            dMdξ[i, qp], M[i, qp] = Ferrite.reference_shape_gradient_and_value(ip_geo, ξ, i)
        end
    end

    detJdV = zeros(T, n_qpoints)
    return SimpleCellValues(N, dNdξ, dNdx, M, dMdξ, weights, detJdV)
end;</code></pre><p>To make our <code>SimpleCellValues</code> work in standard Ferrite code, we need to dispatch some access functions:</p><pre><code class="language-julia hljs">Ferrite.getnbasefunctions(cv::SimpleCellValues) = size(cv.N, 1)
Ferrite.getnquadpoints(cv::SimpleCellValues) = size(cv.N, 2)
Ferrite.shape_value(cv::SimpleCellValues, q_point::Int, i::Int) = cv.N[i, q_point]
Ferrite.shape_gradient(cv::SimpleCellValues, q_point::Int, i::Int) = cv.dNdx[i, q_point];</code></pre><p>The last step is then to dispatch <code>reinit!</code> for our <code>SimpleCellValues</code> to calculate the cached values <code>dNdx</code> and <code>detJdV</code> for the current cell according to the theory for <code>IdentityMapping</code> above.</p><pre><code class="language-julia hljs">function Ferrite.reinit!(cv::SimpleCellValues, x::Vector{Vec{dim, T}}) where {dim, T}
    for (q_point, w) in pairs(cv.weights) # Loop over each quadrature point
        # Calculate the jacobian, J
        J = zero(Tensor{2, dim, T})
        for i in eachindex(x)
            J += x[i] ⊗ cv.dMdξ[i, q_point]
        end
        # Calculate the correct integration weight for the current q_point
        cv.detJdV[q_point] = det(J) * w
        # map the shape gradients to the current geometry
        Jinv = inv(J)
        for i in 1:getnbasefunctions(cv)
            cv.dNdx[i, q_point] = cv.dNdξ[i, q_point] ⋅ Jinv
        end
    end
    return
end;</code></pre><p>To test our implementation, we create instances of our <code>SimpleCellValues</code> and the standard <code>CellValues</code>:</p><pre><code class="language-julia hljs">qr = QuadratureRule{RefQuadrilateral}(2)
ip = Lagrange{RefQuadrilateral, 1}()
simple_cv = SimpleCellValues(qr, ip, ip)
cv = CellValues(qr, ip, ip);</code></pre><p>The first thing to try is to reinitialize the cell values to a given cell, in this case cell nr. 2</p><pre><code class="language-julia hljs">grid = generate_grid(Quadrilateral, (2, 2))
x = getcoordinates(grid, 2)
reinit!(simple_cv, x)
reinit!(cv, x);</code></pre><p>If we now pretend we are inside an element routine and have a vector of element degree of freedom values, <code>ue</code>. Then, we can check that our function values and gradients match Ferrite&#39;s builtin <code>CellValues</code>:</p><pre><code class="language-julia hljs">ue = rand(getnbasefunctions(simple_cv))
q_point = 2
@test function_value(cv, q_point, ue) ≈ function_value(simple_cv, q_point, ue)
@test function_gradient(cv, q_point, ue) ≈ function_gradient(simple_cv, q_point, ue)</code></pre><pre><code class="nohighlight hljs">Test Passed</code></pre><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><ul><li><a href="https://defelement.org/ciarlet.html#Mapping+finite+elements">defelement.org</a></li><li>Kirby (2017) [<a href="../../cited-literature/#Kirby2017">5</a>]</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference_shapes/">« Reference shapes</a><a class="docs-footer-nextpage" href="../degrees_of_freedom/">Degrees of freedom »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 14 April 2025 19:25">Monday 14 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
