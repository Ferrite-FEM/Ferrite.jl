<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparsity pattern and sparse matrices · Ferrite.jl</title><meta name="title" content="Sparsity pattern and sparse matrices · Ferrite.jl"/><meta property="og:title" content="Sparsity pattern and sparse matrices · Ferrite.jl"/><meta property="twitter:title" content="Sparsity pattern and sparse matrices · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/sparse_matrix/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/sparse_matrix/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/sparse_matrix/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Tutorials overview</a></li><li><a class="tocitem" href="../../tutorials/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../tutorials/linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../../tutorials/incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../../tutorials/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../tutorials/plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../../tutorials/transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../../tutorials/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../tutorials/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../tutorials/porous_media/">Porous media</a></li><li><a class="tocitem" href="../../tutorials/ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/reactive_surface/">Reactive surface</a></li><li><a class="tocitem" href="../../tutorials/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../tutorials/dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Topic guide overview</a></li><li><a class="tocitem" href="../fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../reference_shapes/">Reference shapes</a></li><li><a class="tocitem" href="../FEValues/">FEValues</a></li><li><a class="tocitem" href="../degrees_of_freedom/">Degrees of Freedom</a></li><li class="is-active"><a class="tocitem" href>Sparsity pattern and sparse matrices</a><ul class="internal"><li><a class="tocitem" href="#Sparsity-pattern"><span>Sparsity pattern</span></a></li><li><a class="tocitem" href="#Creating-sparsity-patterns"><span>Creating sparsity patterns</span></a></li><li><a class="tocitem" href="#Instantiating-the-sparse-matrix"><span>Instantiating the sparse matrix</span></a></li></ul></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary and initial conditions</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/sparsity_pattern/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../cited-literature/">Cited literature</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Topic guides</a></li><li class="is-active"><a href>Sparsity pattern and sparse matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparsity pattern and sparse matrices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/topics/sparse_matrix.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="topic-sparse-matrix"><a class="docs-heading-anchor" href="#topic-sparse-matrix">Sparsity pattern and sparse matrices</a><a id="topic-sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#topic-sparse-matrix" title="Permalink"></a></h1><p>An important property of the finite element method is that it results in <em>sparse matrices</em> for the linear systems to be solved. On this page the topic of sparsity and sparse matrices are discussed.</p><ul><li><a href="#Sparsity-pattern">Sparsity pattern</a></li><li><a href="#Creating-sparsity-patterns">Creating sparsity patterns</a></li><li><a href="#Instantiating-the-sparse-matrix">Instantiating the sparse matrix</a></li></ul><h2 id="Sparsity-pattern"><a class="docs-heading-anchor" href="#Sparsity-pattern">Sparsity pattern</a><a id="Sparsity-pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-pattern" title="Permalink"></a></h2><p>The sparse structure of the linear system depends on many factors such as e.g. the weak form, the discretization, and the choice of interpolation(s). In the end it boils down to how the degrees of freedom (DoFs) <em>couple</em> with each other. The most common reason that two DoFs couple is because they belong to the same element. Note, however, that this is not guaranteed to result in a coupling since it depends on the specific weak form that is being discretized, see e.g. <a href="#Increasing-the-sparsity">Increasing the sparsity</a>. Boundary conditions and constraints can also result in additional DoF couplings.</p><p>If DoFs <code>i</code> and <code>j</code> couple, then the computed value in the eventual matrix will be <em>structurally nonzero</em><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. In this case the entry <code>(i, j)</code> should be included in the sparsity pattern. Conversely, if DoFs <code>i</code> and <code>j</code> <em>don&#39;t</em> couple, then the computed value will be <em>zero</em>. In this case the entry <code>(i, j)</code> should <em>not</em> be included in the sparsity pattern since there is no need to allocate memory for entries that will be zero.</p><p>The sparsity, i.e. the ratio of zero-entries to the total number of entries, is often<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> <em>very</em> high and taking advantage of this results in huge savings in terms of memory. For example, in a problem with <span>$10^6$</span> DoFs there will be a matrix of size <span>$10^6 \times 10^6$</span>. If all <span>$10^{12}$</span> entries of this matrix had to be stored (0% sparsity) as double precision (<code>Float64</code>, 8 bytes) it would require 8 TB of memory. If instead the sparsity is 99.9973% (which is the case when solving the heat equation on a three dimensional hypercube with linear Lagrange interpolation) this would be reduced to 216 MB.</p><details class="admonition is-details"><summary class="admonition-header">Sparsity pattern example</summary><div class="admonition-body"><p>To give an example, in this one-dimensional heat problem (see the <a href="../../tutorials/heat_equation/">Heat equation</a> tutorial for the weak form) we have 4 nodes with 3 elements in between. For simplicity DoF numbers and node numbers are the same but this is not true in general since nodes and DoFs can be numbered independently (and in fact are numbered independently in Ferrite).</p><pre><code class="nohighlight hljs">1 ----- 2 ----- 3 ----- 4</code></pre><p>Assuming we use linear Lagrange interpolation (the &quot;hat functions&quot;) this will give the following connections according to the weak form:</p><ul><li>Trial function 1 couples with test functions 1 and 2 (entries <code>(1, 1)</code> and <code>(1, 2)</code> included in the sparsity pattern)</li><li>Trial function 2 couples with test functions 1, 2, and 3 (entries <code>(2, 1)</code>, <code>(2, 2)</code>, and <code>(2, 3)</code> included in the sparsity pattern)</li><li>Trial function 3 couples with test functions 2, 3, and 4 (entries <code>(3, 2)</code>, <code>(3, 3)</code>, and <code>(3, 4)</code> included in the sparsity pattern)</li><li>Trial function 4 couples with test functions 3 and 4 (entries <code>(4, 3)</code> and <code>(4, 4)</code> included in the sparsity pattern)</li></ul><p>The resulting sparsity pattern would look like this:</p><pre><code class="nohighlight hljs">4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 10 stored entries:
 0.0  0.0   ⋅    ⋅
 0.0  0.0  0.0   ⋅
  ⋅   0.0  0.0  0.0
  ⋅    ⋅   0.0  0.0</code></pre><p>Moreover, if the problem is solved with periodic boundary conditions, for example by constraining the value on the right side to the value on the left side, there will be additional couplings. In the example above, this means that DoF 4 should be equal to DoF</p><ol><li>Since DoF 4 is constrained it has to be eliminated from the system. Existing entries</li></ol><p>that include DoF 4 are <code>(3, 4)</code>, <code>(4, 3)</code>, and <code>(4, 4)</code>. Given the simple constraint in this case we can simply replace DoF 4 with DoF 1 in these entries and we end up with entries <code>(3, 1)</code>, <code>(1, 3)</code>, and <code>(1, 1)</code>. This results in two new entries: <code>(3, 1)</code> and <code>(1, 3)</code> (entry <code>(1, 1)</code> is already included).</p></div></details><h2 id="Creating-sparsity-patterns"><a class="docs-heading-anchor" href="#Creating-sparsity-patterns">Creating sparsity patterns</a><a id="Creating-sparsity-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-sparsity-patterns" title="Permalink"></a></h2><p>Creating a sparsity pattern can be quite expensive if not done properly and therefore Ferrite provides efficient methods and data structures for this. In general the sparsity pattern is not known in advance and has to be created incrementally. To make this incremental construction efficient it is necessary to use a dynamic data structure which allow for fast insertions.</p><p>The sparsity pattern also serves as a &quot;matrix builder&quot;. When all entries are inserted into the sparsity pattern the dynamic data structure is typically converted, or &quot;compressed&quot;, into a sparse matrix format such as e.g. the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)"><em>compressed sparse row (CSR)</em></a> format or the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)"><em>compressed sparse column (CSC)</em></a> format, where the latter is the default sparse matrix type implemented in the <a href="https://github.com/JuliaSparse/SparseArrays.jl">SparseArrays standard library</a>. These matrix formats allow for fast linear algebra operations, such as factorizations and matrix-vector multiplications, that are needed when the linear system is solved. See <a href="#Instantiating-the-sparse-matrix">Instantiating the sparse matrix</a> for more details.</p><p>In summary, a dynamic structure is more efficient when incrementally building the pattern by inserting new entries, and a static or compressed structure is more efficient for linear algebra operations.</p><h3 id="Basic-sparsity-patterns-construction"><a class="docs-heading-anchor" href="#Basic-sparsity-patterns-construction">Basic sparsity patterns construction</a><a id="Basic-sparsity-patterns-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-sparsity-patterns-construction" title="Permalink"></a></h3><p>Working with the sparsity pattern explicitly is in many cases not necessary. For basic usage (e.g. when only one matrix needed, when no customization of the pattern is required, etc) there exist convenience methods of <a href="../../reference/sparsity_pattern/#Ferrite.allocate_matrix-Tuple{SparsityPattern}"><code>allocate_matrix</code></a> that return the matrix directly. Most examples in this documentation don&#39;t deal with the sparsity pattern explicitly because the basic method suffice. See also <a href="#Instantiating-the-sparse-matrix">Instantiating the sparse matrix</a> for more details.</p><h3 id="Custom-sparsity-pattern-construction"><a class="docs-heading-anchor" href="#Custom-sparsity-pattern-construction">Custom sparsity pattern construction</a><a id="Custom-sparsity-pattern-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-sparsity-pattern-construction" title="Permalink"></a></h3><p>In more advanced cases there might be a need for more fine grained control of the sparsity pattern. The following steps are typically taken when constructing a sparsity pattern in Ferrite:</p><ol><li><p><strong>Initialize an empty pattern:</strong> This can be done by either using the <a href="../../reference/sparsity_pattern/#Ferrite.init_sparsity_pattern"><code>init_sparsity_pattern(dh)</code></a> function or by using a constructor directly. <code>init_sparsity_pattern</code> will return a default pattern type that is compatible with the DofHandler. In some cases you might require another type of pattern (for example a blocked pattern, see <a href="#Blocked-sparsity-pattern">Blocked sparsity pattern</a>) and in that case you can use the constructor directly.</p></li><li><p><strong>Add entries to the pattern:</strong> There are a number of functions that add entries to the pattern:</p><ul><li><a href="../../reference/sparsity_pattern/#Ferrite.add_sparsity_entries!"><code>add_sparsity_entries!</code></a> is a convenience method for performing the common task of calling <code>add_cell_entries!</code>, <code>add_interface_entries!</code>, and <code>add_constraint_entries!</code> after each other (see below).</li><li><a href="../../reference/sparsity_pattern/#Ferrite.add_cell_entries!"><code>add_cell_entries!</code></a> adds entries for all couplings between the DoFs within each element. These entries correspond to assembling the standard element matrix and is thus almost always required.</li><li><a href="../../reference/sparsity_pattern/#Ferrite.add_interface_entries!"><code>add_interface_entries!</code></a> adds entries for couplings between the DoFs in neighboring elements. These entries are required when integrating along internal interfaces between elements (e.g. for discontinuous Galerkin methods).</li><li><a href="../../reference/sparsity_pattern/#Ferrite.add_constraint_entries!"><code>add_constraint_entries!</code></a> adds entries required from constraints and boundary conditions in the ConstraintHandler. Note that this operation depends on existing entries in the pattern and <em>must</em> be called as the last operation on the pattern.</li><li><a href="../../reference/sparsity_pattern/#Ferrite.add_entry!"><code>Ferrite.add_entry!</code></a> adds a single entry to the pattern. This can be used if you need to add custom entries that are not covered by the other functions.</li></ul></li><li><p><strong>Instantiate the matrix:</strong> A sparse matrix can be created from the sparsity pattern using <a href="../../reference/sparsity_pattern/#Ferrite.allocate_matrix-Tuple{SparsityPattern}"><code>allocate_matrix</code></a>, see <a href="#Instantiating-the-sparse-matrix">Instantiating the sparse matrix</a> below for more details.</p></li></ol><h3 id="Increasing-the-sparsity"><a class="docs-heading-anchor" href="#Increasing-the-sparsity">Increasing the sparsity</a><a id="Increasing-the-sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Increasing-the-sparsity" title="Permalink"></a></h3><p>By default, when creating a sparsity pattern, it is assumed that each DoF within an element couple with with <em>all</em> other DoFs in the element.</p><div class="admonition is-todo"><header class="admonition-header">Todo</header><div class="admonition-body"><ul><li>Discuss the <code>coupling</code> keyword argument.</li><li>Discuss the <code>keep_constrained</code> keyword argument.</li></ul></div></div><h3 id="Blocked-sparsity-pattern"><a class="docs-heading-anchor" href="#Blocked-sparsity-pattern">Blocked sparsity pattern</a><a id="Blocked-sparsity-pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Blocked-sparsity-pattern" title="Permalink"></a></h3><div class="admonition is-todo"><header class="admonition-header">Todo</header><div class="admonition-body"><p>Discuss <code>BlockSparsityPattern</code> and <code>BlockArrays</code> extension.</p></div></div><h2 id="Instantiating-the-sparse-matrix"><a class="docs-heading-anchor" href="#Instantiating-the-sparse-matrix">Instantiating the sparse matrix</a><a id="Instantiating-the-sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Instantiating-the-sparse-matrix" title="Permalink"></a></h2><p>As mentioned above, for many simple cases there is no need to work with the sparsity pattern directly and using methods of <a href="../../reference/sparsity_pattern/#Ferrite.allocate_matrix-Tuple{SparsityPattern}"><code>allocate_matrix</code></a> that take the DofHandler as input is enough, for example:</p><pre><code class="language-julia hljs">K = allocate_matrix(dh, ch)</code></pre><p><code>allocate_matrix</code> is also used to instantiate a matrix from a sparsity pattern, for example:</p><pre><code class="language-julia hljs">K = allocate_matrix(sp)</code></pre><div class="admonition is-info"><header class="admonition-header">Multiple matrices with the same pattern</header><div class="admonition-body"><p>For some problems there is a need for multiple matrices with the same sparsity pattern, for example a mass matrix and a stiffness matrix. In this case it is more efficient to create the sparsity pattern once and then instantiate both matrices from it.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Structurally nonzero means that there is a possibility of a nonzero value even though  the computed value might become zero in the end for various reasons.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>At least for most practical problems using low order interpolations.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../degrees_of_freedom/">« Degrees of Freedom</a><a class="docs-footer-nextpage" href="../assembly/">Assembly »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 2 February 2025 22:37">Sunday 2 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
