<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Incompressible Navier-Stokes equations via DifferentialEquations.jl · Ferrite.jl</title><meta name="title" content="Incompressible Navier-Stokes equations via DifferentialEquations.jl · Ferrite.jl"/><meta property="og:title" content="Incompressible Navier-Stokes equations via DifferentialEquations.jl · Ferrite.jl"/><meta property="twitter:title" content="Incompressible Navier-Stokes equations via DifferentialEquations.jl · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/ns_vs_diffeq/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/ns_vs_diffeq/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/ns_vs_diffeq/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Tutorials overview</a></li><li><a class="tocitem" href="../heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../porous_media/">Porous media</a></li><li class="is-active"><a class="tocitem" href>Incompressible Navier-Stokes equations via DifferentialEquations.jl</a><ul class="internal"><li><a class="tocitem" href="#Remarks-on-DifferentialEquations.jl"><span>Remarks on DifferentialEquations.jl</span></a></li><li><a class="tocitem" href="#Some-theory-on-the-incompressible-Navier-Stokes-equations"><span>Some theory on the incompressible Navier-Stokes equations</span></a></li><li><a class="tocitem" href="#Commented-implementation"><span>Commented implementation</span></a></li><li><a class="tocitem" href="#ns_vs_diffeq-plain-program"><span>Plain program</span></a></li></ul></li><li><a class="tocitem" href="../reactive_surface/">Reactive surface</a></li><li><a class="tocitem" href="../linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Topic guide overview</a></li><li><a class="tocitem" href="../../topics/fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../../topics/reference_shapes/">Reference shapes</a></li><li><a class="tocitem" href="../../topics/FEValues/">FEValues</a></li><li><a class="tocitem" href="../../topics/degrees_of_freedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../../topics/sparse_matrix/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../topics/assembly/">Assembly</a></li><li><a class="tocitem" href="../../topics/boundary_conditions/">Boundary and initial conditions</a></li><li><a class="tocitem" href="../../topics/constraints/">Affine constraints</a></li><li><a class="tocitem" href="../../topics/grid/">Grid</a></li><li><a class="tocitem" href="../../topics/export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of freedom</a></li><li><a class="tocitem" href="../../reference/sparsity_pattern/">Sparsity pattern and sparse matrices</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../cited-literature/">Cited literature</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate-tutorials/ns_vs_diffeq.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial-ins-ordinarydiffeq"><a class="docs-heading-anchor" href="#tutorial-ins-ordinarydiffeq">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a><a id="tutorial-ins-ordinarydiffeq-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-ins-ordinarydiffeq" title="Permalink"></a></h1><p><img src="../nsdiffeq.gif" alt="nsdiffeq"/></p><p>In this example we focus on a simple but visually appealing problem from fluid dynamics, namely vortex shedding. This problem is also known as <a href="https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_vortex_street">von-Karman vortex streets</a>. Within this example, we show how to utilize <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> in tandem with Ferrite to solve this space-time problem. To keep things simple we use a naive approach to discretize the system.</p><h2 id="Remarks-on-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Remarks-on-DifferentialEquations.jl">Remarks on DifferentialEquations.jl</a><a id="Remarks-on-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Remarks-on-DifferentialEquations.jl" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Required Version</header><div class="admonition-body"><p>This example will only work with OrdinaryDiffEq@v6.80.1. or above</p></div></div><p>Many &quot;time step solvers&quot; of <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> assume that that the problem is provided in mass matrix form. The incompressible Navier-Stokes equations as stated above yield a DAE in this form after applying a spatial discretization technique - in our case FEM. The mass matrix form of ODEs and DAEs is given as:</p><p class="math-container">\[  M(t) \mathrm{d}_t u = f(u,t)\]</p><p>where <span>$M$</span> is a possibly time-dependent and not necessarily invertible mass matrix, <span>$u$</span> the vector of unknowns and <span>$f$</span> the right-hand-side (RHS). For us <span>$f$</span> can be interpreted as the spatial discretization of all linear and nonlinear operators depending on <span>$u$</span> and <span>$t$</span>, but not on the time derivative of <span>$u$</span>.</p><h2 id="Some-theory-on-the-incompressible-Navier-Stokes-equations"><a class="docs-heading-anchor" href="#Some-theory-on-the-incompressible-Navier-Stokes-equations">Some theory on the incompressible Navier-Stokes equations</a><a id="Some-theory-on-the-incompressible-Navier-Stokes-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Some-theory-on-the-incompressible-Navier-Stokes-equations" title="Permalink"></a></h2><h3 id="Problem-description-in-strong-form"><a class="docs-heading-anchor" href="#Problem-description-in-strong-form">Problem description in strong form</a><a id="Problem-description-in-strong-form-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-description-in-strong-form" title="Permalink"></a></h3><p>The incompressible Navier-Stokes equations can be stated as the system</p><p class="math-container">\[ \begin{aligned}
   \partial_t v &amp;= \underbrace{\nu \Delta v}_{\text{viscosity}} - \underbrace{(v \cdot \nabla) v}_{\text{advection}} - \underbrace{\nabla p}_{\text{pressure}} \\
              0 &amp;= \underbrace{\nabla \cdot v}_{\text{incompressibility}}
 \end{aligned}\]</p><p>where <span>$v$</span> is the unknown velocity field, <span>$p$</span> the unknown pressure field, <span>$\nu$</span> the dynamic viscosity and <span>$\Delta$</span> the Laplacian. In the derivation we assumed a constant density of 1 for the fluid and negligible coupling between the velocity components.</p><p>Our setup is derived from <a href="http://www.mathematik.tu-dortmund.de/~featflow/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark2_re100.html">Turek&#39;s DFG benchmark</a>. We model a channel with size <span>$0.41 \times 1.1$</span> and a hole of radius <span>$0.05$</span> centered at <span>$(0.2, 0.2)$</span>. The left side has a parabolic inflow profile, which is ramped up over time, modeled as the time dependent Dirichlet condition</p><p class="math-container">\[ v(x,y,t)
 =
 \begin{bmatrix}
     4 v_{in}(t) y (0.41-y)/0.41^2 \\
     0
 \end{bmatrix}\]</p><p>where <span>$v_{in}(t) = \text{clamp}(t, 0.0, 1.5)$</span>. With a dynamic viscosity of <span>$\nu = 0.001$</span> this is enough to induce turbulence behind the cylinder which leads to vortex shedding. The top and bottom of our channel have no-slip conditions, i.e. <span>$v = [0,0]^{\textrm{T}}$</span>, while the right boundary has the do-nothing boundary condition <span>$\nu \partial_{\textrm{n}} v - p n = 0$</span> to model outflow. With these boundary conditions we can choose the zero solution as a feasible initial condition.</p><h3 id="Derivation-of-semi-discrete-weak-form"><a class="docs-heading-anchor" href="#Derivation-of-semi-discrete-weak-form">Derivation of semi-discrete weak form</a><a id="Derivation-of-semi-discrete-weak-form-1"></a><a class="docs-heading-anchor-permalink" href="#Derivation-of-semi-discrete-weak-form" title="Permalink"></a></h3><p>By multiplying test functions <span>$\varphi$</span> and <span>$\psi$</span> from a suitable test function space on the strong form, followed by integrating over the domain and applying partial integration to the pressure and viscosity terms we can obtain the following weak form</p><p class="math-container">\[ \begin{aligned}
   \int_\Omega \partial_t v \cdot \varphi &amp;= - \int_\Omega \nu \nabla v : \nabla \varphi - \int_\Omega (v \cdot \nabla) v \cdot \varphi + \int_\Omega p (\nabla \cdot \varphi) + \int_{\partial \Omega_{N}} \underbrace{(\nu \partial_n v - p n )}_{=0} \cdot \varphi \\
                                 0 &amp;= \int_\Omega (\nabla \cdot v) \psi
 \end{aligned}\]</p><p>for all possible test functions from the suitable space.</p><p>Now we can discretize the problem as usual with the finite element method utilizing Taylor-Hood elements (Q2Q1) to yield a stable discretization in mass matrix form:</p><p class="math-container">\[ \underbrace{\begin{bmatrix}
     M_v &amp; 0 \\
      0  &amp; 0
 \end{bmatrix}}_{:=M}
 \begin{bmatrix}
     \mathrm{d}_t\hat{v} \\
     \mathrm{d}_t\hat{p}
 \end{bmatrix}
 =
 \underbrace{\begin{bmatrix}
      A &amp; B^{\textrm{T}} \\
      B &amp; 0
 \end{bmatrix}}_{:=K}
 \begin{bmatrix}
     \hat{v} \\
     \hat{p}
 \end{bmatrix}
 +
 \begin{bmatrix}
     N(\hat{v}, \hat{v}, \hat{\varphi}) \\
     0
 \end{bmatrix}\]</p><p>Here <span>$M$</span> is the singular block mass matrix, <span>$K$</span> is the discretized Stokes operator and <span>$N$</span> the nonlinear advection term, which is also called trilinear form. <span>$\hat{v}$</span> and <span>$\hat{p}$</span> represent the time-dependent vectors of nodal values of the discretizations of <span>$v$</span> and <span>$p$</span> respectively, while <span>$\hat{\varphi}$</span> is the choice for the test function in the discretization. The hats are dropped in the implementation and only stated for clarity in this section.</p><h2 id="Commented-implementation"><a class="docs-heading-anchor" href="#Commented-implementation">Commented implementation</a><a id="Commented-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Commented-implementation" title="Permalink"></a></h2><p>Now we solve the problem with Ferrite and <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>. What follows is a program spliced with comments. The full program, without comments, can be found in the next <a href="#ns_vs_diffeq-plain-program">section</a>.</p><p>First we load Ferrite and some other packages we need</p><pre><code class="language-julia hljs">using Ferrite, SparseArrays, BlockArrays, LinearAlgebra, UnPack, LinearSolve, WriteVTK</code></pre><p>Since we do not need the complete DifferentialEquations suite, we just load the required ODE infrastructure, which can also handle DAEs in mass matrix form.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq</code></pre><p>We start off by defining our only material parameter.</p><pre><code class="language-julia hljs">ν = 1.0 / 1000.0; #dynamic viscosity</code></pre><p>Next a rectangular grid with a cylinder in it has to be generated. We use Gmsh.jl for the creation of the mesh and FerriteGmsh.jl to translate it to a <code>Ferrite.Grid</code>. Note that the mesh is pretty fine, leading to a high memory consumption when feeding the equation system to direct solvers.</p><pre><code class="language-julia hljs">using FerriteGmsh
using FerriteGmsh: Gmsh
Gmsh.initialize()
gmsh.option.set_number(&quot;General.Verbosity&quot;, 2)
dim = 2;</code></pre><p>We specify first the rectangle, the cylinder, the surface spanned by the cylinder and the boolean difference of rectangle and cylinder.</p><pre><code class="language-julia hljs">rect_tag = gmsh.model.occ.add_rectangle(0, 0, 0, 1.1, 0.41)
circle_tag = gmsh.model.occ.add_circle(0.2, 0.2, 0, 0.05)
circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])
circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])
gmsh.model.occ.cut([(dim, rect_tag)], [(dim, circle_surf_tag)])</code></pre><p>Now, the geometrical entities need to be synchronized in order to be available outside of <code>gmsh.model.occ</code></p><pre><code class="language-julia hljs">gmsh.model.occ.synchronize()</code></pre><p>In the next lines, we add the physical groups needed to define boundary conditions.</p><pre><code class="language-julia hljs">bottomtag = gmsh.model.model.add_physical_group(dim - 1, [6], -1, &quot;bottom&quot;)
lefttag = gmsh.model.model.add_physical_group(dim - 1, [7], -1, &quot;left&quot;)
righttag = gmsh.model.model.add_physical_group(dim - 1, [8], -1, &quot;right&quot;)
toptag = gmsh.model.model.add_physical_group(dim - 1, [9], -1, &quot;top&quot;)
holetag = gmsh.model.model.add_physical_group(dim - 1, [5], -1, &quot;hole&quot;)</code></pre><p>Since we want a quad mesh, we specify the meshing algorithm to the quasi structured quad one. For a complete list, <a href="https://gmsh.info/doc/texinfo/gmsh.html#Mesh-options-list">see the Gmsh docs</a>.</p><pre><code class="language-julia hljs">gmsh.option.setNumber(&quot;Mesh.Algorithm&quot;, 11)
gmsh.option.setNumber(&quot;Mesh.MeshSizeFromCurvature&quot;, 20)
gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, 0.05)</code></pre><p>In the next step, the mesh is generated and finally translated.</p><pre><code class="language-julia hljs">gmsh.model.mesh.generate(dim)
grid = togrid()
Gmsh.finalize();</code></pre><h3 id="Function-space"><a class="docs-heading-anchor" href="#Function-space">Function space</a><a id="Function-space-1"></a><a class="docs-heading-anchor-permalink" href="#Function-space" title="Permalink"></a></h3><p>To ensure stability we utilize the Taylor-Hood element pair Q2-Q1.  We have to utilize the same quadrature rule for the pressure as for the velocity, because in the weak form the  linear pressure term is tested against a quadratic function.</p><pre><code class="language-julia hljs">ip_v = Lagrange{RefQuadrilateral, 2}()^dim
qr = QuadratureRule{RefQuadrilateral}(4)
cellvalues_v = CellValues(qr, ip_v);

ip_p = Lagrange{RefQuadrilateral, 1}()
cellvalues_p = CellValues(qr, ip_p);

dh = DofHandler(grid)
add!(dh, :v, ip_v)
add!(dh, :p, ip_p)
close!(dh);</code></pre><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>As in the DFG benchmark we apply no-slip conditions to the top, bottom and cylinder boundary. The no-slip condition states that the velocity of the fluid on this portion of the boundary is fixed to be zero.</p><pre><code class="language-julia hljs">ch = ConstraintHandler(dh);

nosplip_facet_names = [&quot;top&quot;, &quot;bottom&quot;, &quot;hole&quot;];
∂Ω_noslip = union(getfacetset.((grid,), nosplip_facet_names)...);
noslip_bc = Dirichlet(:v, ∂Ω_noslip, (x, t) -&gt; Vec((0.0, 0.0)), [1, 2])
add!(ch, noslip_bc);</code></pre><p>The left boundary has a parabolic inflow with peak velocity of 1.5. This ensures that for the given geometry the Reynolds number is 100, which is already enough to obtain some simple vortex streets. By increasing the velocity further we can obtain stronger vortices - which may need additional refinement of the grid.</p><pre><code class="language-julia hljs">∂Ω_inflow = getfacetset(grid, &quot;left&quot;);</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The kink in the velocity profile will lead to a discontinuity in the pressure at <span>$t=1$</span>. This needs to be considered in the DiffEq <code>init</code> by providing the keyword argument <code>d_discontinuities=[1.0]</code>.</p></div></div><pre><code class="language-julia hljs">vᵢₙ(t) = min(t * 1.5, 1.5) #inflow velocity

parabolic_inflow_profile(x, t) = Vec((4 * vᵢₙ(t) * x[2] * (0.41 - x[2]) / 0.41^2, 0.0))
inflow_bc = Dirichlet(:v, ∂Ω_inflow, parabolic_inflow_profile, [1, 2])
add!(ch, inflow_bc);</code></pre><p>The outflow boundary condition has been applied on the right side of the cylinder when the weak form has been derived by setting the boundary integral to zero. It is also called the do-nothing condition. Other outflow conditions are also possible.</p><pre><code class="language-julia hljs">∂Ω_free = getfacetset(grid, &quot;right&quot;);

close!(ch)
update!(ch, 0.0);</code></pre><h3 id="Linear-system-assembly"><a class="docs-heading-anchor" href="#Linear-system-assembly">Linear system assembly</a><a id="Linear-system-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-system-assembly" title="Permalink"></a></h3><p>Next we describe how the block mass matrix and the Stokes matrix are assembled.</p><p>For the block mass matrix <span>$M$</span> we remember that only the first equation had a time derivative and that the block mass matrix corresponds to the term arising from discretizing the time derivatives. Hence, only the upper left block has non-zero components.</p><pre><code class="language-julia hljs">function assemble_mass_matrix(cellvalues_v::CellValues, cellvalues_p::CellValues, M::SparseMatrixCSC, dh::DofHandler)
    # Allocate a buffer for the local matrix and some helpers, together with the assembler.
    n_basefuncs_v = getnbasefunctions(cellvalues_v)
    n_basefuncs_p = getnbasefunctions(cellvalues_p)
    n_basefuncs = n_basefuncs_v + n_basefuncs_p
    v▄, p▄ = 1, 2
    Mₑ = BlockedArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])

    # It follows the assembly loop as explained in the basic tutorials.
    mass_assembler = start_assemble(M)
    for cell in CellIterator(dh)
        fill!(Mₑ, 0)
        Ferrite.reinit!(cellvalues_v, cell)

        for q_point in 1:getnquadpoints(cellvalues_v)
            dΩ = getdetJdV(cellvalues_v, q_point)
            # Remember that we assemble a vector mass term, hence the dot product.
            # There is only one time derivative on the left hand side, so only one mass block is non-zero.
            for i in 1:n_basefuncs_v
                φᵢ = shape_value(cellvalues_v, q_point, i)
                for j in 1:n_basefuncs_v
                    φⱼ = shape_value(cellvalues_v, q_point, j)
                    Mₑ[BlockIndex((v▄, v▄), (i, j))] += φᵢ ⋅ φⱼ * dΩ
                end
            end
        end
        assemble!(mass_assembler, celldofs(cell), Mₑ)
    end

    return M
end;</code></pre><p>Next we discuss the assembly of the Stokes matrix appearing on the right hand side. Remember that we use the same function spaces for trial and test, hence the matrix has the following block form</p><p class="math-container">\[  K = \begin{bmatrix}
      A &amp; B^{\textrm{T}} \\
      B &amp; 0
  \end{bmatrix}\]</p><p>which is also called saddle point matrix. These problems are known to have a non-trivial kernel, which is a reflection of the strong form as discussed in the theory portion if this example.</p><pre><code class="language-julia hljs">function assemble_stokes_matrix(cellvalues_v::CellValues, cellvalues_p::CellValues, ν, K::SparseMatrixCSC, dh::DofHandler)
    # Again, some buffers and helpers
    n_basefuncs_v = getnbasefunctions(cellvalues_v)
    n_basefuncs_p = getnbasefunctions(cellvalues_p)
    n_basefuncs = n_basefuncs_v + n_basefuncs_p
    v▄, p▄ = 1, 2
    Kₑ = BlockedArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])

    # Assembly loop
    stiffness_assembler = start_assemble(K)
    for cell in CellIterator(dh)
        # Don&#39;t forget to initialize everything
        fill!(Kₑ, 0)

        Ferrite.reinit!(cellvalues_v, cell)
        Ferrite.reinit!(cellvalues_p, cell)

        for q_point in 1:getnquadpoints(cellvalues_v)
            dΩ = getdetJdV(cellvalues_v, q_point)</code></pre><p>Assemble local viscosity block of <span>$A$</span></p><pre><code class="language-julia hljs">            for i in 1:n_basefuncs_v
                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)
                for j in 1:n_basefuncs_v
                    ∇φⱼ = shape_gradient(cellvalues_v, q_point, j)
                    Kₑ[BlockIndex((v▄, v▄), (i, j))] -= ν * ∇φᵢ ⊡ ∇φⱼ * dΩ
                end
            end</code></pre><p>Assemble local pressure and incompressibility blocks of <span>$B^{\textrm{T}}$</span> and <span>$B$</span>.</p><pre><code class="language-julia hljs">            for j in 1:n_basefuncs_p
                ψ = shape_value(cellvalues_p, q_point, j)
                for i in 1:n_basefuncs_v
                    divφ = shape_divergence(cellvalues_v, q_point, i)
                    Kₑ[BlockIndex((v▄, p▄), (i, j))] += (divφ * ψ) * dΩ
                    Kₑ[BlockIndex((p▄, v▄), (j, i))] += (ψ * divφ) * dΩ
                end
            end
        end

        # Assemble `Kₑ` into the Stokes matrix `K`.
        assemble!(stiffness_assembler, celldofs(cell), Kₑ)
    end
    return K
end;</code></pre><h3 id="Solution-of-the-semi-discretized-system-via-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Solution-of-the-semi-discretized-system-via-DifferentialEquations.jl">Solution of the semi-discretized system via DifferentialEquations.jl</a><a id="Solution-of-the-semi-discretized-system-via-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-of-the-semi-discretized-system-via-DifferentialEquations.jl" title="Permalink"></a></h3><p>First we assemble the linear portions for efficiency. These matrices are assumed to be constant over time.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To obtain the vortex street a small time step is important to resolve the small oscillation forming. The mesh size becomes important to &quot;only&quot; resolve the smaller vertices forming, but less important for the initial formation.</p></div></div><pre><code class="language-julia hljs">T = 6.0
Δt₀ = 0.001
Δt_save = 0.1

M = allocate_matrix(dh);
M = assemble_mass_matrix(cellvalues_v, cellvalues_p, M, dh);

K = allocate_matrix(dh);
K = assemble_stokes_matrix(cellvalues_v, cellvalues_p, ν, K, dh);</code></pre><p>These are our initial conditions. We start from the zero solution, because it is trivially admissible if the Dirichlet conditions are zero everywhere on the Dirichlet boundary for <span>$t=0$</span>. Note that the time stepper is also doing fine if the Dirichlet condition is non-zero and not too pathological.</p><pre><code class="language-julia hljs">u₀ = zeros(ndofs(dh))
apply!(u₀, ch);</code></pre><p>DifferentialEquations assumes dense matrices by default, which is not feasible for semi-discretization of finite element models. We communicate that a sparse matrix with specified pattern should be utilized through the <code>jac_prototyp</code> argument. It is simple to see that the Jacobian and the stiffness matrix share the same sparsity pattern, since they share the same relation between trial and test functions.</p><pre><code class="language-julia hljs">jac_sparsity = sparse(K);</code></pre><p>To apply the nonlinear portion of the Navier-Stokes problem we simply hand over the dof handler and cell values to the right-hand-side (RHS) as a parameter. Furthermore the pre-assembled linear part, our Stokes operator (which is time independent) is passed to save some additional runtime. To apply the time-dependent Dirichlet BCs, we also need to hand over the constraint handler. The basic idea to apply the Dirichlet BCs consistently is that we copy the current solution <code>u</code>, apply the Dirichlet BCs on the copy, evaluate the discretized RHS of the Navier-Stokes equations with this vector. Furthermore we pass down the Jacobian assembly manually. For the Jacobian we eliminate all rows and columns associated with constrained dofs. Also note that we eliminate the mass matrix beforehand in a similar fashion. This decouples the time evolution of the constrained dofs from the true unknowns. The correct solution is enforced by utilizing step and stage limiters. The correct norms are computed by passing down a custom norm which simply ignores all constrained dofs.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An alternative strategy is to hook into the nonlinear and linear solvers and enforce the solution therein. However, this is not possible at the time of writing this tutorial.</p></div></div><pre><code class="language-julia hljs">apply!(M, ch)

struct RHSparams
    K::SparseMatrixCSC
    ch::ConstraintHandler
    dh::DofHandler
    cellvalues_v::CellValues
    u::Vector
end
p = RHSparams(K, ch, dh, cellvalues_v, copy(u₀))

function ferrite_limiter!(u, _, p, t)
    update!(p.ch, t)
    return apply!(u, p.ch)
end

function navierstokes_rhs_element!(dvₑ, vₑ, cellvalues_v)
    n_basefuncs = getnbasefunctions(cellvalues_v)
    for q_point in 1:getnquadpoints(cellvalues_v)
        dΩ = getdetJdV(cellvalues_v, q_point)
        ∇v = function_gradient(cellvalues_v, q_point, vₑ)
        v = function_value(cellvalues_v, q_point, vₑ)
        for j in 1:n_basefuncs
            φⱼ = shape_value(cellvalues_v, q_point, j)</code></pre><p>Note that in Tensors.jl the definition <span>$\textrm{grad} v = \nabla v$</span> holds. With this information it can be quickly shown in index notation that</p><p class="math-container">\[[(v \cdot \nabla) v]_{\textrm{i}} = v_{\textrm{j}} (\partial_{\textrm{j}} v_{\textrm{i}}) = [v (\nabla v)^{\textrm{T}}]_{\textrm{i}}\]</p><p>where we should pay attentation to the transpose of the gradient.</p><pre><code class="language-julia hljs">            dvₑ[j] -= v ⋅ ∇v&#39; ⋅ φⱼ * dΩ
        end
    end
    return
end

function navierstokes!(du, u_uc, p::RHSparams, t)</code></pre><p>Unpack the struct to save some allocations.</p><pre><code class="language-julia hljs">    @unpack K, ch, dh, cellvalues_v, u = p</code></pre><p>We start by applying the time-dependent Dirichlet BCs. Note that we are not allowed to mutate <code>u_uc</code>! Furthermore not that we also can not pre- allocate a buffer for this variable variable if we want to use AD to derive the Jacobian matrix, which appears in stiff solvers. Therefore, for efficiency reasons, we simply pass down the jacobian analytically.</p><pre><code class="language-julia hljs">    u .= u_uc
    update!(ch, t)
    apply!(u, ch)</code></pre><p>Now we apply the rhs of the Navier-Stokes equations</p><pre><code class="language-julia hljs">    # Linear contribution (Stokes operator)
    mul!(du, K, u) # du .= K * u

    # nonlinear contribution
    v_range = dof_range(dh, :v)
    n_basefuncs = getnbasefunctions(cellvalues_v)
    vₑ = zeros(n_basefuncs)
    duₑ = zeros(n_basefuncs)
    for cell in CellIterator(dh)
        Ferrite.reinit!(cellvalues_v, cell)
        v_celldofs = @view celldofs(cell)[v_range]
        vₑ .= @views u[v_celldofs]
        fill!(duₑ, 0.0)
        navierstokes_rhs_element!(duₑ, vₑ, cellvalues_v)
        assemble!(du, v_celldofs, duₑ)
    end
    return
end;

function navierstokes_jac_element!(Jₑ, vₑ, cellvalues_v)
    n_basefuncs = getnbasefunctions(cellvalues_v)
    for q_point in 1:getnquadpoints(cellvalues_v)
        dΩ = getdetJdV(cellvalues_v, q_point)
        ∇v = function_gradient(cellvalues_v, q_point, vₑ)
        v = function_value(cellvalues_v, q_point, vₑ)
        for j in 1:n_basefuncs
            φⱼ = shape_value(cellvalues_v, q_point, j)</code></pre><p>Note that in Tensors.jl the definition <span>$\textrm{grad} v = \nabla v$</span> holds. With this information it can be quickly shown in index notation that</p><p class="math-container">\[[(v \cdot \nabla) v]_{\textrm{i}} = v_{\textrm{j}} (\partial_{\textrm{j}} v_{\textrm{i}}) = [v (\nabla v)^{\textrm{T}}]_{\textrm{i}}\]</p><p>where we should pay attentation to the transpose of the gradient.</p><pre><code class="language-julia hljs">            for i in 1:n_basefuncs
                φᵢ = shape_value(cellvalues_v, q_point, i)
                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)
                Jₑ[j, i] -= (φᵢ ⋅ ∇v&#39; + v ⋅ ∇φᵢ&#39;) ⋅ φⱼ * dΩ
            end
        end
    end
    return
end

function navierstokes_jac!(J, u_uc, p, t)</code></pre><p>Unpack the struct to save some allocations.</p><pre><code class="language-julia hljs">    @unpack K, ch, dh, cellvalues_v, u = p</code></pre><p>We start by applying the time-dependent Dirichlet BCs. Note that we are not allowed to mutate <code>u_uc</code>, so we use our buffer again.</p><pre><code class="language-julia hljs">    u .= u_uc
    update!(ch, t)
    apply!(u, ch)</code></pre><p>Now we apply the Jacobian of the Navier-Stokes equations.</p><pre><code class="language-julia hljs">    # Linear contribution (Stokes operator)
    # Here we assume that J has exactly the same structure as K by construction
    nonzeros(J) .= nonzeros(K)

    assembler = start_assemble(J; fillzero = false)

    # Assemble variation of the nonlinear term
    n_basefuncs = getnbasefunctions(cellvalues_v)
    Jₑ = zeros(n_basefuncs, n_basefuncs)
    vₑ = zeros(n_basefuncs)
    v_range = dof_range(dh, :v)
    for cell in CellIterator(dh)
        Ferrite.reinit!(cellvalues_v, cell)
        v_celldofs = @view celldofs(cell)[v_range]

        vₑ .= @views u[v_celldofs]
        fill!(Jₑ, 0.0)
        navierstokes_jac_element!(Jₑ, vₑ, cellvalues_v)
        assemble!(assembler, v_celldofs, Jₑ)
    end</code></pre><p>Finally we eliminate the constrained dofs from the Jacobian to decouple them in the nonlinear solver from the remaining system.</p><pre><code class="language-julia hljs">    return apply!(J, ch)
end;</code></pre><p>Finally, together with our pre-assembled mass matrix, we are now able to define our problem in mass matrix form.</p><pre><code class="language-julia hljs">rhs = ODEFunction(navierstokes!, mass_matrix = M; jac = navierstokes_jac!, jac_prototype = jac_sparsity)
problem = ODEProblem(rhs, u₀, (0.0, T), p);</code></pre><p>All norms must not depend on constrained dofs. A problem with the presented implementation is that we are currently unable to strictly enforce constraint everywhere in the internal time integration process of <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>, hence the values might differ, resulting in worse error estimates. We try to resolve this issue in the future. Volunteers are also welcome to take a look into this!</p><pre><code class="language-julia hljs">struct FreeDofErrorNorm
    ch::ConstraintHandler
end
(fe_norm::FreeDofErrorNorm)(u::Union{AbstractFloat, Complex}, t) = DiffEqBase.ODE_DEFAULT_NORM(u, t)
(fe_norm::FreeDofErrorNorm)(u::AbstractArray, t) = DiffEqBase.ODE_DEFAULT_NORM(u[fe_norm.ch.free_dofs], t)</code></pre><p>Now we can put everything together by specifying how to solve the problem. We want to use an adaptive variant of the implicit Euler method. Further we enable the progress bar with the <code>progress</code> and <code>progress_steps</code> arguments. Finally we have to communicate the time step length and initialization algorithm. Since we start with a valid initial state we do not use one of DifferentialEquations.jl initialization algorithms.</p><div class="admonition is-info"><header class="admonition-header">DAE initialization</header><div class="admonition-body"><p>At the time of writing this <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1019">no Hessenberg index 2 initialization is implemented</a>.</p></div></div><p>To visualize the result we export the grid and our fields to VTK-files, which can be viewed in <a href="https://www.paraview.org/">ParaView</a> by utilizing the corresponding pvd file.</p><pre><code class="language-julia hljs">timestepper = Rodas5P(autodiff = false, step_limiter! = ferrite_limiter!);</code></pre><div class="admonition is-info"><header class="admonition-header">Debugging convergence issues</header><div class="admonition-body"><p>We can obtain some debug information from OrdinaryDiffEq by wrapping the following section into a <a href="https://docs.julialang.org/en/v1/stdlib/Logging/#Example:-Enable-debug-level-messages">debug logger</a>.</p></div></div><pre><code class="language-julia hljs">integrator = init(
    problem, timestepper; initializealg = NoInit(), dt = Δt₀,
    adaptive = true, abstol = 1.0e-4, reltol = 1.0e-5,
    progress = true, progress_steps = 1,
    verbose = true, internalnorm = FreeDofErrorNorm(ch), d_discontinuities = [1.0]
);</code></pre><div class="admonition is-info"><header class="admonition-header">Export of solution</header><div class="admonition-body"><p>Exporting interpolated solutions of problems containing mass matrices is currently broken. Thus, the <code>intervals</code> iterator is used. Note that <code>solve</code> holds all solutions in the memory.</p></div></div><pre><code class="language-julia hljs">pvd = paraview_collection(&quot;vortex-street&quot;)
for (step, (u, t)) in enumerate(intervals(integrator))
    VTKGridFile(&quot;vortex-street-$step&quot;, dh) do vtk
        write_solution(vtk, dh, u)
        pvd[t] = vtk
    end
end
vtk_save(pvd);</code></pre><h2 id="ns_vs_diffeq-plain-program"><a class="docs-heading-anchor" href="#ns_vs_diffeq-plain-program">Plain program</a><a id="ns_vs_diffeq-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#ns_vs_diffeq-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../ns_vs_diffeq.jl"><code>ns_vs_diffeq.jl</code></a>.</p><pre><code class="language-julia hljs">using Ferrite, SparseArrays, BlockArrays, LinearAlgebra, UnPack, LinearSolve, WriteVTK

using OrdinaryDiffEq

ν = 1.0 / 1000.0; #dynamic viscosity

using FerriteGmsh
using FerriteGmsh: Gmsh
Gmsh.initialize()
gmsh.option.set_number(&quot;General.Verbosity&quot;, 2)
dim = 2;

rect_tag = gmsh.model.occ.add_rectangle(0, 0, 0, 1.1, 0.41)
circle_tag = gmsh.model.occ.add_circle(0.2, 0.2, 0, 0.05)
circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])
circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])
gmsh.model.occ.cut([(dim, rect_tag)], [(dim, circle_surf_tag)])

gmsh.model.occ.synchronize()

bottomtag = gmsh.model.model.add_physical_group(dim - 1, [6], -1, &quot;bottom&quot;)
lefttag = gmsh.model.model.add_physical_group(dim - 1, [7], -1, &quot;left&quot;)
righttag = gmsh.model.model.add_physical_group(dim - 1, [8], -1, &quot;right&quot;)
toptag = gmsh.model.model.add_physical_group(dim - 1, [9], -1, &quot;top&quot;)
holetag = gmsh.model.model.add_physical_group(dim - 1, [5], -1, &quot;hole&quot;)

gmsh.option.setNumber(&quot;Mesh.Algorithm&quot;, 11)
gmsh.option.setNumber(&quot;Mesh.MeshSizeFromCurvature&quot;, 20)
gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, 0.05)

gmsh.model.mesh.generate(dim)
grid = togrid()
Gmsh.finalize();

ip_v = Lagrange{RefQuadrilateral, 2}()^dim
qr = QuadratureRule{RefQuadrilateral}(4)
cellvalues_v = CellValues(qr, ip_v);

ip_p = Lagrange{RefQuadrilateral, 1}()
cellvalues_p = CellValues(qr, ip_p);

dh = DofHandler(grid)
add!(dh, :v, ip_v)
add!(dh, :p, ip_p)
close!(dh);

ch = ConstraintHandler(dh);

nosplip_facet_names = [&quot;top&quot;, &quot;bottom&quot;, &quot;hole&quot;];
∂Ω_noslip = union(getfacetset.((grid,), nosplip_facet_names)...);
noslip_bc = Dirichlet(:v, ∂Ω_noslip, (x, t) -&gt; Vec((0.0, 0.0)), [1, 2])
add!(ch, noslip_bc);

∂Ω_inflow = getfacetset(grid, &quot;left&quot;);

vᵢₙ(t) = min(t * 1.5, 1.5) #inflow velocity

parabolic_inflow_profile(x, t) = Vec((4 * vᵢₙ(t) * x[2] * (0.41 - x[2]) / 0.41^2, 0.0))
inflow_bc = Dirichlet(:v, ∂Ω_inflow, parabolic_inflow_profile, [1, 2])
add!(ch, inflow_bc);

∂Ω_free = getfacetset(grid, &quot;right&quot;);

close!(ch)
update!(ch, 0.0);

function assemble_mass_matrix(cellvalues_v::CellValues, cellvalues_p::CellValues, M::SparseMatrixCSC, dh::DofHandler)
    # Allocate a buffer for the local matrix and some helpers, together with the assembler.
    n_basefuncs_v = getnbasefunctions(cellvalues_v)
    n_basefuncs_p = getnbasefunctions(cellvalues_p)
    n_basefuncs = n_basefuncs_v + n_basefuncs_p
    v▄, p▄ = 1, 2
    Mₑ = BlockedArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])

    # It follows the assembly loop as explained in the basic tutorials.
    mass_assembler = start_assemble(M)
    for cell in CellIterator(dh)
        fill!(Mₑ, 0)
        Ferrite.reinit!(cellvalues_v, cell)

        for q_point in 1:getnquadpoints(cellvalues_v)
            dΩ = getdetJdV(cellvalues_v, q_point)
            # Remember that we assemble a vector mass term, hence the dot product.
            # There is only one time derivative on the left hand side, so only one mass block is non-zero.
            for i in 1:n_basefuncs_v
                φᵢ = shape_value(cellvalues_v, q_point, i)
                for j in 1:n_basefuncs_v
                    φⱼ = shape_value(cellvalues_v, q_point, j)
                    Mₑ[BlockIndex((v▄, v▄), (i, j))] += φᵢ ⋅ φⱼ * dΩ
                end
            end
        end
        assemble!(mass_assembler, celldofs(cell), Mₑ)
    end

    return M
end;

function assemble_stokes_matrix(cellvalues_v::CellValues, cellvalues_p::CellValues, ν, K::SparseMatrixCSC, dh::DofHandler)
    # Again, some buffers and helpers
    n_basefuncs_v = getnbasefunctions(cellvalues_v)
    n_basefuncs_p = getnbasefunctions(cellvalues_p)
    n_basefuncs = n_basefuncs_v + n_basefuncs_p
    v▄, p▄ = 1, 2
    Kₑ = BlockedArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])

    # Assembly loop
    stiffness_assembler = start_assemble(K)
    for cell in CellIterator(dh)
        # Don&#39;t forget to initialize everything
        fill!(Kₑ, 0)

        Ferrite.reinit!(cellvalues_v, cell)
        Ferrite.reinit!(cellvalues_p, cell)

        for q_point in 1:getnquadpoints(cellvalues_v)
            dΩ = getdetJdV(cellvalues_v, q_point)

            for i in 1:n_basefuncs_v
                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)
                for j in 1:n_basefuncs_v
                    ∇φⱼ = shape_gradient(cellvalues_v, q_point, j)
                    Kₑ[BlockIndex((v▄, v▄), (i, j))] -= ν * ∇φᵢ ⊡ ∇φⱼ * dΩ
                end
            end

            for j in 1:n_basefuncs_p
                ψ = shape_value(cellvalues_p, q_point, j)
                for i in 1:n_basefuncs_v
                    divφ = shape_divergence(cellvalues_v, q_point, i)
                    Kₑ[BlockIndex((v▄, p▄), (i, j))] += (divφ * ψ) * dΩ
                    Kₑ[BlockIndex((p▄, v▄), (j, i))] += (ψ * divφ) * dΩ
                end
            end
        end

        # Assemble `Kₑ` into the Stokes matrix `K`.
        assemble!(stiffness_assembler, celldofs(cell), Kₑ)
    end
    return K
end;

T = 6.0
Δt₀ = 0.001
Δt_save = 0.1

M = allocate_matrix(dh);
M = assemble_mass_matrix(cellvalues_v, cellvalues_p, M, dh);

K = allocate_matrix(dh);
K = assemble_stokes_matrix(cellvalues_v, cellvalues_p, ν, K, dh);

u₀ = zeros(ndofs(dh))
apply!(u₀, ch);

jac_sparsity = sparse(K);

apply!(M, ch)

struct RHSparams
    K::SparseMatrixCSC
    ch::ConstraintHandler
    dh::DofHandler
    cellvalues_v::CellValues
    u::Vector
end
p = RHSparams(K, ch, dh, cellvalues_v, copy(u₀))

function ferrite_limiter!(u, _, p, t)
    update!(p.ch, t)
    return apply!(u, p.ch)
end

function navierstokes_rhs_element!(dvₑ, vₑ, cellvalues_v)
    n_basefuncs = getnbasefunctions(cellvalues_v)
    for q_point in 1:getnquadpoints(cellvalues_v)
        dΩ = getdetJdV(cellvalues_v, q_point)
        ∇v = function_gradient(cellvalues_v, q_point, vₑ)
        v = function_value(cellvalues_v, q_point, vₑ)
        for j in 1:n_basefuncs
            φⱼ = shape_value(cellvalues_v, q_point, j)

            dvₑ[j] -= v ⋅ ∇v&#39; ⋅ φⱼ * dΩ
        end
    end
    return
end

function navierstokes!(du, u_uc, p::RHSparams, t)

    @unpack K, ch, dh, cellvalues_v, u = p

    u .= u_uc
    update!(ch, t)
    apply!(u, ch)

    # Linear contribution (Stokes operator)
    mul!(du, K, u) # du .= K * u

    # nonlinear contribution
    v_range = dof_range(dh, :v)
    n_basefuncs = getnbasefunctions(cellvalues_v)
    vₑ = zeros(n_basefuncs)
    duₑ = zeros(n_basefuncs)
    for cell in CellIterator(dh)
        Ferrite.reinit!(cellvalues_v, cell)
        v_celldofs = @view celldofs(cell)[v_range]
        vₑ .= @views u[v_celldofs]
        fill!(duₑ, 0.0)
        navierstokes_rhs_element!(duₑ, vₑ, cellvalues_v)
        assemble!(du, v_celldofs, duₑ)
    end
    return
end;

function navierstokes_jac_element!(Jₑ, vₑ, cellvalues_v)
    n_basefuncs = getnbasefunctions(cellvalues_v)
    for q_point in 1:getnquadpoints(cellvalues_v)
        dΩ = getdetJdV(cellvalues_v, q_point)
        ∇v = function_gradient(cellvalues_v, q_point, vₑ)
        v = function_value(cellvalues_v, q_point, vₑ)
        for j in 1:n_basefuncs
            φⱼ = shape_value(cellvalues_v, q_point, j)

            for i in 1:n_basefuncs
                φᵢ = shape_value(cellvalues_v, q_point, i)
                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)
                Jₑ[j, i] -= (φᵢ ⋅ ∇v&#39; + v ⋅ ∇φᵢ&#39;) ⋅ φⱼ * dΩ
            end
        end
    end
    return
end

function navierstokes_jac!(J, u_uc, p, t)

    @unpack K, ch, dh, cellvalues_v, u = p

    u .= u_uc
    update!(ch, t)
    apply!(u, ch)

    # Linear contribution (Stokes operator)
    # Here we assume that J has exactly the same structure as K by construction
    nonzeros(J) .= nonzeros(K)

    assembler = start_assemble(J; fillzero = false)

    # Assemble variation of the nonlinear term
    n_basefuncs = getnbasefunctions(cellvalues_v)
    Jₑ = zeros(n_basefuncs, n_basefuncs)
    vₑ = zeros(n_basefuncs)
    v_range = dof_range(dh, :v)
    for cell in CellIterator(dh)
        Ferrite.reinit!(cellvalues_v, cell)
        v_celldofs = @view celldofs(cell)[v_range]

        vₑ .= @views u[v_celldofs]
        fill!(Jₑ, 0.0)
        navierstokes_jac_element!(Jₑ, vₑ, cellvalues_v)
        assemble!(assembler, v_celldofs, Jₑ)
    end

    return apply!(J, ch)
end;

rhs = ODEFunction(navierstokes!, mass_matrix = M; jac = navierstokes_jac!, jac_prototype = jac_sparsity)
problem = ODEProblem(rhs, u₀, (0.0, T), p);

struct FreeDofErrorNorm
    ch::ConstraintHandler
end
(fe_norm::FreeDofErrorNorm)(u::Union{AbstractFloat, Complex}, t) = DiffEqBase.ODE_DEFAULT_NORM(u, t)
(fe_norm::FreeDofErrorNorm)(u::AbstractArray, t) = DiffEqBase.ODE_DEFAULT_NORM(u[fe_norm.ch.free_dofs], t)

timestepper = Rodas5P(autodiff = false, step_limiter! = ferrite_limiter!);

integrator = init(
    problem, timestepper; initializealg = NoInit(), dt = Δt₀,
    adaptive = true, abstol = 1.0e-4, reltol = 1.0e-5,
    progress = true, progress_steps = 1,
    verbose = true, internalnorm = FreeDofErrorNorm(ch), d_discontinuities = [1.0]
);

pvd = paraview_collection(&quot;vortex-street&quot;)
for (step, (u, t)) in enumerate(intervals(integrator))
    VTKGridFile(&quot;vortex-street-$step&quot;, dh) do vtk
        write_solution(vtk, dh, u)
        pvd[t] = vtk
    end
end
vtk_save(pvd);</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../porous_media/">« Porous media</a><a class="docs-footer-nextpage" href="../reactive_surface/">Reactive surface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 5 May 2025 09:09">Monday 5 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
