<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Initial and Boundary Conditions · Ferrite.jl</title><meta name="title" content="Initial and Boundary Conditions · Ferrite.jl"/><meta property="og:title" content="Initial and Boundary Conditions · Ferrite.jl"/><meta property="twitter:title" content="Initial and Boundary Conditions · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/manual/boundary_conditions/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/manual/boundary_conditions/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/manual/boundary_conditions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.048/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs (Ctrl + /)"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../fe_intro/">Introduction to FEM</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li class="is-active"><a class="tocitem" href>Initial and Boundary Conditions</a><ul class="internal"><li><a class="tocitem" href="#Dirichlet-Boundary-Conditions"><span>Dirichlet Boundary Conditions</span></a></li><li><a class="tocitem" href="#Neumann-Boundary-Conditions"><span>Neumann Boundary Conditions</span></a></li><li><a class="tocitem" href="#Periodic-boundary-conditions"><span>Periodic boundary conditions</span></a></li><li><a class="tocitem" href="#Initial-Conditions"><span>Initial Conditions</span></a></li></ul></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../export/">Export</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../overview/">Documentation of examples</a></li><li><a class="tocitem" href="../../examples/heat_equation/">Heat Equation</a></li><li><a class="tocitem" href="../../examples/postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../../examples/helmholtz/">Helmholtz equation</a></li><li><a class="tocitem" href="../../examples/incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="tocitem" href="../../examples/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../examples/threaded_assembly/">Threaded Assembly</a></li><li><a class="tocitem" href="../../examples/plasticity/">von Mises plasticity</a></li><li><a class="tocitem" href="../../examples/transient_heat_equation/">Time Dependent Problems</a></li><li><a class="tocitem" href="../../examples/landau/">Ginzburg-Landau model energy minimization</a></li><li><a class="tocitem" href="../../examples/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../examples/quasi_incompressible_hyperelasticity/">Nearly Incompressible Hyperelasticity</a></li><li><a class="tocitem" href="../../examples/ns_vs_diffeq/">Incompressible Navier-Stokes Equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../examples/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../examples/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../examples/topology_optimization/">Topology optimization</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Initial and Boundary Conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Initial and Boundary Conditions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/manual/boundary_conditions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Initial-and-Boundary-Conditions"><a class="docs-heading-anchor" href="#Initial-and-Boundary-Conditions">Initial and Boundary Conditions</a><a id="Initial-and-Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-and-Boundary-Conditions" title="Permalink"></a></h1><p>Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it <code>Ferrite</code>.</p><h2 id="Dirichlet-Boundary-Conditions"><a class="docs-heading-anchor" href="#Dirichlet-Boundary-Conditions">Dirichlet Boundary Conditions</a><a id="Dirichlet-Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-Boundary-Conditions" title="Permalink"></a></h2><p>At a Dirichlet boundary the unknown field is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To handle Dirichlet boundary conditions in Ferrite we use the <a href="../../reference/boundary_conditions/#Ferrite.ConstraintHandler"><code>ConstraintHandler</code></a>. A constraint handler is created from a DoF handler:</p><pre><code class="language-julia hljs">ch = ConstraintHandler(dh)</code></pre><p>We can now create Dirichlet constraints and add them to the constraint handler. To create a Dirichlet constraint we need to specify a field name, a part of the boundary, and a function for computing the prescribed value. Example:</p><pre><code class="language-julia hljs">dbc1 = Dirichlet(
    :u,                       # Name of the field
    getfaceset(grid, &quot;left&quot;), # Part of the boundary
    x -&gt; 1.0,                 # Function mapping coordinate to a prescribed value
)</code></pre><p>The field name is given as a symbol, just like when the field was added to the dof handler, the part of the boundary where this constraint is active is given as a face set, and the function computing the prescribed value should be of the form <code>f(x)</code> or <code>f(x, t)</code> (coordinate <code>x</code> and time <code>t</code>) and return the prescribed value(s).</p><div class="admonition is-info"><header class="admonition-header">Multiple sets</header><div class="admonition-body"><p>To apply a constraint on multiple face sets in the grid you can use <code>union</code> to join them, for example</p><pre><code class="language-julia hljs">left_right = union(getfaceset(grid, &quot;left&quot;), getfaceset(grid, &quot;right&quot;))</code></pre><p>creates a new face set containing all faces in the <code>&quot;left&quot;</code> and &quot;<code>right</code>&quot; face sets, which can be passed to the <code>Dirichlet</code> constructor.</p></div></div><p>By default the constraint is added to all components of the given field. To add the constraint to selected components a fourth argument with the components should be passed to the constructor. Here is an example where a constraint is added to component 1 and 3 of a vector field <code>:u</code>:</p><pre><code class="language-julia hljs">dbc2 = Dirichlet(
    :u,                       # Name of the field
    getfaceset(grid, &quot;left&quot;), # Part of the boundary
    x -&gt; [0.0, 0.0],          # Function mapping coordinate to prescribed values
    [1, 3],                   # Components
)</code></pre><p>Note that the return value of the function must match with the components – in the example above we prescribe components 1 and 3 to 0 so we return a vector of length 2.</p><p>Adding the constraints to the constraint handler is done with <a href="../../reference/boundary_conditions/#Ferrite.add!"><code>add!</code></a>:</p><pre><code class="language-julia hljs">add!(ch, dbc1)
add!(ch, dbc2)</code></pre><p>Finally, just like for the dof handler, we need to use <a href="../../reference/boundary_conditions/#Ferrite.close!"><code>close!</code></a> to finalize the constraint handler. Internally this will then compute the degrees-of-freedom that match the constraints we added.</p><p>If one or more of the constraints depend on time, i.e. they are specified as <code>f(x, t)</code>, the prescribed values can be recomputed in each new time step by calling <a href="../../reference/boundary_conditions/#Ferrite.update!"><code>update!</code></a> with the proper time, e.g.:</p><pre><code class="language-julia hljs">for t in 0.0:0.1:1.0
    update!(ch, t) # Compute prescribed values for this t
    # Solve for time t...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>Most examples make use of Dirichlet boundary conditions, for example <a href="../../examples/heat_equation/#Heat-Equation">Heat Equation</a>.</p></div></div><h2 id="Neumann-Boundary-Conditions"><a class="docs-heading-anchor" href="#Neumann-Boundary-Conditions">Neumann Boundary Conditions</a><a id="Neumann-Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Neumann-Boundary-Conditions" title="Permalink"></a></h2><p>At the Neumann part of the boundary we know something about the gradient of the solution.</p><p>As an example, the following code snippet can be included in the element routine, to evaluate the boundary integral:</p><pre><code class="language-julia hljs">for face in 1:nfaces(cell)
    if (cellid(cell), face) ∈ getfaceset(grid, &quot;Neumann Boundary&quot;)
        reinit!(facevalues, cell, face)
        for q_point in 1:getnquadpoints(facevalues)
            dΓ = getdetJdV(facevalues, q_point)
            for i in 1:getnbasefunctions(facevalues)
                δu = shape_value(facevalues, q_point, i)
                fe[i] += δu * b * dΓ
            end
        end
    end
end</code></pre><p>We start by looping over all the faces of the cell, next we check if this particular face is located on our faceset of interest called <code>&quot;Neumann Boundary&quot;</code>. If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize <code>facevalues</code> for this face, using <a href="../../reference/fevalues/#Ferrite.reinit!"><code>reinit!</code></a>. When <code>reinit!</code>ing <code>facevalues</code> we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.</p><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>The following commented examples makes use of Neumann boundary conditions:</p><ul><li>TODO</li></ul></div></div><h2 id="Periodic-boundary-conditions"><a class="docs-heading-anchor" href="#Periodic-boundary-conditions">Periodic boundary conditions</a><a id="Periodic-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-boundary-conditions" title="Permalink"></a></h2><p>Periodic boundary conditions ensure that the solution is periodic across two boundaries. To define the periodicity we first define the image boundary <span>$\Gamma^+$</span> and the mirror boundary <span>$\Gamma^-$</span>. We also define a (unique) coordinate mapping between the image and the mirror: <span>$\varphi:\ \Gamma^+\, \rightarrow\, \Gamma^-$</span>. With the mapping we can, for every coordinate on the image, compute the corresponding coordinate on the mirror:</p><p class="math-container">\[\boldsymbol{x}^- = \varphi(\boldsymbol{x}^+),\quad \boldsymbol{x}^- \in \Gamma^-,\,
\boldsymbol{x}^+ \in \Gamma^+.\]</p><p>We now want to ensure that the solution on the image <span>$\Gamma^+$</span> is mirrored on the mirror <span>$\Gamma^-$</span>. This periodicity constraint can thus be described by</p><p class="math-container">\[u(\boldsymbol{x}^-) = u(\boldsymbol{x}^+).\]</p><p>Sometimes this is written as</p><p class="math-container">\[\llbracket u \rrbracket = 0,\]</p><p>where <span>$\llbracket \bullet \rrbracket := \bullet(\boldsymbol{x}^+) - \bullet(\boldsymbol{x}^-)$</span> is the &quot;jump operator&quot;. Thus, this condition ensure that the jump, or difference, in the solution between the image and mirror boundary is the zero – the solution becomes periodic. For a vector valued problem the periodicity constraint can in general be written as</p><p class="math-container">\[\boldsymbol{u}(\boldsymbol{x}^-) = \boldsymbol{R} \cdot \boldsymbol{u}(\boldsymbol{x}^+)
\quad \Leftrightarrow \quad \llbracket \boldsymbol{u} \rrbracket =
\boldsymbol{R} \cdot \boldsymbol{u}(\boldsymbol{x}^+) - \boldsymbol{u}(\boldsymbol{x}^-) =
\boldsymbol{0}\]</p><p>where <span>$\boldsymbol{R}$</span> is a rotation matrix. If the mapping between mirror and image is simply a translation (e.g. sides of a cube) this matrix will be the identity matrix.</p><p>In <code>Ferrite</code> this type of periodic Dirichlet boundary conditions can be added to the <code>ConstraintHandler</code> by constructing an instance of <a href="../../reference/boundary_conditions/#Ferrite.PeriodicDirichlet"><code>PeriodicDirichlet</code></a>. This is usually done it two steps. First we compute the mapping between mirror and image faces using <a href="../../reference/boundary_conditions/#Ferrite.collect_periodic_faces"><code>collect_periodic_faces</code></a>. Here we specify the mirror set and image sets (the sets are usually known or can be constructed easily ) and the mapping <span>$\varphi$</span>. Second we construct the constraint using the <code>PeriodicDirichlet</code> constructor. Here we specify which components of the function that should be constrained, and the rotation matrix <span>$\boldsymbol{R}$</span> (when needed). When adding the constraint to the <code>ConstraintHandler</code> the resulting dof-mapping is computed.</p><p>Here is a simple example where periodicity is enforced for components 1 and 2 of the field <code>:u</code> between the mirror boundary set <code>&quot;left&quot;</code> and the image boundary set <code>&quot;right&quot;</code>. Note that no rotation matrix is needed here since the mirror and image are parallel, just shifted in the <span>$x$</span>-direction (as seen by the mapping <code>φ</code>):</p><pre><code class="language-julia hljs"># Create a constraint handler from the dof handler
ch = ConstraintHandler(dofhandler)

# Compute the face mapping
φ(x) = x - Vec{2}((1.0, 0.0))
face_mapping = collect_periodic_faces(grid, &quot;left&quot;, &quot;right&quot;, φ)

# Construct the periodic constraint for field :u
pdbc = PeriodicDirichlet(:u, face_mapping, [1, 2])

# Add the constraint to the constraint handler
add!(ch, pdbc)

# If no more constraints should be added we can close
close!(ch)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>PeriodicDirichlet</code> constraints are imposed in a strong sense, so note that this requires a periodic mesh such that it is possible to compute the face mapping between faces on the mirror and boundary.</p></div></div><div class="admonition is-info"><header class="admonition-header">Examples</header><div class="admonition-body"><p>Periodic boundary conditions are used in the following examples <a href="../../examples/computational_homogenization/#Computational-homogenization">Computational homogenization</a>, <a href="../../examples/stokes-flow/#Stokes-flow">Stokes flow</a>.</p></div></div><h4 id="Heterogeneous-&quot;periodic&quot;-constraint"><a class="docs-heading-anchor" href="#Heterogeneous-&quot;periodic&quot;-constraint">Heterogeneous &quot;periodic&quot; constraint</a><a id="Heterogeneous-&quot;periodic&quot;-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Heterogeneous-&quot;periodic&quot;-constraint" title="Permalink"></a></h4><p>It is also possible to define constraints of the form</p><p class="math-container">\[\llbracket u \rrbracket = \llbracket f \rrbracket
\quad \Leftrightarrow \quad
u(\boldsymbol{x}^+) - u(\boldsymbol{x}^-) =
f(\boldsymbol{x}^+) - f(\boldsymbol{x}^-),\]</p><p>where <span>$f$</span> is a prescribed function. Although the constraint in this case is not technically periodic, <code>PeriodicDirichlet</code> can be used for this too. This is done by passing a function to <code>PeriodicDirichlet</code>, similar to <code>Dirichlet</code>, which, given the coordinate <span>$\boldsymbol{x}$</span> and time <code>t</code>, computes the prescribed values of <span>$f$</span> on the boundary.</p><p>Here is an example of how to implement this type of boundary condition, for a known function <code>f</code>:</p><pre><code class="language-julia hljs">pdbc = PeriodicDirichlet(
    :u,
    face_mapping,
    (x, t) -&gt; f(x),
    [1, 2],
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One application for this type of boundary conditions is multiscale modeling and computational homogenization when solving the finite element problem for the subscale. In this case the unknown <span>$u$</span> is split into a macroscopic part <span>$u^{\mathrm{M}}$</span> and a microscopic/fluctuation part <span>$u^\mu$</span>, i.e. <span>$u = u^{\mathrm{M}} + u^{\mu}$</span>. Periodicity is then usually enforced for the fluctuation part, i.e. <span>$\llbracket u^\mu \rrbracket = 0$</span>. The equivalent constraint for <span>$u$</span> then becomes <span>$\llbracket u \rrbracket = \llbracket u^{\mathrm{M}} \rrbracket$</span>.</p><p>As an example, consider first order homogenization where the macroscopic part is constructed as <span>$u^{\mathrm{M}} = \bar{u} + \boldsymbol{\nabla} \bar{u} \cdot [\boldsymbol{x} - \bar{\boldsymbol{x}}]$</span> for known <span>$\bar{u}$</span> and <span>$\boldsymbol{\nabla} \bar{u}$</span>. This could be implemented as</p><pre><code class="language-julia hljs">pdbc = PeriodicDirichlet(
    :u,
    face_mapping,
    (x, t) -&gt; ū + ∇ū  ⋅ (x - x̄)
)</code></pre></div></div><h2 id="Initial-Conditions"><a class="docs-heading-anchor" href="#Initial-Conditions">Initial Conditions</a><a id="Initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Conditions" title="Permalink"></a></h2><p>When solving time-dependent problems, initial conditions, different from zero, may be required.  For finite element formulations of ODE-type,  i.e. <span>$\boldsymbol{u}&#39;(t) = \boldsymbol{f}(\boldsymbol{u}(t),t)$</span>,  where <span>$\boldsymbol{u}(t)$</span> are the degrees of freedom, initial conditions can be specified by the <a href="../../reference/boundary_conditions/#Ferrite.apply_analytical!"><code>apply_analytical!</code></a> function. For example, specify the initial pressure as a function of the y-coordinate</p><pre><code class="language-julia hljs">ρ = 1000; g = 9.81    # density [kg/m³] and gravity [N/kg]
grid = generate_grid(Quadrilateral, (10,10))
dh = DofHandler(grid); add!(dh, :u, 2); add!(dh, :p, 1); close!(dh)
u = zeros(ndofs(dh))
apply_analytical!(u, dh, :p, x -&gt; ρ * g * x[2])</code></pre><p>See also <a href="../../examples/transient_heat_equation/#Time-Dependent-Problems">Time Dependent Problems</a> for one example.</p><div class="admonition is-info"><header class="admonition-header">Consistency</header><div class="admonition-body"><p><code>apply_analytical!</code> does not enforce consistency of the applied solution with the system of  equations. Some problems, like for example differential-algebraic systems of equations (DAEs) need extra care during initialization. We refer to the paper <a href="manual/dx.doi.org/10.1137/S1064827595289996">&quot;Consistent Initial Condition Calculation for Differential-Algebraic Systems&quot;  by Brown et al.</a> for more details on this matter.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../assembly/">« Assembly</a><a class="docs-footer-nextpage" href="../constraints/">Constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Thursday 23 March 2023 11:38">Thursday 23 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
