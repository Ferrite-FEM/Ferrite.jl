var documenterSearchIndex = {"docs":
[{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/incompressible_elasticity.jl\"","category":"page"},{"location":"examples/incompressible_elasticity/#Incompressible-Elasticity","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: incompressible_elasticity.ipynb","category":"page"},{"location":"examples/incompressible_elasticity/#Introduction","page":"Incompressible Elasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Mixed elements can be used to overcome locking when the material becomes incompressible. However, for an element to be stable, it needs to fulfill the LBB condition. In this example we will consider two different element formulations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"linear displacement with linear pressure approximation (does not fulfill LBB)\nquadratic displacement with linear pressure approximation (does fulfill LBB)","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The quadratic/linear element is also known as the Taylor-Hood element. We will consider Cook's Membrane with an applied traction on the right hand side.","category":"page"},{"location":"examples/incompressible_elasticity/#Commented-Program","page":"Incompressible Elasticity","title":"Commented Program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing BlockArrays, SparseArrays, LinearAlgebra","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"First we generate a simple grid, specifying the 4 corners of Cooks membrane.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Next we define a function to set up our cell- and facevalues.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We create a DofHandler, with two fields, :u and :p, with possibly different interpolations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We also need to add Dirichlet boundary conditions on the \"clamped\" faceset. We specify a homogeneous Dirichlet bc on the displacement field, :u.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The material is linear elastic, which is here specified by the shear and bulk moduli","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct LinearElasticity{T}\n    G::T\n    K::T\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Now to the assembling of the stiffness matrix. This mixed formulation leads to a blocked element matrix. Since Ferrite does not force us to use any particular matrix type we will use a PseudoBlockArray from BlockArrays.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function doassemble(cellvalues_u::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim},\n                    facevalues_u::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, mp::LinearElasticity) where {dim}\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    # traction vector\n    t = Vec{2}((0.0, 1/16))\n    # cache ɛdev outside the element routine to avoid some unnecessary allocations\n    ɛdev = [zero(SymmetricTensor{2, dim}) for i in 1:getnbasefunctions(cellvalues_u)]\n\n    for cell in CellIterator(dh)\n        fill!(ke, 0)\n        fill!(fe, 0)\n        assemble_up!(ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n        assemble!(assembler, celldofs(cell), fe, ke)\n    end\n\n    return K, f\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The element routine integrates the local stiffness and force vector for all elements. Since the problem results in a symmetric matrix we choose to only assemble the lower part, and then symmetrize it after the loop over the quadrature points.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function assemble_up!(Ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    u▄, p▄ = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    @inbounds for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ɛdev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            divδu = shape_divergence(cellvalues_u, q_point, i)\n            δu = shape_value(cellvalues_u, q_point, i)\n            for j in 1:i\n                Ke[BlockIndex((u▄, u▄), (i, j))] += 2 * mp.G * ɛdev[i] ⊡ ɛdev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδu = shape_divergence(cellvalues_u, q_point, j)\n                Ke[BlockIndex((p▄, u▄), (i, j))] += -δp * divδu * dΩ\n            end\n            for j in 1:i\n                p = shape_value(cellvalues_p, q_point, j)\n                Ke[BlockIndex((p▄, p▄), (i, j))] += - 1/mp.K * δp * p * dΩ\n            end\n\n        end\n    end\n\n    symmetrize_lower!(Ke)\n\n    # We integrate the Neumann boundary using the facevalues.\n    # We loop over all the faces in the cell, then check if the face\n    # is in our `\"traction\"` faceset.\n    @inbounds for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"traction\")\n            reinit!(facevalues_u, cell, face)\n            for q_point in 1:getnquadpoints(facevalues_u)\n                dΓ = getdetJdV(facevalues_u, q_point)\n                for i in 1:n_basefuncs_u\n                    δu = shape_value(facevalues_u, q_point, i)\n                    fe[i] += (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Now we have constructed all the necessary components, we just need a function to put it all together.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function solve(ν, interpolation_u, interpolation_p)\n    # material\n    Emod = 1.\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    mp = LinearElasticity(Gmod, Kmod)\n\n    # grid, dofhandler, boundary condition\n    n = 50\n    grid = create_cook_grid(n, n)\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    dbc = create_bc(dh)\n\n    # cellvalues\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # assembly and solve\n    K = create_sparsity_pattern(dh);\n    K, f = doassemble(cellvalues_u, cellvalues_p, facevalues_u, K, grid, dh, mp);\n    apply!(K, f, dbc)\n    u = Symmetric(K) \\ f;\n\n    # export\n    filename = \"cook_\" * (isa(interpolation_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\") *\n                         \"_linear\"\n    vtk_grid(filename, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\n    return u\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"All that is left is to solve the problem. We choose a value of Poissons ratio that is near incompressibility – ν = 05 – and thus expect the linear/linear approximation to return garbage, and the quadratic/linear approximation to be stable.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"linear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\n\nu1 = solve(0.4999999, linear, linear)\nu2 = solve(0.4999999, quadratic, linear);\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#incompressible_elasticity-plain-program","page":"Incompressible Elasticity","title":"Plain Program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Below follows a version of the program without any comments. The file is also available here: incompressible_elasticity.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing BlockArrays, SparseArrays, LinearAlgebra\n\nfunction create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\n\nstruct LinearElasticity{T}\n    G::T\n    K::T\nend\n\nfunction doassemble(cellvalues_u::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim},\n                    facevalues_u::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, mp::LinearElasticity) where {dim}\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    # traction vector\n    t = Vec{2}((0.0, 1/16))\n    # cache ɛdev outside the element routine to avoid some unnecessary allocations\n    ɛdev = [zero(SymmetricTensor{2, dim}) for i in 1:getnbasefunctions(cellvalues_u)]\n\n    for cell in CellIterator(dh)\n        fill!(ke, 0)\n        fill!(fe, 0)\n        assemble_up!(ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n        assemble!(assembler, celldofs(cell), fe, ke)\n    end\n\n    return K, f\nend;\n\nfunction assemble_up!(Ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    u▄, p▄ = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    @inbounds for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ɛdev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            divδu = shape_divergence(cellvalues_u, q_point, i)\n            δu = shape_value(cellvalues_u, q_point, i)\n            for j in 1:i\n                Ke[BlockIndex((u▄, u▄), (i, j))] += 2 * mp.G * ɛdev[i] ⊡ ɛdev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδu = shape_divergence(cellvalues_u, q_point, j)\n                Ke[BlockIndex((p▄, u▄), (i, j))] += -δp * divδu * dΩ\n            end\n            for j in 1:i\n                p = shape_value(cellvalues_p, q_point, j)\n                Ke[BlockIndex((p▄, p▄), (i, j))] += - 1/mp.K * δp * p * dΩ\n            end\n\n        end\n    end\n\n    symmetrize_lower!(Ke)\n\n    # We integrate the Neumann boundary using the facevalues.\n    # We loop over all the faces in the cell, then check if the face\n    # is in our `\"traction\"` faceset.\n    @inbounds for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"traction\")\n            reinit!(facevalues_u, cell, face)\n            for q_point in 1:getnquadpoints(facevalues_u)\n                dΓ = getdetJdV(facevalues_u, q_point)\n                for i in 1:n_basefuncs_u\n                    δu = shape_value(facevalues_u, q_point, i)\n                    fe[i] += (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nfunction solve(ν, interpolation_u, interpolation_p)\n    # material\n    Emod = 1.\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    mp = LinearElasticity(Gmod, Kmod)\n\n    # grid, dofhandler, boundary condition\n    n = 50\n    grid = create_cook_grid(n, n)\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    dbc = create_bc(dh)\n\n    # cellvalues\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # assembly and solve\n    K = create_sparsity_pattern(dh);\n    K, f = doassemble(cellvalues_u, cellvalues_p, facevalues_u, K, grid, dh, mp);\n    apply!(K, f, dbc)\n    u = Symmetric(K) \\ f;\n\n    # export\n    filename = \"cook_\" * (isa(interpolation_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\") *\n                         \"_linear\"\n    vtk_grid(filename, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\n    return u\nend\n\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\n\nu1 = solve(0.4999999, linear, linear)\nu2 = solve(0.4999999, quadratic, linear);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/interpolations/#reference-interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"Interpolation\ngetnbasefunctions\ngetdim\ngetrefshape\ngetorder","category":"page"},{"location":"reference/interpolations/#Ferrite.Interpolation","page":"Interpolation","title":"Ferrite.Interpolation","text":"Interpolation{dim, ref_shape, order}()\n\nReturn an Interpolation of given dimension dim, reference shape (see see AbstractRefShape) ref_shape and order order. order corresponds to the highest order term in the polynomial. The interpolation is used to define shape functions to interpolate a function between nodes.\n\nThe following interpolations are implemented:\n\nLagrange{1,RefCube,1}\nLagrange{1,RefCube,2}\nLagrange{2,RefCube,1}\nLagrange{2,RefCube,2}\nLagrange{2,RefTetrahedron,1}\nLagrange{2,RefTetrahedron,2}\nLagrange{3,RefCube,1}\nSerendipity{2,RefCube,2}\nLagrange{3,RefTetrahedron,1}\nLagrange{3,RefTetrahedron,2}\n\nExamples\n\njulia> ip = Lagrange{2,RefTetrahedron,2}()\nFerrite.Lagrange{2,Ferrite.RefTetrahedron,2}()\n\njulia> getnbasefunctions(ip)\n6\n\n\n\n\n\n","category":"type"},{"location":"reference/interpolations/#Ferrite.getnbasefunctions","page":"Interpolation","title":"Ferrite.getnbasefunctions","text":"Return the number of base functions for an Interpolation or Values object.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getdim","page":"Interpolation","title":"Ferrite.getdim","text":"Return the dimension of an Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getrefshape","page":"Interpolation","title":"Ferrite.getrefshape","text":"Return the reference shape of an Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getorder","page":"Interpolation","title":"Ferrite.getorder","text":"Return the polynomial order of the Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/fevalues/#FEValues","page":"FEValues","title":"FEValues","text":"","category":"section"},{"location":"reference/fevalues/#reference-cellvalues","page":"FEValues","title":"CellValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CellValues\nreinit!\ngetnquadpoints\ngetdetJdV\n\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\n\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate","category":"page"},{"location":"reference/fevalues/#Ferrite.CellValues","page":"FEValues","title":"Ferrite.CellValues","text":"CellScalarValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\nCellVectorValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA CellValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. in the finite element cell. There are two different types of CellValues: CellScalarValues and CellVectorValues. As the names suggest, CellScalarValues utilizes scalar shape functions and CellVectorValues utilizes vectorial shape functions. For a scalar field, the CellScalarValues type should be used. For vector field, both subtypes can be used.\n\nArguments:\n\nT: an optional argument (default to Float64) to determine the type the internal data is stored as.\nquad_rule: an instance of a QuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of a Interpolation which is used to interpolate the geometry\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.reinit!","page":"FEValues","title":"Ferrite.reinit!","text":"reinit!(cv::CellValues, x::Vector)\nreinit!(bv::FaceValues, x::Vector, face::Int)\n\nUpdate the CellValues/FaceValues object for a cell or face with coordinates x. The derivatives of the shape functions, and the new integration weights are computed.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.getnquadpoints","page":"FEValues","title":"Ferrite.getnquadpoints","text":"getnquadpoints(fe_v::Values)\n\nReturn the number of quadrature points for the Values object.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.getdetJdV","page":"FEValues","title":"Ferrite.getdetJdV","text":"getdetJdV(fe_v::Values, q_point::Int)\n\nReturn the product between the determinant of the Jacobian and the quadrature point weight for the given quadrature point: det(J(mathbfx)) w_q\n\nThis value is typically used when one integrates a function on a finite element cell or face as\n\nintlimits_Omega f(mathbfx) d Omega approx sumlimits_q = 1^n_q f(mathbfx_q) det(J(mathbfx)) w_q intlimits_Gamma f(mathbfx) d Gamma approx sumlimits_q = 1^n_q f(mathbfx_q) det(J(mathbfx)) w_q\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_value","page":"FEValues","title":"Ferrite.shape_value","text":"shape_value(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the value of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_gradient","page":"FEValues","title":"Ferrite.shape_gradient","text":"shape_gradient(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_symmetric_gradient","page":"FEValues","title":"Ferrite.shape_symmetric_gradient","text":"shape_symmetric_gradient(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the symmetric gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_divergence","page":"FEValues","title":"Ferrite.shape_divergence","text":"shape_divergence(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the divergence of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_value","page":"FEValues","title":"Ferrite.function_value","text":"function_value(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the value of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe value of a scalar valued function is computed as u(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) u_i where u_i are the value of u in the nodes. For a vector valued function the value is calculated as mathbfu(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) mathbfu_i where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_gradient","page":"FEValues","title":"Ferrite.function_gradient","text":"function_scalar_gradient(fe_v::Values{dim}, q_point::Int, u::AbstractVector)\n\nCompute the gradient of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe gradient of a scalar function is computed as mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx) u_i where u_i are the nodal values of the function. For a vector valued function the gradient is computed as mathbfnabla mathbfu(mathbfx) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx) otimes mathbfu_i where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_symmetric_gradient","page":"FEValues","title":"Ferrite.function_symmetric_gradient","text":"function_symmetric_gradient(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the symmetric gradient of the function, see function_gradient. Return a SymmetricTensor.\n\nThe symmetric gradient of a scalar function is computed as left mathbfnabla  mathbfu(mathbfx_q) right^textsym =  sumlimits_i = 1^n  frac12 left mathbfnabla N_i (mathbfx_q) otimes mathbfu_i + mathbfu_i  otimes  mathbfnabla N_i (mathbfx_q) right where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_divergence","page":"FEValues","title":"Ferrite.function_divergence","text":"function_divergence(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the divergence of the vector valued function in a quadrature point.\n\nThe divergence of a vector valued functions in the quadrature point mathbfx_q) is computed as mathbfnabla cdot mathbfu(mathbfx_q) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx_q) cdot mathbfu_i where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.spatial_coordinate","page":"FEValues","title":"Ferrite.spatial_coordinate","text":"spatial_coordinate(fe_v::Values{dim}, q_point::Int, x::AbstractVector)\n\nCompute the spatial coordinate in a quadrature point. x contains the nodal coordinates of the cell.\n\nThe coordinate is computed, using the geometric interpolation, as mathbfx = sumlimits_i = 1^n M_i (mathbfx) mathbfhatx_i\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#reference-facevalues","page":"FEValues","title":"FaceValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"All of the methods for CellValues apply for FaceValues as well. In addition, there are some methods that are unique for FaecValues:","category":"page"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"FaceValues\ngetcurrentface","category":"page"},{"location":"reference/fevalues/#Ferrite.FaceValues","page":"FEValues","title":"Ferrite.FaceValues","text":"FaceScalarValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\nFaceVectorValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA FaceValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. on the faces of finite elements. There are two different types of FaceValues: FaceScalarValues and FaceVectorValues. As the names suggest, FaceScalarValues utilizes scalar shape functions and FaceVectorValues utilizes vectorial shape functions. For a scalar field, the FaceScalarValues type should be used. For vector field, both subtypes can be used.\n\nnote: Note\nThe quadrature rule for the face should be given with one dimension lower. I.e. for a 3D case, the quadrature rule should be in 2D.\n\nArguments:\n\nT: an optional argument to determine the type the internal data is stored as.\nquad_rule: an instance of a QuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of an Interpolation which is used to interpolate the geometry\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.getcurrentface","page":"FEValues","title":"Ferrite.getcurrentface","text":"getcurrentface(fv::FaceValues)\n\nReturn the current active face of the FaceValues object (from last reinit!).\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/assembly/#Assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"start_assemble\nassemble!\nend_assemble","category":"page"},{"location":"reference/assembly/#Ferrite.start_assemble","page":"Assembly","title":"Ferrite.start_assemble","text":"start_assemble([N=0]) -> Assembler\n\nCall before starting an assembly.\n\nReturns an Assembler type that is used to hold the intermediate data before an assembly is finished.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.assemble!","page":"Assembly","title":"Ferrite.assemble!","text":"assemble!(a, Ke, edof)\n\nAssembles the element matrix Ke into a.\n\n\n\n\n\nassemble!(g, ge, edof)\n\nAssembles the element residual ge into the global residual vector g.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.end_assemble","page":"Assembly","title":"Ferrite.end_assemble","text":"end_assemble(a::Assembler) -> K\n\nFinalizes an assembly. Returns a sparse matrix with the assembled values.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"create_sparsity_pattern\ncreate_symmetric_sparsity_pattern","category":"page"},{"location":"reference/assembly/#Ferrite.create_sparsity_pattern","page":"Assembly","title":"Ferrite.create_sparsity_pattern","text":"create_sparsity_pattern(dh::DofHandler)\n\nCreate the sparsity pattern corresponding to the degree of freedom numbering in the DofHandler. Return a SparseMatrixCSC with stored values in the correct places.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.create_symmetric_sparsity_pattern","page":"Assembly","title":"Ferrite.create_symmetric_sparsity_pattern","text":"create_symmetric_sparsity_pattern(dh::DofHandler)\n\nCreate the symmetric sparsity pattern corresponding to the degree of freedom numbering in the DofHandler by only considering the upper triangle of the matrix. Return a Symmetric{SparseMatrixCSC}.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/","page":"Export","title":"Export","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"reference/export/","page":"Export","title":"Export","text":"vtk_grid","category":"page"},{"location":"reference/export/#WriteVTK.vtk_grid","page":"Export","title":"WriteVTK.vtk_grid","text":"vtk_grid(vtm::MultiblockFile, [filename], griddata...; kwargs...)\n\nCreate new dataset file that is added to an existent multiblock file. The VTK grid is specified by the elements of griddata.\n\nIf the filename is not given, it is determined automatically from the filename of the vtm file and the number of existent blocks.\n\n\n\n\n\nvtk_grid(vtb::vtkBlock, [filename], griddata...; kwargs...)\n\nCreate new dataset file that is added to an existent VTKBlock. The VTK grid is specified by the elements of griddata.\n\nIf the filename is not given, it is determined automatically from the filename of the vtb file and the number of existent blocks.\n\n\n\n\n\nvtk_grid(filename, x::AbstractRange{T}, y::AbstractRange{T}, [z::AbstractRange{T}];\n         kwargs...)\n\nCreate image data (.vti) file.\n\nAlong each direction, the grid is specified in terms of an AbstractRange object.\n\nExamples\n\njulia> vtk = vtk_grid(\"abc\", 1:0.2:5, 2:1.:3, 4:1.:5)  # 3D dataset\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"abc\", 1:0.2:5, 2:1.:3)  # 2D dataset\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"def\",\n                      LinRange(0., 5., 10),\n                      LinRange(0., 2π, 16),\n                      LinRange(1., 10., 12))\nVTK file 'def.vti' (ImageData file, open)\n\n\n\n\n\n\nvtk_grid(filename::AbstractString,\n         x::AbstractVector{T}, y::AbstractVector{T}, [z::AbstractVector{T}];\n         kwargs...)\n\nCreate 2D or 3D rectilinear grid (.vtr) file.\n\nCoordinates are specified by separate vectors x, y, z.\n\nExamples\n\njulia> vtk = vtk_grid(\"abc\", [0., 0.2, 0.5], collect(-2.:0.2:3), [1., 2.1, 2.3])\nVTK file 'abc.vtr' (RectilinearGrid file, open)\n\n\n\n\n\nvtk_grid(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = vtk_grid(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\nvtk_grid(filename::AbstractString, grid::Grid)\n\nCreate a unstructured VTK grid from a Grid. Return a DatasetFile which data can be appended to, see vtk_point_data and vtk_cell_data.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/","page":"Export","title":"Export","text":"L2Projector\nproject","category":"page"},{"location":"reference/export/#Ferrite.L2Projector","page":"Export","title":"Ferrite.L2Projector","text":"L2Projector(func_ip::Interpolation, grid::AbstractGrid; kwargs...)\n\nCreate an L2Projector used for projecting quadrature data. func_ip is the function interpolation used for the projection and grid the grid over which the projection is applied.\n\nKeyword arguments:\n\nqr_lhs: quadrature for the left hand side. Defaults to a quadrature which exactly integrates a mass matrix with func_ip as the interpolation.\nset: element set over which the projection applies. Defaults to all elements in the grid.\ngeom_ip: geometric interpolation. Defaults to the default interpolation for the grid.\n\nThe L2Projector acts as the integrated left hand side of the projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project.\n\nUse project to integrate the right hand side and solve for the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.project","page":"Export","title":"Ferrite.project","text":"project(proj::L2Projector, vals::Vector{Vector{T}}}, qr_rhs::QuadratureRule; project_to_nodes=true)\n\nMakes a L2 projection of data vals to the nodes of the grid using the projector proj (see L2Projector).\n\nproject integrates the right hand side, and solves the projection u from the following projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project, i.e. vals.\n\nThe data vals should be a vector, with length corresponding to number of elements, of vectors, with length corresponding to number of quadrature points per element, matching the number of points in qr_rhs. Example scalar input data:\n\nvals = [\n    [0.44, 0.98, 0.32], # data for quadrature point 1, 2, 3 of element 1\n    [0.29, 0.48, 0.55], # data for quadrature point 1, 2, 3 of element 2\n    # ...\n]\n\nSupported data types to project are Numbers and AbstractTensors.\n\nIf the parameter project_to_nodes is true, then the projection returns the values in the order of the mesh nodes (suitable format for exporting). If false, it returns the values corresponding to the degrees of freedom for a scalar field over the domain, which is useful if one wants to interpolate the projected values.\n\n\n\n\n\n","category":"function"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/threaded_assembly.jl\"","category":"page"},{"location":"examples/threaded_assembly/#Threaded-Assembly","page":"Threaded Assembly","title":"Threaded Assembly","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"tip: Tip\nThis example is also available as a Jupyter notebook: threaded_assembly.ipynb","category":"page"},{"location":"examples/threaded_assembly/#Example-of-a-colored-grid","page":"Threaded Assembly","title":"Example of a colored grid","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Creates a simple 2D grid and colors it. Save the example grid to a VTK file to show the coloring. No cells with the same color has any shared nodes (dofs). This means that it is safe to assemble in parallel as long as we only assemble one color at a time.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"using Ferrite, SparseArrays\n\nfunction create_example_2d_grid()\n    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))\n    cell_colors, colors = Ferrite.create_coloring(grid)\n    vtk_grid(\"colored\", grid) do vtk\n        Ferrite.vtk_cell_data_colors(vtk, grid, colors)\n    end\nend;\n\ncreate_example_2d_grid()","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"(Image: )","category":"page"},{"location":"examples/threaded_assembly/#Cantilever-beam-in-3D-with-threaded-assembly","page":"Threaded Assembly","title":"Cantilever beam in 3D with threaded assembly","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"We will now look at an example where we assemble the stiffness matrix using multiple threads. We set up a simple grid and create a coloring, then create a DofHandler, and define the material stiffness","category":"page"},{"location":"examples/threaded_assembly/#Grid-for-the-beam","page":"Threaded Assembly","title":"Grid for the beam","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_colored_cantilever_grid(celltype, n)\n    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))\n    cell_colors, final_colors = Ferrite.create_coloring(grid)\n    return grid, final_colors\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#DofHandler","page":"Threaded Assembly","title":"DofHandler","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_dofhandler(grid::Grid{dim}) where {dim}\n    dh = DofHandler(grid)\n    push!(dh, :u, dim) # Add a displacement field\n    close!(dh)\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Stiffness-tensor-for-linear-elasticity","page":"Threaded Assembly","title":"Stiffness tensor for linear elasticity","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_stiffness(::Val{dim}) where {dim}\n    E = 200e9\n    ν = 0.3\n    λ = E*ν / ((1+ν) * (1 - 2ν))\n    μ = E / (2(1+ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n    C = SymmetricTensor{4, dim}(g);\n    return C\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Threaded-data-structures","page":"Threaded Assembly","title":"Threaded data structures","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"ScratchValues is a thread-local collection of data that each thread needs to own, since we need to be able to mutate the data in the threads independently","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"struct ScratchValues{T, CV <: CellValues, FV <: FaceValues, TT <: AbstractTensor, dim, Ti}\n    Ke::Matrix{T}\n    fe::Vector{T}\n    cellvalues::CV\n    facevalues::FV\n    global_dofs::Vector{Int}\n    ɛ::Vector{TT}\n    coordinates::Vector{Vec{dim, T}}\n    assembler::Ferrite.AssemblerSparsityPattern{T, Ti}\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Each thread need its own CellValues and FaceValues (although, for this example we don't use the FaceValues)","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_values(refshape, dim, order::Int)\n    # Interpolations and values\n    interpolation_space = Lagrange{dim, refshape, 1}()\n    quadrature_rule = QuadratureRule{dim, refshape}(order)\n    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)\n    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    return cellvalues, facevalues\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Create a ScratchValues for each thread with the thread local data","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}\n    nthreads = Threads.nthreads()\n    assemblers = [start_assemble(K, f) for i in 1:nthreads]\n    cellvalues, facevalues = create_values(RefCube, dim, 2)\n\n    n_basefuncs = getnbasefunctions(cellvalues[1])\n    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]\n\n    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector\n    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]\n\n    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]\n\n    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]\n\n    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],\n                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Threaded-assemble","page":"Threaded Assembly","title":"Threaded assemble","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"The assembly function loops over each color and does a threaded assembly for that color","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}\n\n    f = zeros(ndofs(dh))\n    scratches = create_scratchvalues(K, f, dh)\n    b = Vec{3}((0.0, 0.0, 0.0)) # Body force\n\n    for color in colors\n        # Each color is safe to assemble threaded\n        Threads.@threads for i in 1:length(color)\n            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)\n        end\n    end\n\n    return K, f\nend","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"The cell assembly function is written the same way as if it was a single threaded example. The only difference is that we unpack the variables from our scratch.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,\n                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}\n\n    # Unpack our stuff from the scratch\n    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =\n         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,\n         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler\n\n    fill!(Ke, 0)\n    fill!(fe, 0)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n\n    # Fill up the coordinates\n    nodeids = grid.cells[cell].nodes\n    for j in 1:length(coordinates)\n        coordinates[j] = grid.nodes[nodeids[j]].x\n    end\n\n    reinit!(cellvalues, coordinates)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        for i in 1:n_basefuncs\n            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))\n        end\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(cellvalues, q_point, i)\n            fe[i] += (δu ⋅ b) * dΩ\n            ɛC = ɛ[i] ⊡ C\n            for j in 1:n_basefuncs\n                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ\n            end\n        end\n    end\n\n    celldofs!(global_dofs, dh, cell)\n    assemble!(assembler, global_dofs, fe, Ke)\nend;\n\nfunction run_assemble()\n    refshape = RefCube\n    quadrature_order = 2\n    dim = 3\n    n = 20\n    grid, colors = create_colored_cantilever_grid(Hexahedron, n);\n    dh = create_dofhandler(grid);\n\n    K = create_sparsity_pattern(dh);\n    C = create_stiffness(Val{3}());\n    # compilation\n    doassemble(K, colors, grid, dh, C);\n    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);\n    return b\nend\n\nrun_assemble()","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Running the code with different number of threads give the following runtimes:","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"1 thread  2.46 seconds\n2 threads 1.19 seconds\n3 threads 0.83 seconds\n4 threads 0.75 seconds","category":"page"},{"location":"examples/threaded_assembly/#threaded_assembly-plain-program","page":"Threaded Assembly","title":"Plain Program","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Below follows a version of the program without any comments. The file is also available here: threaded_assembly.jl","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"using Ferrite, SparseArrays\n\nfunction create_example_2d_grid()\n    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))\n    cell_colors, colors = Ferrite.create_coloring(grid)\n    vtk_grid(\"colored\", grid) do vtk\n        Ferrite.vtk_cell_data_colors(vtk, grid, colors)\n    end\nend;\n\ncreate_example_2d_grid()\n\nfunction create_colored_cantilever_grid(celltype, n)\n    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))\n    cell_colors, final_colors = Ferrite.create_coloring(grid)\n    return grid, final_colors\nend;\n\nfunction create_dofhandler(grid::Grid{dim}) where {dim}\n    dh = DofHandler(grid)\n    push!(dh, :u, dim) # Add a displacement field\n    close!(dh)\nend;\n\nfunction create_stiffness(::Val{dim}) where {dim}\n    E = 200e9\n    ν = 0.3\n    λ = E*ν / ((1+ν) * (1 - 2ν))\n    μ = E / (2(1+ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n    C = SymmetricTensor{4, dim}(g);\n    return C\nend;\n\nstruct ScratchValues{T, CV <: CellValues, FV <: FaceValues, TT <: AbstractTensor, dim, Ti}\n    Ke::Matrix{T}\n    fe::Vector{T}\n    cellvalues::CV\n    facevalues::FV\n    global_dofs::Vector{Int}\n    ɛ::Vector{TT}\n    coordinates::Vector{Vec{dim, T}}\n    assembler::Ferrite.AssemblerSparsityPattern{T, Ti}\nend;\n\nfunction create_values(refshape, dim, order::Int)\n    # Interpolations and values\n    interpolation_space = Lagrange{dim, refshape, 1}()\n    quadrature_rule = QuadratureRule{dim, refshape}(order)\n    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)\n    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    return cellvalues, facevalues\nend;\n\nfunction create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}\n    nthreads = Threads.nthreads()\n    assemblers = [start_assemble(K, f) for i in 1:nthreads]\n    cellvalues, facevalues = create_values(RefCube, dim, 2)\n\n    n_basefuncs = getnbasefunctions(cellvalues[1])\n    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]\n\n    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector\n    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]\n\n    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]\n\n    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]\n\n    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],\n                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]\nend;\n\nfunction doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}\n\n    f = zeros(ndofs(dh))\n    scratches = create_scratchvalues(K, f, dh)\n    b = Vec{3}((0.0, 0.0, 0.0)) # Body force\n\n    for color in colors\n        # Each color is safe to assemble threaded\n        Threads.@threads for i in 1:length(color)\n            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)\n        end\n    end\n\n    return K, f\nend\n\nfunction assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,\n                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}\n\n    # Unpack our stuff from the scratch\n    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =\n         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,\n         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler\n\n    fill!(Ke, 0)\n    fill!(fe, 0)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n\n    # Fill up the coordinates\n    nodeids = grid.cells[cell].nodes\n    for j in 1:length(coordinates)\n        coordinates[j] = grid.nodes[nodeids[j]].x\n    end\n\n    reinit!(cellvalues, coordinates)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        for i in 1:n_basefuncs\n            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))\n        end\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(cellvalues, q_point, i)\n            fe[i] += (δu ⋅ b) * dΩ\n            ɛC = ɛ[i] ⊡ C\n            for j in 1:n_basefuncs\n                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ\n            end\n        end\n    end\n\n    celldofs!(global_dofs, dh, cell)\n    assemble!(assembler, global_dofs, fe, Ke)\nend;\n\nfunction run_assemble()\n    refshape = RefCube\n    quadrature_order = 2\n    dim = 3\n    n = 20\n    grid, colors = create_colored_cantilever_grid(Hexahedron, n);\n    dh = create_dofhandler(grid);\n\n    K = create_sparsity_pattern(dh);\n    C = create_stiffness(Val{3}());\n    # compilation\n    doassemble(K, colors, grid, dh, C);\n    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);\n    return b\nend\n\nrun_assemble()\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"using Ferrite","category":"page"},{"location":"manual/degrees_of_freedom/#Degrees-of-Freedom","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The distribution and numbering of degrees of freedom (dofs) are handled by the DofHandler. The DofHandler will be used to query information about the dofs. For example we can obtain the dofs for a particular cell, which we need when assembling the system.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The DofHandler is based on the grid. Here we create a simple grid with Triangle cells, and then create a DofHandler based on the grid","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"grid = generate_grid(Triangle, (20, 20))\ndh = DofHandler(grid)\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/#Fields","page":"Degrees of Freedom","title":"Fields","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Before we can distribute the dofs we need to specify fields. A field is simply the unknown function(s) we are solving for. To add a field we need a name (a Symbol) and we also need to specify number of components for the field. Here we add a vector field :u (2 components for a 2D problem) and a scalar field :p.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"push!(dh, :u, 2)\npush!(dh, :p, 1)\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Finally, when we have added all the fields, we have to close! the DofHandler. When the DofHandler is closed it will traverse the grid and distribute all the dofs for the fields we added.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"close!(dh)","category":"page"},{"location":"manual/degrees_of_freedom/#Specifying-interpolation-for-a-field","page":"Degrees of Freedom","title":"Specifying interpolation for a field","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"In the example above we did not specify which interpolation should be used for our fields :u and :p. By default iso-parametric elements will be used meaning that the interpolation that matches the grid will be used – for a linear grid a linear interpolation will be used etc. It is sometimes useful to separate the grid interpolation from the interpolation that is used to approximate our fields (e.g. sub- and super-parametric elements).","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"We can specify which interpolation that should be used for the approximation when we add the fields to the dofhandler. For example, here we add our vector field :u with a quadratic interpolation, and our :p field with a linear approximation.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"dh = DofHandler(grid) # hide\npush!(dh, :u, 2, Lagrange{2,RefTetrahedron,2}())\npush!(dh, :p, 1, Lagrange{2,RefTetrahedron,1}())\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/#Ordering-of-Dofs","page":"Degrees of Freedom","title":"Ordering of Dofs","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"ordered in the same order as we add to dofhandler nodes -> (edges ->) faces -> cells","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/hyperelasticity.jl\"","category":"page"},{"location":"examples/hyperelasticity/#Hyperelasticity","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Keywords: hyperelasticity, finite strain, large deformations, Newton's method, conjugate gradient, automatic differentiation","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"(Image: hyperelasticity.png)","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: hyperelasticity.ipynb","category":"page"},{"location":"examples/hyperelasticity/#Introduction","page":"Hyperelasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"In this example we will solve a problem in a finite strain setting using an hyperelastic material model. In order to compute the stress we will use automatic differentiation, to solve the non-linear system we use Newton's method, and for solving the Newton increment we use conjugate gradient.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The weak format is expressed in terms of the first Piola-Kirchoff stress mathbfP as follows: Find u in mathbbU such that","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":" int_Omega delta mathbfu otimes nabla  mathbfP(mathbfu) mathrmdOmega =\nint_Omega delta mathbfu cdot mathbfb mathrmdOmega + int_Gamma^mathrmN\nmathbfu cdot mathbft mathrmdGamma\nquad forall delta mathbfu in mathbbU^0","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where mathbfu is the unknown displacement field, mathbfb is the body force, mathbft is the traction on the Neumann part of the boundary, and where mathbbU and mathbbU^0 are suitable trial and test sets.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Ferrite, Tensors, TimerOutputs, ProgressMeter\nimport KrylovMethods, IterativeSolvers","category":"page"},{"location":"examples/hyperelasticity/#Hyperelastic-material-model","page":"Hyperelasticity","title":"Hyperelastic material model","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The stress can be derived from an energy potential, defined in terms of the right Cauchy-Green tensor mathbfC. We shall use a neo-Hookean model, where the potential can be written as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Psi(mathbfC) = fracmu2 (I_C - 3) - mu ln(J) + fraclambda2 ln(J)^2","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where I_C = mathrmtr(C), J = sqrtdet(C) and mu and lambda material parameters. From the potential we obtain the second Piola-Kirchoff stress mathbfS as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"mathbfS = 2 fracpartial Psipartial mathbfC","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"and the tangent of mathbfS as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"fracpartial mathbfSpartial mathbfC = 4 fracpartial Psipartial mathbfC","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"We can implement the material model as follows, where we utilize automatic differentiation for the stress and the tangent, and thus only define the potential:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"struct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 4.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Finally, for the finite element problem we need mathbfP and fracpartial mathbfPpartial mathbfF, which can be obtained by the following transformations","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"beginalign*\nmathbfP = mathbfF cdot mathbfS\nfracpartial mathbfPpartial mathbfF = mathbfF barotimes mathbfI \nfracpartial mathbfSpartial mathbfC  mathbfF^mathrmT barotimes mathbfI\n+ mathbfI barotimes mathbfS\nendalign*","category":"page"},{"location":"examples/hyperelasticity/#Finite-element-assembly","page":"Hyperelasticity","title":"Finite element assembly","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The element routine for assembling the residual and tangent stiffness is implemented as usual, with loops over quadrature points and shape functions:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    t = Vec{3}((0.1, 0.0, 0.0)) # Traction\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F)\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function + gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face)\n            reinit!(fv, cell, face)\n            for q_point in 1:getnquadpoints(fv)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Assembling global residual and tangent","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function assemble_global!(K, f, dh, cv, fv, mp, u)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and f\n    assembler = start_assemble(K, f)\n\n    # Loop over all cells in the grid\n    @timeit \"assemble\" for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n        assemble!(assembler, global_dofs, ge, ke)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Define a main function, with a loop for Newton iterations","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    qr = QuadratureRule{3, RefTetrahedron}(1)\n    qr_face = QuadratureRule{2, RefTetrahedron}(1)\n    cv = CellVectorValues(qr, ip)\n    fv = FaceVectorValues(qr_face, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    push!(dh, :u, 3) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t, θ = deg2rad(60.0))\n        x, y, z = X\n        return t * Vec{3}(\n            (0.0,\n            L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n            L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n            ))\n    end\n\n    dbcs = ConstraintHandler(dh)\n    # Add a homogenous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(dbcs, dbc)\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\n    add!(dbcs, dbc)\n    close!(dbcs)\n    t = 0.5\n    Ferrite.update!(dbcs, t)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u  = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, dbcs)\n\n    # Create sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    g = zeros(_ndofs)\n\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1e-8\n    prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\n    while true; newton_itr += 1\n        u .= un .+ Δu # Current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u)\n        normg = norm(g[Ferrite.free_dofs(dbcs)])\n        apply_zero!(K, g, dbcs)\n        ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > 30\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using cg! from IterativeSolvers.jl\n        @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n        @assert flag == 0\n        @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n        apply_zero!(ΔΔu, dbcs)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        vtk_grid(\"hyperelasticity\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Run the simulation","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"u = solve();\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/#Plain-Program","page":"Hyperelasticity","title":"Plain Program","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Below follows a version of the program without any comments. The file is also available here: hyperelasticity.jl","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Ferrite, Tensors, TimerOutputs, ProgressMeter\nimport KrylovMethods, IterativeSolvers\n\nstruct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 4.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\n\nfunction assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    t = Vec{3}((0.1, 0.0, 0.0)) # Traction\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F)\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function + gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face)\n            reinit!(fv, cell, face)\n            for q_point in 1:getnquadpoints(fv)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend;\n\nfunction assemble_global!(K, f, dh, cv, fv, mp, u)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and f\n    assembler = start_assemble(K, f)\n\n    # Loop over all cells in the grid\n    @timeit \"assemble\" for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n        assemble!(assembler, global_dofs, ge, ke)\n    end\nend;\n\nfunction solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    qr = QuadratureRule{3, RefTetrahedron}(1)\n    qr_face = QuadratureRule{2, RefTetrahedron}(1)\n    cv = CellVectorValues(qr, ip)\n    fv = FaceVectorValues(qr_face, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    push!(dh, :u, 3) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t, θ = deg2rad(60.0))\n        x, y, z = X\n        return t * Vec{3}(\n            (0.0,\n            L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n            L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n            ))\n    end\n\n    dbcs = ConstraintHandler(dh)\n    # Add a homogenous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(dbcs, dbc)\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\n    add!(dbcs, dbc)\n    close!(dbcs)\n    t = 0.5\n    Ferrite.update!(dbcs, t)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u  = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, dbcs)\n\n    # Create sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    g = zeros(_ndofs)\n\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1e-8\n    prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\n    while true; newton_itr += 1\n        u .= un .+ Δu # Current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u)\n        normg = norm(g[Ferrite.free_dofs(dbcs)])\n        apply_zero!(K, g, dbcs)\n        ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > 30\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using cg! from IterativeSolvers.jl\n        @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n        @assert flag == 0\n        @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n        apply_zero!(ΔΔu, dbcs)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        vtk_grid(\"hyperelasticity\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend\n\nu = solve();\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#von-Mises-plasticity","page":"von Mises plasticity","title":"von Mises plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"(Image: Shows the von Mises stress distribution in a cantilever beam.) Figure 1. A coarse mesh solution of a cantilever beam subjected to a load causing plastic deformations. The initial yield limit is 200 MPa but due to hardening it increases up to approximately 240 MPa.","category":"page"},{"location":"examples/plasticity/#Introduction","page":"von Mises plasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This example illustrates the use of a nonlinear material model in Ferrite. The particular model is von Mises plasticity (also know as J₂-plasticity) with isotropic hardening. The model is fully 3D, meaning that no assumptions like plane stress or plane strain are introduced.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Also note that the theory of the model is not described here, instead one is referred to standard textbooks on material modeling.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"To illustrate the use of the plasticity model, we setup and solve a FE-problem consisting of a cantilever beam loaded at its free end. But first, we shortly describe the parts of the implementation deadling with the material modeling.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: plasticity.ipynb","category":"page"},{"location":"examples/plasticity/#Material-modeling","page":"von Mises plasticity","title":"Material modeling","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This section describes the structs and methods used to implement the material model","category":"page"},{"location":"examples/plasticity/#Material-parameters-and-state-variables","page":"von Mises plasticity","title":"Material parameters and state variables","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Start by loading some necessary packages","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Ferrite, SparseArrays, LinearAlgebra, Printf","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"We define a J₂-plasticity-material, containing material parameters and the elastic stiffness Dᵉ (since it is constant)","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"struct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}}\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Next, we define a constructor for the material instance.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function J2Plasticity(E, ν, σ₀, H)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"note: Note\nAbove, we defined a constructor J2Plasticity(E, ν, σ₀, H) in terms of the more common material parameters E and ν - simply as a convenience for the user.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Define a struct to store the material state.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"mutable struct MaterialState{T, S <: SecondOrderTensor{3, T}}\n    # Store \"converged\" values\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\n\n    # Store temporary values used during equilibrium iterations\n    temp_ϵᵖ::S\n    temp_σ::S\n    temp_k::T\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Constructor for initializing a material state. Every quantity is set to zero.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function MaterialState()\n    return MaterialState(\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0,\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0)\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Next, we define a method to update the material state after equilibrium has been found. This will be called at the end of each time-step.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function update_state!(state::MaterialState)\n    state.ϵᵖ = state.temp_ϵᵖ\n    state.σ = state.temp_σ\n    state.k = state.temp_k\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"For later use, during the post-processing step, we define a function to compute the von Mises effective stress.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function vonMises(σ)\n    s = dev(σ)\n    return sqrt(3.0/2.0 * s ⊡ s)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Constitutive-driver","page":"von Mises plasticity","title":"Constitutive driver","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This is the actual method which computes the stress and material tangent stiffness in a given integration point. Input is the current strain and material state.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function compute_stress_tangent(ϵ::SymmetricTensor{2, 3}, material::J2Plasticity, state::MaterialState)\n    # unpack some material parameters\n    G = material.G\n    K = material.K\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ   # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effetive trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        state.temp_σ = σᵗ\n        return state.temp_σ, material.Dᵉ\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Store outputs in the material state\n        Δϵᵖ = 3/2 *μ / σₑ*s            # plastic strain\n        state.temp_ϵᵖ = state.ϵᵖ + Δϵᵖ  # plastic strain\n        state.temp_k = state.k + μ     # hardening variable\n        state.temp_σ = σ               # updated stress\n        return state.temp_σ, D\n    end\nend","category":"page"},{"location":"examples/plasticity/#FE-problem","page":"von Mises plasticity","title":"FE-problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"What follows are methods for assembling and and solving the FE-problem.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_values(interpolation)\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for u)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    return cellvalues_u, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Add-degrees-of-freedom","page":"von Mises plasticity","title":"Add degrees of freedom","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_dofhandler(grid, interpolation)\n    dh = DofHandler(grid)\n    dim = 3\n    push!(dh, :u, dim, interpolation) # add a displacement field with 3 components\n    close!(dh)\n    return dh\nend","category":"page"},{"location":"examples/plasticity/#Boundary-conditions","page":"von Mises plasticity","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_bc(dh, grid)\n    dbcs = ConstraintHandler(dh)\n    # Clamped on the left side\n    dofs = [1, 2, 3]\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], dofs)\n    add!(dbcs, dbc)\n    close!(dbcs)\n    return dbcs\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Assembling-of-element-contributions","page":"von Mises plasticity","title":"Assembling of element contributions","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Residual vector r\nTangent stiffness K","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function doassemble(cellvalues::CellVectorValues{dim},\n                    facevalues::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, material::J2Plasticity, u, states, t) where {dim}\n    r = zeros(ndofs(dh))\n    assembler = start_assemble(K, r)\n    nu = getnbasefunctions(cellvalues)\n    re = zeros(nu)     # element residual vector\n    ke = zeros(nu, nu) # element tangent matrix\n\n    for (cell, state) in zip(CellIterator(dh), states)\n        fill!(ke, 0)\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        ue = u[eldofs]\n        assemble_cell!(ke, re, cell, cellvalues, facevalues, grid, material,\n                       ue, state, t)\n        assemble!(assembler, eldofs, re, ke)\n    end\n    return K, r\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Compute element contribution to the residual and the tangent.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"note: Note\nDue to symmetry, we only compute the lower half of the tangent and then symmetrize it.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function assemble_cell!(Ke, re, cell, cellvalues, facevalues, grid, material,\n                        ue, state, t)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    reinit!(cellvalues, cell)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        ϵ = symmetric(∇u) # Total strain\n        σ, D = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = symmetric(shape_gradient(cellvalues, q_point, i))\n\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i\n                Δϵ = symmetric(shape_gradient(cellvalues, q_point, j))\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\n\n    # Add traction as a negative contribution to the element residual `re`:\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n            reinit!(facevalues, cell, face)\n            for q_point in 1:getnquadpoints(facevalues)\n                dΓ = getdetJdV(facevalues, q_point)\n                for i in 1:n_basefuncs\n                    δu = shape_value(facevalues, q_point, i)\n                    re[i] -= (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Helper function to symmetrize the material tangent","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Define a function which solves the FE-problem.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function solve()\n    # Define material parameters\n    E = 200.0e9 # [Pa]\n    H = E/20   # [Pa]\n    ν = 0.3     # [-]\n    σ₀ = 200e6  # [Pa]\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0 # beam length [m]\n    w = 1.0  # beam width [m]\n    h = 1.0  # beam height[m]\n    n_timesteps = 10\n    u_max = zeros(n_timesteps)\n    traction_magnitude = 1.e7 * range(0.5, 1.0, length=n_timesteps)\n\n    # Create geometry, dofs and boundary conditions\n    n = 2\n    nels = (10n, n, 2n) # number of elements in each spatial direction\n    P1 = Vec((0.0, 0.0, 0.0))  # start point for geometry\n    P2 = Vec((L, w, h))        # end point for geometry\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}() # Linear tet with 3 unknowns/node\n\n    dh = create_dofhandler(grid, interpolation) # JuaFEM helper function\n    dbcs = create_bc(dh, grid) # create Dirichlet boundary-conditions\n\n    cellvalues, facevalues = create_values(interpolation)\n\n    # Pre-allocate solution vectors, etc.\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)  # solution vector\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    # Create material states. One array for each cell, where each element is an array of material-\n    # states - one for each integration point\n    nqp = getnquadpoints(cellvalues)\n    states = [[MaterialState() for _ in 1:nqp] for _ in 1:getncells(grid)]\n\n    # states = [MaterialState() for _ in 1:nqp for _ in 1:getncells(grid)]\n    # temp_states = [MaterialState() for _ in 1:nqp for _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n    print(\"\\n Starting Netwon iterations:\\n\")\n\n    for timestep in 1:n_timesteps\n        t = timestep # actual time (used for evaluating d-bndc)\n        traction = Vec((0.0, 0.0, traction_magnitude[timestep]))\n        newton_itr = -1\n        print(\"\\n Time step @time = $timestep:\\n\")\n        update!(dbcs, t) # evaluates the D-bndc at time t\n        apply!(u, dbcs)  # set the prescribed values in the solution vector\n\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            print(\"Iteration: $newton_itr \\tresidual: $(@sprintf(\"%.8f\", norm_r))\\n\")\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        # Update all the material states after we have reached equilibrium\n        for cell_states in states\n            foreach(update_state!, cell_states)\n        end\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # ## Postprocessing\n    # Only a vtu-file corrsponding to the last time-step is exported.\n    #\n    # The following is a quick (and dirty) way of extracting average cell data for export.\n    mises_values = zeros(getncells(grid))\n    κ_values = zeros(getncells(grid))\n    for (el, cell_states) in enumerate(states)\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n            κ_values[el] += state.k*material.H\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n        κ_values[el] /= length(cell_states)     # average drag stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n        vtk_cell_data(vtkfile, κ_values, \"Drag stress [Pa]\")\n    end\n\n    return u_max, traction_magnitude\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Solve the FE-problem and for each time-step extract maximum displacement and the corresponding traction load. Also compute the limit-traction-load","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"u_max, traction_magnitude = solve();\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Finally we plot the load-displacement curve.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Plots\nplot(\n    vcat(0.0, u_max),                # add the origin as a point\n    vcat(0.0, traction_magnitude),\n    linewidth=2,\n    title=\"Traction-displacement\",\n    label=[\"\"],\n    markershape=:auto\n    )\nylabel!(\"Traction [Pa]\")\nxlabel!(\"Maximum deflection [m]\")","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Figure 2. Load-displacement-curve for the beam, showing a clear decrease in stiffness as more material starts to yield.","category":"page"},{"location":"examples/plasticity/#plasticity-raw-code","page":"von Mises plasticity","title":"Raw source","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Below follows a version of the program without any comments. The file is also available here: plasticity.jl","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Ferrite, SparseArrays, LinearAlgebra, Printf\n\nstruct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}}\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend;\n\nfunction J2Plasticity(E, ν, σ₀, H)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\n\nmutable struct MaterialState{T, S <: SecondOrderTensor{3, T}}\n    # Store \"converged\" values\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\n\n    # Store temporary values used during equilibrium iterations\n    temp_ϵᵖ::S\n    temp_σ::S\n    temp_k::T\nend\n\nfunction MaterialState()\n    return MaterialState(\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0,\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0)\nend\n\nfunction update_state!(state::MaterialState)\n    state.ϵᵖ = state.temp_ϵᵖ\n    state.σ = state.temp_σ\n    state.k = state.temp_k\nend;\n\nfunction vonMises(σ)\n    s = dev(σ)\n    return sqrt(3.0/2.0 * s ⊡ s)\nend;\n\nfunction compute_stress_tangent(ϵ::SymmetricTensor{2, 3}, material::J2Plasticity, state::MaterialState)\n    # unpack some material parameters\n    G = material.G\n    K = material.K\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ   # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effetive trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        state.temp_σ = σᵗ\n        return state.temp_σ, material.Dᵉ\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Store outputs in the material state\n        Δϵᵖ = 3/2 *μ / σₑ*s            # plastic strain\n        state.temp_ϵᵖ = state.ϵᵖ + Δϵᵖ  # plastic strain\n        state.temp_k = state.k + μ     # hardening variable\n        state.temp_σ = σ               # updated stress\n        return state.temp_σ, D\n    end\nend\n\nfunction create_values(interpolation)\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for u)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    return cellvalues_u, facevalues_u\nend;\n\nfunction create_dofhandler(grid, interpolation)\n    dh = DofHandler(grid)\n    dim = 3\n    push!(dh, :u, dim, interpolation) # add a displacement field with 3 components\n    close!(dh)\n    return dh\nend\n\nfunction create_bc(dh, grid)\n    dbcs = ConstraintHandler(dh)\n    # Clamped on the left side\n    dofs = [1, 2, 3]\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], dofs)\n    add!(dbcs, dbc)\n    close!(dbcs)\n    return dbcs\nend;\n\nfunction doassemble(cellvalues::CellVectorValues{dim},\n                    facevalues::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, material::J2Plasticity, u, states, t) where {dim}\n    r = zeros(ndofs(dh))\n    assembler = start_assemble(K, r)\n    nu = getnbasefunctions(cellvalues)\n    re = zeros(nu)     # element residual vector\n    ke = zeros(nu, nu) # element tangent matrix\n\n    for (cell, state) in zip(CellIterator(dh), states)\n        fill!(ke, 0)\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        ue = u[eldofs]\n        assemble_cell!(ke, re, cell, cellvalues, facevalues, grid, material,\n                       ue, state, t)\n        assemble!(assembler, eldofs, re, ke)\n    end\n    return K, r\nend\n\nfunction assemble_cell!(Ke, re, cell, cellvalues, facevalues, grid, material,\n                        ue, state, t)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    reinit!(cellvalues, cell)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        ϵ = symmetric(∇u) # Total strain\n        σ, D = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = symmetric(shape_gradient(cellvalues, q_point, i))\n\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i\n                Δϵ = symmetric(shape_gradient(cellvalues, q_point, j))\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\n\n    # Add traction as a negative contribution to the element residual `re`:\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n            reinit!(facevalues, cell, face)\n            for q_point in 1:getnquadpoints(facevalues)\n                dΓ = getdetJdV(facevalues, q_point)\n                for i in 1:n_basefuncs\n                    δu = shape_value(facevalues, q_point, i)\n                    re[i] -= (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nfunction solve()\n    # Define material parameters\n    E = 200.0e9 # [Pa]\n    H = E/20   # [Pa]\n    ν = 0.3     # [-]\n    σ₀ = 200e6  # [Pa]\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0 # beam length [m]\n    w = 1.0  # beam width [m]\n    h = 1.0  # beam height[m]\n    n_timesteps = 10\n    u_max = zeros(n_timesteps)\n    traction_magnitude = 1.e7 * range(0.5, 1.0, length=n_timesteps)\n\n    # Create geometry, dofs and boundary conditions\n    n = 2\n    nels = (10n, n, 2n) # number of elements in each spatial direction\n    P1 = Vec((0.0, 0.0, 0.0))  # start point for geometry\n    P2 = Vec((L, w, h))        # end point for geometry\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}() # Linear tet with 3 unknowns/node\n\n    dh = create_dofhandler(grid, interpolation) # JuaFEM helper function\n    dbcs = create_bc(dh, grid) # create Dirichlet boundary-conditions\n\n    cellvalues, facevalues = create_values(interpolation)\n\n    # Pre-allocate solution vectors, etc.\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)  # solution vector\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    # Create material states. One array for each cell, where each element is an array of material-\n    # states - one for each integration point\n    nqp = getnquadpoints(cellvalues)\n    states = [[MaterialState() for _ in 1:nqp] for _ in 1:getncells(grid)]\n\n    # states = [MaterialState() for _ in 1:nqp for _ in 1:getncells(grid)]\n    # temp_states = [MaterialState() for _ in 1:nqp for _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n    print(\"\\n Starting Netwon iterations:\\n\")\n\n    for timestep in 1:n_timesteps\n        t = timestep # actual time (used for evaluating d-bndc)\n        traction = Vec((0.0, 0.0, traction_magnitude[timestep]))\n        newton_itr = -1\n        print(\"\\n Time step @time = $timestep:\\n\")\n        update!(dbcs, t) # evaluates the D-bndc at time t\n        apply!(u, dbcs)  # set the prescribed values in the solution vector\n\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            print(\"Iteration: $newton_itr \\tresidual: $(@sprintf(\"%.8f\", norm_r))\\n\")\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        # Update all the material states after we have reached equilibrium\n        for cell_states in states\n            foreach(update_state!, cell_states)\n        end\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # ## Postprocessing\n    # Only a vtu-file corrsponding to the last time-step is exported.\n    #\n    # The following is a quick (and dirty) way of extracting average cell data for export.\n    mises_values = zeros(getncells(grid))\n    κ_values = zeros(getncells(grid))\n    for (el, cell_states) in enumerate(states)\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n            κ_values[el] += state.k*material.H\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n        κ_values[el] /= length(cell_states)     # average drag stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n        vtk_cell_data(vtkfile, κ_values, \"Drag stress [Pa]\")\n    end\n\n    return u_max, traction_magnitude\nend\n\nu_max, traction_magnitude = solve();\n\nusing Plots\nplot(\n    vcat(0.0, u_max),                # add the origin as a point\n    vcat(0.0, traction_magnitude),\n    linewidth=2,\n    title=\"Traction-displacement\",\n    label=[\"\"],\n    markershape=:auto\n    )\nylabel!(\"Traction [Pa]\")\nxlabel!(\"Maximum deflection [m]\")\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/helmholtz.jl\"","category":"page"},{"location":"examples/helmholtz/#Helmholtz-equation","page":"Helmholtz equation","title":"Helmholtz equation","text":"","category":"section"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"In this example, we want to solve a (variant of) of the Helmholtz equation. The example is inspired by an dealii step_7 on the standard square.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":" - Delta u + u = f","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"With boundary conditions given by","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"u = g_1 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"and","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"n cdot nabla u = g_2 quad x in Gamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"Here Γ₁ is the union of the top and the right boundary of the square, while Γ₂ is the union of the bottom and the left boundary.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"(Image: )","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"We will use the following weak formulation:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int nabla δu cdot nabla u dOmega\n+ int δu cdot u dOmega\n- int δu cdot f dOmega\n+ int δu cdot (n cdot nabla u - g_2) dGamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"where δu is a suitable test function that satisfies:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"δu = 0 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"and u is a suitable function that satisfies:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"u = g_1 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"The example highlights the following interesting features:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"There are two kinds of boundary conditions, \"Dirichlet\" and \"Von Neumann\"\nThe example contains boundary integrals\nThe Dirichlet condition is imposed strongly and the Von Neumann condition is imposed weakly.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"using Ferrite\nusing Tensors\nusing SparseArrays\nusing LinearAlgebra\n\nconst ∇ = Tensors.gradient\nconst Δ = Tensors.hessian;\n\ngrid = generate_grid(Quadrilateral, (150, 150))\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\nqr_face = QuadratureRule{dim-1, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nfacevalues = FaceScalarValues(qr_face, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"We will set things up, so that a known analytic solution is approximately reproduced. This is a good testing strategy for PDE codes and known as the method of manufactured solutions.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"function u_ana(x::Vec{2, T}) where {T}\n    xs = (Vec{2}((-0.5,  0.5)),\n          Vec{2}((-0.5, -0.5)),\n          Vec{2}(( 0.5,  -0.5)))\n    σ = 1/8\n    s = zero(eltype(x))\n    for i in 1:3\n        s += exp(- norm(x - xs[i])^2 / σ^2)\n    end\n    return max(1e-15 * one(T), s) # Denormals, be gone\nend;\n\ndbcs = ConstraintHandler(dh)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"The (strong) Dirichlet boundary condition can be handled automatically by the Ferrite library.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"dbc = Dirichlet(:u, union(getfaceset(grid, \"top\"), getfaceset(grid, \"right\")), (x,t) -> u_ana(x))\nadd!(dbcs, dbc)\nclose!(dbcs)\nupdate!(dbcs, 0.0)\n\nK = create_sparsity_pattern(dh);\n\nfunction doassemble(cellvalues::CellScalarValues{dim}, facevalues::FaceScalarValues{dim},\n                         K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    b = 1.0\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    global_dofs = zeros(Int, ndofs_per_cell(dh))\n\n    fe = zeros(n_basefuncs) # Local force vector\n    Ke = zeros(n_basefuncs, n_basefuncs) # Local stiffness mastrix\n\n    @inbounds for (cellcount, cell) in enumerate(CellIterator(dh))\n        fill!(Ke, 0)\n        fill!(fe, 0)\n        coords = getcoordinates(cell)\n\n        reinit!(cellvalues, cell)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"First we derive the non boundary part of the variation problem from the destined solution u_ana","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int nabla δu cdot nabla u dOmega\n+ int δu cdot u dOmega\n- int δu cdot f dOmega","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            coords_qp = spatial_coordinate(cellvalues, q_point, coords)\n            f_true = -LinearAlgebra.tr(hessian(u_ana, coords_qp)) + u_ana(coords_qp)\n            for i in 1:n_basefuncs\n                δu = shape_value(cellvalues, q_point, i)\n                ∇δu = shape_gradient(cellvalues, q_point, i)\n                fe[i] += (δu * f_true) * dΩ\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇δu ⋅ ∇u + δu * u) * dΩ\n                end\n            end\n        end","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"Now we manually add the von Neumann boundary terms","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int δu cdot (n cdot nabla u - g_2) dGamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"        for face in 1:nfaces(cell)\n            if onboundary(cell, face) &&\n                   ((cellcount, face) ∈ getfaceset(grid, \"left\") ||\n                    (cellcount, face) ∈ getfaceset(grid, \"bottom\"))\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    coords_qp = spatial_coordinate(facevalues, q_point, coords)\n                    n = getnormal(facevalues, q_point)\n                    g = gradient(u_ana, coords_qp) ⋅ n\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:n_basefuncs\n                        δu = shape_value(facevalues, q_point, i)\n                        fe[i] += -(δu * g) * dΓ\n                        for j in 1:n_basefuncs\n                            ∇u = shape_gradient(cellvalues, q_point, j)\n                            Ke[i, j] += (δu * ∇u ⋅ n) * dΓ\n                        end\n                    end\n                end\n            end\n        end\n\n        celldofs!(global_dofs, cell)\n        assemble!(assembler, global_dofs, fe, Ke)\n    end\n    return K, f\nend;\n\nK, f = doassemble(cellvalues, facevalues, K, dh);\napply!(K, f, dbcs)\nu = Symmetric(K) \\ f;\n\nvtkfile = vtk_grid(\"helmholtz\", dh)\nvtk_point_data(vtkfile, dh, u)\nvtk_save(vtkfile)\nprintln(\"Helmholtz successful\")","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"In Ferrite a Grid is a collection of Nodes and Cells and is parameterized in its physical dimensionality and cell type. Nodes are points in the physical space and can be initialized by a N-Tuple, where N corresponds to the dimensions.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"n1 = Node((0.0, 0.0))","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Cells are defined based on the Node IDs. Hence, they collect IDs in a N-Tuple. Consider the following 2D mesh:","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"(Image: global mesh)","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The cells of the grid can be described in the following way","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> elements = [\n              (1,2,5,4),\n              (2,3,6,5),\n              (4,5,8,7),\n              (5,6,9,8)\n       ]","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Additionally, the data structure Grid can hold node-, face- and cellsets.  All of these three sets are defined by a dictionary that maps a string key to a Set.  For the special case of node- and cellsets the dictionary's value is of type Set{Int}, i.e. a keyword is mapped to a node or cell ID, respectively. ","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Facesets are a more elaborate construction. They map a String key to a Set{Int, Int} consisting of (global_cell_id, local_face_id). In order to understand the local_face_id properly, one has to consider the reference space of the element, which typically is spanned by a product of the interval -1 1 and in this particular example -1 1 times -1 1.  In this space a local numbering of nodes and faces exists, i.e.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"(Image: local element)","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The example shows a local face ID ordering, defined as:","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"faces(::Lagrange{2,RefCube,1}) = ((1,2), (2,3), (3,4), (4,1))","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Other face ID definitions can be found in the src files in the corresponding faces dispatch.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The highlighted face, i.e. the two lines from node ID 3 to 6 and from 6 to 9, on the right hand side of our test mesh can now be described as","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> edges = [\n           (3,6),\n           (6,9)\n       ]","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The local ID can be constructed based on elements, corresponding edges and chosen interpolation, since the face ordering is interpolation dependent.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> function compute_faceset(elements, edges, ip::Interpolation{dim}) where {dim}\n           local_faces = Ferrite.faces(ip)\n           nodes_per_face = length(local_faces[1])\n           d = Dict{NTuple{nodes_per_face, Int}, Tuple{Int, Int}}()\n           for (e, element) in enumerate(elements) # e is global element number\n               for (f, face) in enumerate(local_faces) # f is local face number\n                   # store the global nodes for the particular element, local face combination\n                   d[ntuple(i-> element[face[i]], nodes_per_face)] = (e, f)\n               end\n           end\n       \n           faces = Set{Tuple{Int, Int}}()\n           for edge in edges\n               # lookup the element, local face combination for this edge\n               push!(faces, d[edge])\n           end\n       \n           return faces\n       end\n\njulia> interpolation = Lagrange{2, RefTetrahedron, 1}()\n\njulia> compute_faceset(elements, edges, interpolation)\nSet{Tuple{Int64,Int64}} with 2 elements:\n  (2, 2)\n  (4, 2)","category":"page"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"QuadratureRule\nAbstractRefShape\ngetpoints\ngetweights","category":"page"},{"location":"reference/quadrature/#Ferrite.QuadratureRule","page":"Quadrature","title":"Ferrite.QuadratureRule","text":"QuadratureRule{dim,shape}([quad_rule_type::Symbol], order::Int)\n\nCreate a QuadratureRule used for integration. dim is the space dimension, shape an AbstractRefShape and order the order of the quadrature rule. quad_rule_type is an optional argument determining the type of quadrature rule, currently the :legendre and :lobatto rules are implemented.\n\nA QuadratureRule is used to approximate an integral on a domain by a weighted sum of function values at specific points:\n\nintlimits_Omega f(mathbfx) textd Omega approx sumlimits_q = 1^n_q f(mathbfx_q) w_q\n\nThe quadrature rule consists of n_q points in space mathbfx_q with corresponding weights w_q.\n\nIn Ferrite, the QuadratureRule type is mostly used as one of the components to create a CellValues or FaceValues object.\n\nCommon methods:\n\ngetpoints : the points of the quadrature rule\ngetweights : the weights of the quadrature rule\n\nExample:\n\njulia> QuadratureRule{2, RefTetrahedron}(1)\nFerrite.QuadratureRule{2,Ferrite.RefTetrahedron,Float64}([0.5], Tensors.Tensor{1,2,Float64,2}[[0.333333, 0.333333]])\n\njulia> QuadratureRule{1, RefCube}(:lobatto, 2)\nFerrite.QuadratureRule{1,Ferrite.RefCube,Float64}([1.0, 1.0], Tensors.Tensor{1,1,Float64,1}[[-1.0], [1.0]])\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.AbstractRefShape","page":"Quadrature","title":"Ferrite.AbstractRefShape","text":"Represents a reference shape which quadrature rules and interpolations are defined on. Currently, the only concrete types that subtype this type are RefCube in 1, 2 and 3 dimensions, and RefTetrahedron in 2 and 3 dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.getpoints","page":"Quadrature","title":"Ferrite.getpoints","text":"getpoints(qr::QuadratureRule)\n\nReturn the points of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{2, RefTetrahedron}(:legendre, 2);\n\njulia> getpoints(qr)\n3-element Array{Tensors.Tensor{1,2,Float64,2},1}:\n [0.166667, 0.166667]\n [0.166667, 0.666667]\n [0.666667, 0.166667]\n\n\n\n\n\n","category":"function"},{"location":"reference/quadrature/#Ferrite.getweights","page":"Quadrature","title":"Ferrite.getweights","text":"getweights(qr::QuadratureRule)\n\nReturn the weights of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{2, RefTetrahedron}(:legendre, 2);\n\njulia> getweights(qr)\n3-element Array{Float64,1}:\n 0.166667\n 0.166667\n 0.166667\n\n\n\n\n\n","category":"function"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/transient_heat_equation.jl\"","category":"page"},{"location":"examples/transient_heat_equation/#Time-Dependent-Problems","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"(Image: )","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"tip: Tip\nThis example is also available as a Jupyter notebook: transient_heat_equation.ipynb","category":"page"},{"location":"examples/transient_heat_equation/#Introduction","page":"Time Dependent Problems","title":"Introduction","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In this example we extend the heat equation by a time dependent term, i.e.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":" fracpartial upartial t-nabla cdot (k nabla u) = f  quad x in Omega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set f = 1 and k = 1. We define homogeneous Dirichlet boundary conditions along the left and right edge of the domain.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"u(xt) = 0 quad x in partial Omega_1","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where partial Omega_1 denotes the left and right boundary of Omega.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Further, we define heterogeneous Dirichlet boundary conditions at the top and bottom edge partial Omega_2. We choose a linearly increasing function a(t) that describes the temperature at this boundary","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"u(xt) = a(t) quad x in partial Omega_2","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"The semidiscrete weak form is given by","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"int_Omegafracpartial upartial tcdot v  dOmega + int_Omega nabla v cdot nabla u  dOmega = int_Omega v  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where v is a suitable test function. Now, we still need to discretize the time derivative. An implicit Euler scheme is applied, which yields:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"int_Omegau_n+1cdot v  dOmega + Delta tint_Omega nabla v cdot nabla u_n+1  dOmega = Delta tint_Omega v  dOmega + int_Omega u_ncdot v  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"If we assemble the discrete operators, we get the following algebraic system:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"mathbfM mathbfu_n+1 + Δt mathbfK mathbfu_n+1 = Δt mathbff + mathbfM mathbfu_n","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In this example we apply the boundary conditions to the assembled discrete operators (mass matrix mathbfM and stiffnes matrix mathbfK) only once. We utilize the fact that in finite element computations Dirichlet conditions can be applied by zero out rows and columns that correspond to a prescribed dof in the system matrix (mathbfA = Δt mathbfK + mathbfM) and setting the value of the right-hand side vector to the value of the Dirichlet condition. Thus, we only need to apply in every time step the Dirichlet condition to the right-hand side of the problem.","category":"page"},{"location":"examples/transient_heat_equation/#Commented-Program","page":"Time Dependent Problems","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"First we load Ferrite, and some other packages we need.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"using Ferrite, SparseArrays","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We create the same grid as in the heat equation example.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"grid = generate_grid(Quadrilateral, (100, 100));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Trial-and-test-functions","page":"Time Dependent Problems","title":"Trial and test functions","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Again, we define the structs that are responsible for the shape_value and shape_gradient evaluation.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"dim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Degrees-of-freedom","page":"Time Dependent Problems","title":"Degrees of freedom","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"After this, we can define the DofHandler and distribute the DOFs of the problem.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"dh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"By means of the DofHandler we can allocate the needed SparseMatrixCSC. M refers here to the so called mass matrix, which always occurs in time related terms, i.e.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"M_ij = int_Omega u_i cdot v_j  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where u_i and v_j are trial and test functions, respectively.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"K = create_sparsity_pattern(dh);\nM = create_sparsity_pattern(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We also preallocate the right hand side","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"f = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Boundary-conditions","page":"Time Dependent Problems","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In order to define the time dependent problem, we need some end time T and something that describes the linearly increasing Dirichlet boundary condition on partial Omega_2.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"max_temp = 100\nΔt = 1\nT = 200\nch = ConstraintHandler(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here, we define the boundary condition related to partial Omega_1.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"∂Ω₁ = union(getfaceset.((grid, ), [\"left\", \"right\"])...)\ndbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\nadd!(ch, dbc);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"While the next code block corresponds to the linearly increasing temperature description on partial Omega_2.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"∂Ω₂ = union(getfaceset.((grid, ), [\"top\", \"bottom\"])...)\ndbc = Dirichlet(:u, ∂Ω₂, (x, t) -> t*(max_temp/T))\nadd!(ch, dbc)\nclose!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Assembling-the-linear-system","page":"Time Dependent Problems","title":"Assembling the linear system","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"As in the heat equation example we define a doassemble! function that assembles the diffusion parts of the equation:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"function doassemble_K!(K::SparseMatrixCSC, f::Vector, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\nnothing # hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In addition to the diffusive part, we also need a function that assembles the mass matrix M.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"function doassemble_M!(M::SparseMatrixCSC, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Me = zeros(n_basefuncs, n_basefuncs)\n\n    assembler = start_assemble(M)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Me, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    Me[i, j] += (v ⋅ u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), Me)\n    end\n    return M\nend\nnothing # hide","category":"page"},{"location":"examples/transient_heat_equation/#Solution-of-the-system","page":"Time Dependent Problems","title":"Solution of the system","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We first assemble all parts in the prior allocated SparseMatrixCSC.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"K, f = doassemble_K!(K, f, cellvalues, dh)\nM = doassemble_M!(M, cellvalues, dh)\nA = (Δt .* K) + M;\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Now, we need to save all boundary condition related values of the unaltered system matrix A, which is done by get_rhs_data. The function returns a RHSData struct, which contains all needed informations to apply the boundary conditions solely on the right-hand-side vector of the problem.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"rhsdata = get_rhs_data(ch, A);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We set the initial time step, denoted by uₙ,  to mathbf0.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"uₙ = zeros(length(f));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here, we apply once the boundary conditions to the system matrix A.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"apply!(A, ch);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"To store the solution, we initialize a paraview_collection (.pvd) file.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"pvd = paraview_collection(\"transient-heat.pvd\");\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"At this point everything is set up and we can finally approach the time loop.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"for t in 0:Δt:T\n    #First of all, we need to update the Dirichlet boundary condition values.\n    update!(ch, t)\n\n    #Secondly, we compute the right-hand-side of the problem.\n    b = Δt .* f .+ M * uₙ\n    #Then, we can apply the boundary conditions of the current time step.\n    apply_rhs!(rhsdata, b, ch)\n\n    #Finally, we can solve the time step and save the solution afterwards.\n    u = A \\ b;\n\n    vtk_grid(\"transient-heat-$t\", dh) do vtk\n        vtk_point_data(vtk, dh, u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\n   #At the end of the time loop, we set the previous solution to the current one and go to the next time step.\n   uₙ .= u\nend","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In order to use the .pvd file we need to store it to the disk, which is done by:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"vtk_save(pvd);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#transient_heat_equation-plain-program","page":"Time Dependent Problems","title":"Plain Program","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Below follows a version of the program without any comments. The file is also available here: transientheatequation.jl","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"using Ferrite, SparseArrays\n\ngrid = generate_grid(Quadrilateral, (100, 100));\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\n\nK = create_sparsity_pattern(dh);\nM = create_sparsity_pattern(dh);\n\nf = zeros(ndofs(dh));\n\nmax_temp = 100\nΔt = 1\nT = 200\nch = ConstraintHandler(dh);\n\n∂Ω₁ = union(getfaceset.((grid, ), [\"left\", \"right\"])...)\ndbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\nadd!(ch, dbc);\n\n∂Ω₂ = union(getfaceset.((grid, ), [\"top\", \"bottom\"])...)\ndbc = Dirichlet(:u, ∂Ω₂, (x, t) -> t*(max_temp/T))\nadd!(ch, dbc)\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction doassemble_K!(K::SparseMatrixCSC, f::Vector, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\n\nfunction doassemble_M!(M::SparseMatrixCSC, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Me = zeros(n_basefuncs, n_basefuncs)\n\n    assembler = start_assemble(M)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Me, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    Me[i, j] += (v ⋅ u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), Me)\n    end\n    return M\nend\n\nK, f = doassemble_K!(K, f, cellvalues, dh)\nM = doassemble_M!(M, cellvalues, dh)\nA = (Δt .* K) + M;\n\nrhsdata = get_rhs_data(ch, A);\n\nuₙ = zeros(length(f));\n\napply!(A, ch);\n\npvd = paraview_collection(\"transient-heat.pvd\");\n\nfor t in 0:Δt:T\n    #First of all, we need to update the Dirichlet boundary condition values.\n    update!(ch, t)\n\n    #Secondly, we compute the right-hand-side of the problem.\n    b = Δt .* f .+ M * uₙ\n    #Then, we can apply the boundary conditions of the current time step.\n    apply_rhs!(rhsdata, b, ch)\n\n    #Finally, we can solve the time step and save the solution afterwards.\n    u = A \\ b;\n\n    vtk_grid(\"transient-heat-$t\", dh) do vtk\n        vtk_point_data(vtk, dh, u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\n   #At the end of the time loop, we set the previous solution to the current one and go to the next time step.\n   uₙ .= u\nend\n\nvtk_save(pvd);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/landau.jl\"","category":"page"},{"location":"examples/landau/#Ginzburg-Landau-model-energy-minimization","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"(Image: landau_orig.png)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Original","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"(Image: landau_opt.png)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Optimized","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"In this example a basic Ginzburg-Landau model is solved. This example gives an idea of how the API together with ForwardDiff can be leveraged to performantly solve non standard problems on a FEM grid. A large portion of the code is there only for performance reasons, but since this usually really matters and is what takes the most time to optimize, it is included.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The key to using a method like this for minimizing a free energy function directly, rather than the weak form, as is usually done with FEM, is to split up the gradient and Hessian calculations. This means that they are performed for each cell seperately instead of for the grid as a whole.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"using ForwardDiff\nimport ForwardDiff: GradientConfig, HessianConfig, Chunk\nusing Ferrite\nusing Optim, LineSearches\nusing SparseArrays\nusing Tensors\nusing Base.Threads","category":"page"},{"location":"examples/landau/#Energy-terms","page":"Ginzburg-Landau model energy minimization","title":"Energy terms","text":"","category":"section"},{"location":"examples/landau/#th-order-Landau-free-energy","page":"Ginzburg-Landau model energy minimization","title":"4th order Landau free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function Fl(P::Vec{3, T}, α::Vec{3}) where T\n    P2 = Vec{3, T}((P[1]^2, P[2]^2, P[3]^2))\n    return (α[1] * sum(P2) +\n           α[2] * (P[1]^4 + P[2]^4 + P[3]^4)) +\n           α[3] * ((P2[1] * P2[2]  + P2[2]*P2[3]) + P2[1]*P2[3])\nend","category":"page"},{"location":"examples/landau/#Ginzburg-free-energy","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"@inline Fg(∇P, G) = 0.5(∇P ⊡ G) ⊡ ∇P","category":"page"},{"location":"examples/landau/#GL-free-energy","page":"Ginzburg-Landau model energy minimization","title":"GL free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"F(P, ∇P, params)  = Fl(P, params.α) + Fg(∇P, params.G)","category":"page"},{"location":"examples/landau/#Parameters-that-characterize-the-model","page":"Ginzburg-Landau model energy minimization","title":"Parameters that characterize the model","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"struct ModelParams{V, T}\n    α::V\n    G::T\nend","category":"page"},{"location":"examples/landau/#ThreadCache","page":"Ginzburg-Landau model energy minimization","title":"ThreadCache","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This holds the values that each thread will use during the assembly.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"struct ThreadCache{CV, T, DIM, F <: Function, GC <: GradientConfig, HC <: HessianConfig}\n    cvP              ::CV\n    element_indices  ::Vector{Int}\n    element_dofs     ::Vector{T}\n    element_gradient ::Vector{T}\n    element_hessian  ::Matrix{T}\n    element_coords   ::Vector{Vec{DIM, T}}\n    element_potential::F\n    gradconf         ::GC\n    hessconf         ::HC\nend\nfunction ThreadCache(dpc::Int, nodespercell, cvP::CellValues{DIM, T}, modelparams, elpotential) where {DIM, T}\n    element_indices  = zeros(Int, dpc)\n    element_dofs     = zeros(dpc)\n    element_gradient = zeros(dpc)\n    element_hessian  = zeros(dpc, dpc)\n    element_coords   = zeros(Vec{DIM, T}, nodespercell)\n    potfunc          = x -> elpotential(x, cvP, modelparams)\n    gradconf         = GradientConfig(potfunc, zeros(dpc), Chunk{12}())\n    hessconf         = HessianConfig(potfunc, zeros(dpc), Chunk{12}())\n    return ThreadCache(cvP, element_indices, element_dofs, element_gradient, element_hessian, element_coords, potfunc, gradconf, hessconf)\nend","category":"page"},{"location":"examples/landau/#The-Model","page":"Ginzburg-Landau model energy minimization","title":"The Model","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"everything is combined into a model.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"mutable struct LandauModel{T, DH <: DofHandler, CH <: ConstraintHandler, TC <: ThreadCache}\n    dofs          ::Vector{T}\n    dofhandler    ::DH\n    boundaryconds ::CH\n    threadindices ::Vector{Vector{Int}}\n    threadcaches  ::Vector{TC}\nend\n\nfunction LandauModel(α, G, gridsize, left::Vec{DIM, T}, right::Vec{DIM, T}, elpotential) where {DIM, T}\n    grid = generate_grid(Tetrahedron, gridsize, left, right)\n    questionmark, threadindices = Ferrite.create_coloring(grid)\n\n    qr  = QuadratureRule{DIM, RefTetrahedron}(2)\n    cvP = CellVectorValues(qr, Lagrange{DIM, RefTetrahedron, 1}())\n\n    dofhandler = DofHandler(grid)\n    push!(dofhandler, :P, 3)\n    close!(dofhandler)\n\n    dofvector = zeros(ndofs(dofhandler))\n    startingconditions!(dofvector, dofhandler)\n    boundaryconds = ConstraintHandler(dofhandler)\n    #boundary conditions can be added but aren't necessary for optimization\n    #add!(boundaryconds, Dirichlet(:P, getfaceset(grid, \"left\"), (x, t) -> [0.0,0.0,0.53], [1,2,3]))\n    #add!(boundaryconds, Dirichlet(:P, getfaceset(grid, \"right\"), (x, t) -> [0.0,0.0,-0.53], [1,2,3]))\n    close!(boundaryconds)\n    update!(boundaryconds, 0.0)\n\n    apply!(dofvector, boundaryconds)\n\n    hessian = create_sparsity_pattern(dofhandler)\n    dpc = ndofs_per_cell(dofhandler)\n    cpc = length(grid.cells[1].nodes)\n    caches = [ThreadCache(dpc, cpc, copy(cvP), ModelParams(α, G), elpotential) for t=1:nthreads()]\n    return LandauModel(dofvector, dofhandler, boundaryconds, threadindices, caches)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"utility to quickly save a model","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function Ferrite.vtk_save(path, model, dofs=model.dofs)\n    vtkfile = vtk_grid(path, model.dofhandler)\n    vtk_point_data(vtkfile, model.dofhandler, dofs)\n    vtk_save(vtkfile)\nend","category":"page"},{"location":"examples/landau/#Assembly","page":"Ginzburg-Landau model energy minimization","title":"Assembly","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This macro defines most of the assembly step, since the structure is the same for the energy, gradient and Hessian calculations.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"macro assemble!(innerbody)\n    esc(quote\n        dofhandler = model.dofhandler\n        for indices in model.threadindices\n            @threads for i in indices\n                cache     = model.threadcaches[threadid()]\n                eldofs    = cache.element_dofs\n                nodeids   = dofhandler.grid.cells[i].nodes\n                for j=1:length(cache.element_coords)\n                    cache.element_coords[j] = dofhandler.grid.nodes[nodeids[j]].x\n                end\n                reinit!(cache.cvP, cache.element_coords)\n\n                celldofs!(cache.element_indices, dofhandler, i)\n                for j=1:length(cache.element_dofs)\n                    eldofs[j] = dofvector[cache.element_indices[j]]\n                end\n                $innerbody\n            end\n        end\n    end)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This calculates the total energy calculation of the grid","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function F(dofvector::Vector{T}, model) where T\n    outs = fill(zero(T), nthreads())\n    @assemble! begin\n        outs[threadid()] += cache.element_potential(eldofs)\n    end\n    return sum(outs)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The gradient calculation for each dof","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function ∇F!(∇f::Vector{T}, dofvector::Vector{T}, model::LandauModel{T}) where T\n    fill!(∇f, zero(T))\n    @assemble! begin\n        ForwardDiff.gradient!(cache.element_gradient, cache.element_potential, eldofs, cache.gradconf)\n        @inbounds assemble!(∇f, cache.element_indices, cache.element_gradient)\n    end\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The Hessian calculation for the whole grid","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function ∇²F!(∇²f::SparseMatrixCSC, dofvector::Vector{T}, model::LandauModel{T}) where T\n    assemblers = [start_assemble(∇²f) for t=1:nthreads()]\n    @assemble! begin\n        ForwardDiff.hessian!(cache.element_hessian, cache.element_potential, eldofs, cache.hessconf)\n        @inbounds assemble!(assemblers[threadid()], cache.element_indices, cache.element_hessian)\n    end\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"We can also calculate all things in one go!","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function calcall(∇²f::SparseMatrixCSC, ∇f::Vector{T}, dofvector::Vector{T}, model::LandauModel{T}) where T\n    outs = fill(zero(T), nthreads())\n    fill!(∇f, zero(T))\n    assemblers = [start_assemble(∇²f, ∇f) for t=1:nthreads()]\n    @assemble! begin\n        outs[threadid()] += cache.element_potential(eldofs)\n        ForwardDiff.hessian!(cache.element_hessian, cache.element_potential, eldofs, cache.hessconf)\n        ForwardDiff.gradient!(cache.element_gradient, cache.element_potential, eldofs, cache.gradconf)\n        @inbounds assemble!(assemblers[threadid()], cache.element_indices, cache.element_gradient, cache.element_hessian)\n    end\n    return sum(outs)\nend","category":"page"},{"location":"examples/landau/#Minimization","page":"Ginzburg-Landau model energy minimization","title":"Minimization","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Now everything can be combined to minimize the energy, and find the equilibrium configuration.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function minimize!(model; kwargs...)\n    dh = model.dofhandler\n    dofs = model.dofs\n    ∇f = fill(0.0, length(dofs))\n    ∇²f = create_sparsity_pattern(dh)\n    function g!(storage, x)\n        ∇F!(storage, x, model)\n        apply_zero!(storage, model.boundaryconds)\n    end\n    function h!(storage, x)\n        ∇²F!(storage, x, model)\n        #apply!(storage, model.boundaryconds)\n    end\n    f(x) = F(x, model)\n\n    od = TwiceDifferentiable(f, g!, h!, model.dofs, 0.0, ∇f, ∇²f)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"this way of minimizing is only beneficial when the initial guess is completely off, then a quick couple of ConjuageGradient steps brings us easily closer to the minimum. res = optimize(od, model.dofs, ConjugateGradient(linesearch=BackTracking()), Optim.Options(showtrace=true, showevery=1, g_tol=1e-20, iterations=10)) model.dofs .= res.minimizer to get the final convergence, Newton's method is more ideal since the energy landscape should be almost parabolic","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"    res = optimize(od, model.dofs, Newton(linesearch=BackTracking()), Optim.Options(show_trace=true, show_every=1, g_tol=1e-20))\n    model.dofs .= res.minimizer\n    return res\nend","category":"page"},{"location":"examples/landau/#Testing-it","page":"Ginzburg-Landau model energy minimization","title":"Testing it","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This calculates the contribution of each element to the total energy, it is also the function that will be put through ForwardDiff for the gradient and Hessian.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function element_potential(eldofs::AbstractVector{T}, cvP, params) where T\n    energy = zero(T)\n    for qp=1:getnquadpoints(cvP)\n        P  = function_value(cvP, qp, eldofs)\n        ∇P = function_gradient(cvP, qp, eldofs)\n        energy += F(P, ∇P, params) * getdetJdV(cvP, qp)\n    end\n    return energy\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"now we define some starting conditions","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function startingconditions!(dofvector, dofhandler)\n    for cell in CellIterator(dofhandler)\n        globaldofs = celldofs(cell)\n        it = 1\n        for i=1:3:length(globaldofs)\n            dofvector[globaldofs[i]]   = -2.0\n            dofvector[globaldofs[i+1]] = 2.0\n            dofvector[globaldofs[i+2]] = -2.0tanh(cell.coords[it][1]/20)\n            it += 1\n        end\n    end\nend\n\nδ(i, j) = i == j ? one(i) : zero(i)\nV2T(p11, p12, p44) = Tensor{4, 3}((i,j,k,l) -> p11 * δ(i,j)*δ(k,l)*δ(i,k) + p12*δ(i,j)*δ(k,l)*(1 - δ(i,k)) + p44*δ(i,k)*δ(j,l)*(1 - δ(i,j)))\n\nG = V2T(1.0e2, 0.0, 1.0e2)\nα = Vec{3}((-1.0, 1.0, 1.0))\nleft = Vec{3}((-75.,-25.,-2.))\nright = Vec{3}((75.,25.,2.))\nmodel = LandauModel(α, G, (50, 50, 2), left, right, element_potential)\n\nvtk_save(\"landauorig\", model)\n@time minimize!(model)\nvtk_save(\"landaufinal\", model)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"as we can see this runs very quickly even for relatively large gridsizes. The key to get high performance like this is to minimize the allocations inside the threaded loops, ideally to 0.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/fe_intro/#Introduction-to-FEM","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Here we will present a very brief introduction to partial differential equations (PDEs) and to the finite element method (FEM). Perhaps the simplest PDE of all is the (linear) heat equation, also known as the Laplace equation. We will use this equation as a demonstrative example of the method, and demonstrate how we go from the strong format of the equation, to the weak form, and then finally to the discrete FE problem.","category":"page"},{"location":"manual/fe_intro/#Strong-format","page":"Introduction to FEM","title":"Strong format","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The strong format of the heat equation may be written as:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"- mathbfnabla cdot mathbfq(u) = b quad x in Omega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where u is the unknown temperature field, mathbfq is the heat flux and b is an internal heat source. To complete the system of equations we need boundary conditions. There are different types of boundary conditions, but the most common ones are Dirichlet – which means that the solution u is known at some part of the boundary, and Neumann – which means that the gradient of the solution, mathbfnabla is known. For example","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u = u^mathrmp quad forall mathbfx in Gamma_mathrmD\nmathbfq cdot mathbfn = q^mathrmp quad forall mathbfx in Gamma_mathrmN","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"i.e. the temperature is presribed to u^mathrmp at the Dirichlet part of the boundary, Gamma_mathrmD, and the heat flux is prescribed to q^mathrmp at the Neumann part of the boundary, Gamma_mathrmN.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We also need a constitutive equation which links the temperature field, u, to the heat flux, mathbfq. The simplest case is to use Fourier's law","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"mathbfq = -k mathbfnablau","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where k is the conductivity of the material. For simplicity we will consider only constant conductivity k.","category":"page"},{"location":"manual/fe_intro/#Weak-format","page":"Introduction to FEM","title":"Weak format","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The solution to the equation above is usually calculated from the corresponding weak format. By multiplying the equation with an arbitrary test function delta u, integrating over the domain and using partial integration we obtain the weak form; Find u in mathbbU s.t.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"int_Omega mathbfdelta u cdot (k mathbfu) mathrmdOmega =\nint_Gamma_mathrmN delta u q^mathrmp mathrmdGamma +\nint_Omega delta u b mathrmdOmega quad forall delta u in mathbbU^0","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where mathbbU mathbbU^0 are function spaces with sufficiently regular functions. It can be shown that the solution to the weak form is identical to the solution to the strong format.","category":"page"},{"location":"manual/fe_intro/#FE-approximation","page":"Introduction to FEM","title":"FE-approximation","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We now introduce the finite element approximation u_h approx u as a sum of shape functions, N_i and nodal values, a_i. We approximate the test function in the same way (known as the Galerkin method):","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u_mathrmh = sum_i=1^mathrmN N_i a_iqquad\ndelta u_mathrmh = sum_i=1^mathrmN N_i delta a_i","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We may now inserted these approximations in the weak format, which results in","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"sum_i^N sum_j^N delta a_i int_Omega mathbfnabla N_i cdot (k cdot mathbfnabla N_j) mathrmdOmega a_j =\nsum_i^N delta a_i int_Gamma N_i q^mathrmp mathrmdGamma +\nsum_i^N delta a_i int_Omega N_i b mathrmdOmega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Since delta u can be chosen arbitrary, the nodal values delta a_i can be chosen arbitrary. Thus, the equation can be written as a linear system of equations","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlineK underlinea = underlinef","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where underlineK is the (tangent) stiffness matrix, underlinea is the solution vector with the nodal values and underlinef is the force vector. The elements of underlineK and underlinef are given by","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlineK_ij =\n    int_Omega mathbfnablaN_i cdot (k cdot mathbfnablaN_j) mathrmdOmega\n\nunderlinef_i =\n    int_Gamma N_i q^mathrmp mathrmdGamma + int_Omega N_i b mathrmdOmega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The solution to the system (which in this case is linear) is simply given by inverting the matrix underlineK. We also need to take care of the Dirichlet boundary conditions, by enforcing the correct nodal values a_i to the prescribed values.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlinea = underlineK^-1 underlinef","category":"page"},{"location":"manual/fe_intro/#Implementation","page":"Introduction to FEM","title":"Implementation","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In practice, the shape functions N are only non-zero on parts of the domain Omega. Thus, the integrals are evaluated on sub-domains, called elements or cells. Each cell gives a contribution to the global stiffness matrix and force vector. For a solution of the heat equation, as implemented in Ferrite, check out this thoroughly commented example.","category":"page"},{"location":"reference/grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"using Ferrite\ngrid = generate_grid(Triangle, (2, 2))\ndh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\nu = rand(ndofs(dh)); σ = rand(getncells(grid))","category":"page"},{"location":"manual/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"When the problem is solved, and the solution vector u is known we typically want to visualize it. The simplest way to do this is to write the solution to a VTK-file, which can be viewed in e.g. Paraview. To write VTK-files, Ferrite uses, and extends, functions from the WriteVTK.jl package to simplify the exporting.","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"First we need to create a file, based on the grid. This is done with the vtk_grid function:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", grid)\n# hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Next we have to add data to the file. We may add different kinds of data; point data using vtk_point_data or cell data using vtk_cell_data. Point data is data for each nodal coordinate in the grid, for example our solution vector. Point data can be either scalars or vectors. Cell data is – as the name suggests – data for each cell. This can be for example the stress. As an example, lets add a solution vector u as point data, and a vector with stress for each cell, σ, as cell data:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_point_data(vtk, u, \"my-point-data\")\nvtk_cell_data(vtk,  σ, \"my-cell-data\")\n# hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Finally, we need to save the file to disk, using vtk_save","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Alternatively, all of the above can be done using a do block:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", grid) do vtk\n    vtk_point_data(vtk, u, \"my-point-data\")\n    vtk_cell_data(vtk, σ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"For other functionality, and more information refer to the WriteVTK.jl README. In particular, for exporting the solution at multiple time steps, the section on PVD files is useful.","category":"page"},{"location":"manual/export/#Exporting-with-DofHandler","page":"Export","title":"Exporting with DofHandler","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"There is an even more convenient way to export a solution vector u – using the DofHandler. The DofHandler already contains all of the information needed, such as the names of our fields and if they are scalar or vector fields. But most importantly the DofHandler knows about the numbering and distribution of degrees of freedom, and thus knows how to \"distribute\" the solution vector on the grid. For example, lets say we have a DofHandler dh and a solution vector u:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", dh)\nvtk_point_data(vtk, dh, u)\nvtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"or with a do-block:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\n    vtk_cell_data(vtk, σ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"When vtk_point_data is used with a DofHandler all of the fields will be written to the VTK file, and the names will be determined by the fieldname symbol that was used when the field was added to the DofHandler.","category":"page"},{"location":"manual/export/#Exporting-Boundary-Conditions","page":"Export","title":"Exporting Boundary Conditions","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"There is also a vtk_point_data which accepts a ConstraintHandler. This method is useful to verify that the boundary conditions are applied where they are supposed to. For a ConstraintHandler ch we can export the boundary conditions as","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"boundary-conditions\", grid) do vtk\n    vtk_point_data(vtk, ch)\nend","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"This will export zero-valued fields with ones on the parts where the boundary conditions are active.","category":"page"},{"location":"reference/dofhandler/","page":"DofHandler","title":"DofHandler","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/dofhandler/#DofHandler","page":"DofHandler","title":"DofHandler","text":"","category":"section"},{"location":"reference/dofhandler/","page":"DofHandler","title":"DofHandler","text":"DofHandler","category":"page"},{"location":"reference/dofhandler/#Ferrite.DofHandler","page":"DofHandler","title":"Ferrite.DofHandler","text":"DofHandler(grid::Grid)\n\nConstruct a DofHandler based on the grid grid.\n\n\n\n\n\n","category":"type"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/heat_equation.jl\"","category":"page"},{"location":"examples/heat_equation/#Heat-Equation","page":"Heat Equation","title":"Heat Equation","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"tip: Tip\nThis example is also available as a Jupyter notebook: heat_equation.ipynb","category":"page"},{"location":"examples/heat_equation/#Introduction","page":"Heat Equation","title":"Introduction","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The heat equation is the \"Hello, world!\" equation of finite elements. Here we solve the equation on a unit square, with a uniform internal source. The strong form of the (linear) heat equation is given by","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":" -nabla cdot (k nabla u) = f  quad x in Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set f = 1 and k = 1. We will consider homogeneous Dirichlet boundary conditions such that","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"u(x) = 0 quad x in partial Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where partial Omega denotes the boundary of Omega.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The resulting weak form is given by","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"int_Omega nabla v cdot nabla u  dOmega = int_Omega v  dOmega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where v is a suitable test function.","category":"page"},{"location":"examples/heat_equation/#Commented-Program","page":"Heat Equation","title":"Commented Program","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"First we load Ferrite, and some other packages we need","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, SparseArrays","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We start  generating a simple grid with 20x20 quadrilateral elements using generate_grid. The generator defaults to the unit square, so we don't need to specify the corners of the domain.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"grid = generate_grid(Quadrilateral, (20, 20));\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Trial-and-test-functions","page":"Heat Equation","title":"Trial and test functions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"A CellValues facilitates the process of evaluating values and gradients of test and trial functions (among other things). Since the problem is a scalar problem we will use a CellScalarValues object. To define this we need to specify an interpolation space for the shape functions. We use Lagrange functions (both for interpolating the function and the geometry) based on the reference \"cube\". We also define a quadrature rule based on the same reference cube. We combine the interpolation and the quadrature rule to a CellScalarValues object.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Degrees-of-freedom","page":"Heat Equation","title":"Degrees of freedom","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we need to define a DofHandler, which will take care of numbering and distribution of degrees of freedom for our approximated fields. We create the DofHandler and then add a single field called u. Lastly we close! the DofHandler, it is now that the dofs are distributed for all the elements.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now that we have distributed all our dofs we can create our tangent matrix, using create_sparsity_pattern. This function returns a sparse matrix with the correct elements stored.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"K = create_sparsity_pattern(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We can inspect the pattern using the spy function from UnicodePlots.jl. By default the stored values are set to 0, so we first need to fill the stored values, e.g. K.nzval with something meaningful.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using UnicodePlots\nfill!(K.nzval, 1.0)\nspy(K; height = 15)","category":"page"},{"location":"examples/heat_equation/#Boundary-conditions","page":"Heat Equation","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"In Ferrite constraints like Dirichlet boundary conditions are handled by a ConstraintHandler.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"ch = ConstraintHandler(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we need to add constraints to ch. For this problem we define homogeneous Dirichlet boundary conditions on the whole boundary, i.e. the union of all the face sets on the boundary.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"∂Ω = union(getfaceset.((grid, ), [\"left\", \"right\", \"top\", \"bottom\"])...);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we are set up to define our constraint. We specify which field the condition is for, and our combined face set ∂Ω. The last argument is a function which takes the spatial coordinate x and the current time t and returns the prescribed value. In this case it is trivial – no matter what x and t we return 0. When we have specified our constraint we add! it to ch.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dbc = Dirichlet(:u, ∂Ω, (x, t) -> 0)\nadd!(ch, dbc);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We also need to close! and update! our boundary conditions. When we call close! the dofs which will be constrained by the boundary conditions are calculated and stored in our ch object. Since the boundary conditions are, in this case, independent of time we can update! them directly with e.g. t = 0.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"close!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Assembling-the-linear-system","page":"Heat Equation","title":"Assembling the linear system","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we have all the pieces needed to assemble the linear system, K u = f. We define a function, doassemble to do the assembly, which takes our cellvalues, the sparse matrix and our DofHandler as input arguments. The function returns the assembled stiffness matrix, and the force vector.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function doassemble(cellvalues::CellScalarValues{dim}, K::SparseMatrixCSC, dh::DofHandler) where {dim}","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We allocate the element stiffness matrix and element force vector just once before looping over all the cells instead of allocating them every time in the loop.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we define the global force vector f and use that and the stiffness matrix K and create an assembler. The assembler is just a thin wrapper around f and K and some extra storage to make the assembling faster.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It is now time to loop over all the cells in our grid. We do this by iterating over a CellIterator. The iterator caches some useful things for us, for example the nodal coordinates for the cell, and the local degrees of freedom.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    @inbounds for cell in CellIterator(dh)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Always remember to reset the element stiffness matrix and force vector since we reuse them for all elements.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        fill!(Ke, 0)\n        fill!(fe, 0)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"For each cell we also need to reinitialize the cached values in cellvalues.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        reinit!(cellvalues, cell)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It is now time to loop over all the quadrature points in the cell and assemble the contribution to Ke and fe. The integration weight can be queried from cellvalues by getdetJdV.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"For each quadrature point we loop over all the (local) shape functions. We need the value and gradient of the testfunction v and also the gradient of the trial function u. We get all of these from cellvalues.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The last step in the element loop is to assemble Ke and fe into the global K and f with assemble!.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Solution-of-the-system","page":"Heat Equation","title":"Solution of the system","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The last step is to solve the system. First we call doassemble to obtain the global stiffness matrix K and force vector f.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"K, f = doassemble(cellvalues, K, dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To account for the boundary conditions we use the apply! function. This modifies elements in K and f respectively, such that we can get the correct solution vector u by using \\.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"apply!(K, f, ch)\nu = K \\ f;\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Exporting-to-VTK","page":"Heat Equation","title":"Exporting to VTK","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To visualize the result we export the grid and our field u to a VTK-file, which can be viewed in e.g. ParaView.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vtk_grid(\"heat_equation\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\nend","category":"page"},{"location":"examples/heat_equation/#heat_equation-plain-program","page":"Heat Equation","title":"Plain Program","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Below follows a version of the program without any comments. The file is also available here: heat_equation.jl","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, SparseArrays\n\ngrid = generate_grid(Quadrilateral, (20, 20));\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\n\nK = create_sparsity_pattern(dh);\n\nusing UnicodePlots\nfill!(K.nzval, 1.0)\nspy(K; height = 15)\n\nch = ConstraintHandler(dh);\n\n∂Ω = union(getfaceset.((grid, ), [\"left\", \"right\", \"top\", \"bottom\"])...);\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> 0)\nadd!(ch, dbc);\n\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction doassemble(cellvalues::CellScalarValues{dim}, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\n\nK, f = doassemble(cellvalues, K, dh);\n\napply!(K, f, ch)\nu = K \\ f;\n\nvtk_grid(\"heat_equation\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\nend\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/l2_projection.jl\"","category":"page"},{"location":"examples/l2_projection/#L2-projection","page":"L2-projection","title":"L2-projection","text":"","category":"section"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"(Image: )","category":"page"},{"location":"examples/l2_projection/#Introduction","page":"L2-projection","title":"Introduction","text":"","category":"section"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"This example continues from the Heat equation example, where the temperature field was determined on a square domain. In this example, we first compute the heat flux in each integration point (based on the solved temperature field) and then we do an L2-projection of the fluxes to the nodes of the mesh. By doing this, we can more easily visualize integration points quantities.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"The L2-projection is defined as follows: Find projection q(boldsymbolx) in L_2(Omega) such that","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"int v q  mathrmdOmega = int v d  mathrmdOmega quad forall v in L_2(Omega)","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"where d is the quadrature data to project. Since the flux is a vector the projection function will be solved with multiple right hand sides, e.g. with d = q_x and d = q_y for this 2D problem.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Ferrite has functionality for doing much of this automatically, as displayed in the code below. In particular L2Projector for assembling the left hand side, and project for assembling the right hand sides and solving for the projection.","category":"page"},{"location":"examples/l2_projection/#Implementation","page":"L2-projection","title":"Implementation","text":"","category":"section"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Start by simply running the Heat equation example to solve the problem","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"include(\"heat_equation.jl\");\nnothing #hide","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Next we define a function that computes the heat flux for each integration point in the domain. Fourier's law is adopted, where the conductivity tensor is assumed to be isotropic with unit conductivity lambda = 1  q = - nabla u, where u is the temperature.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"function compute_heat_fluxes(cellvalues::CellScalarValues{dim,T}, dh::DofHandler, a) where {dim,T}\n\n    n = getnbasefunctions(cellvalues)\n    cell_dofs = zeros(Int, n)\n    nqp = getnquadpoints(cellvalues)\n\n    # Allocate storage for the fluxes to store\n    q = [Vec{2,T}[] for _ in 1:getncells(dh.grid)]\n\n    for (cell_num, cell) in enumerate(CellIterator(dh))\n        q_cell = q[cell_num]\n        celldofs!(cell_dofs, dh, cell_num)\n        aᵉ = a[cell_dofs]\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:nqp\n            q_qp = - function_gradient(cellvalues, q_point, aᵉ)\n            push!(q_cell, q_qp)\n        end\n    end\n    return q\nend\nnothing # hide","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Now call the function to get all the fluxes.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"q_gp = compute_heat_fluxes(cellvalues, dh, u);\nnothing #hide","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Next, create an L2Projector using the same interpolation as was used to approximate the temperature field. On instantiation, the projector assembles the coefficient matrix M and computes the Cholesky factorization of it. By doing so, the projector can be reused without having to invert M every time.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"projector = L2Projector(ip, grid);\nnothing #hide","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Project the integration point values to the nodal values","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"q_nodes = project(projector, q_gp, qr);\nnothing #hide","category":"page"},{"location":"examples/l2_projection/#Exporting-to-VTK","page":"L2-projection","title":"Exporting to VTK","text":"","category":"section"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"To visualize the heat flux, we export the projected field q_nodes to a VTK-file, which can be viewed in e.g. ParaView.","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"vtk_grid(\"heat_equation_flux\", grid) do vtk\n    vtk_point_data(vtk, q_nodes, \"q\")\nend;\nnothing #hide","category":"page"},{"location":"examples/l2_projection/#l2_projection-plain-program","page":"L2-projection","title":"Plain Program","text":"","category":"section"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"Below follows a version of the program without any comments. The file is also available here: l2_projection.jl","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"include(\"heat_equation.jl\");\n\nfunction compute_heat_fluxes(cellvalues::CellScalarValues{dim,T}, dh::DofHandler, a) where {dim,T}\n\n    n = getnbasefunctions(cellvalues)\n    cell_dofs = zeros(Int, n)\n    nqp = getnquadpoints(cellvalues)\n\n    # Allocate storage for the fluxes to store\n    q = [Vec{2,T}[] for _ in 1:getncells(dh.grid)]\n\n    for (cell_num, cell) in enumerate(CellIterator(dh))\n        q_cell = q[cell_num]\n        celldofs!(cell_dofs, dh, cell_num)\n        aᵉ = a[cell_dofs]\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:nqp\n            q_qp = - function_gradient(cellvalues, q_point, aᵉ)\n            push!(q_cell, q_qp)\n        end\n    end\n    return q\nend\n\nq_gp = compute_heat_fluxes(cellvalues, dh, u);\n\nprojector = L2Projector(ip, grid);\n\nq_nodes = project(projector, q_gp, qr);\n\nvtk_grid(\"heat_equation_flux\", grid) do vtk\n    vtk_point_data(vtk, q_nodes, \"q\")\nend;\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"","category":"page"},{"location":"examples/l2_projection/","page":"L2-projection","title":"L2-projection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it Ferrite.","category":"page"},{"location":"manual/boundary_conditions/#Dirichlet-Boundary-Conditions","page":"Boundary Conditions","title":"Dirichlet Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At a Dirichlet boundary the solution is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To be able to tell which degrees of freedom we should constrain we need the DofHandler.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ch = ConstraintHandler(dh)","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"TBW","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"note: Examples\nThe following commented examples makes use of Dirichlet boundary conditions:Heat Equation\nTODO","category":"page"},{"location":"manual/boundary_conditions/#Neumann-Boundary-Conditions","page":"Boundary Conditions","title":"Neumann Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At the Neumann part of the boundary we know something about the gradient of the solution.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"As an example, the following code snippet can be included in the element routine, to evaluate the boundary integral:","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"for face in 1:nfaces(cell)\n    if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"Neumann Boundary\")\n        reinit!(facevalues, cell, face)\n        for q_point in 1:getnquadpoints(facevalues)\n            dΓ = getdetJdV(facevalues, q_point)\n            for i in 1:getnbasefunctions(facevalues)\n                δu = shape_value(facevalues, q_point, i)\n                fe[i] += δu * b * dΓ\n            end\n        end\n    end\nend","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We start by looping over all the faces of the cell, next we have to check if this particular face is located on the boundary, and then also check that the face is located on our face-set called \"Neumann Boundary\". If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize facevalues for this face, using reinit!. When reinit!ing facevalues we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"note: Examples\nThe following commented examples makes use of Neumann boundary conditions:TODO","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"#Ferrite.jl","page":"Home","title":"Ferrite.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple finite element toolbox written in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ferrite is a finite element toolbox that provides functionalities to implement finite element analysis in Julia. The aim is to be general and to keep mathematical abstractions. The main functionalities of the package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Facilitate integration using different quadrature rules.\nDefine different finite element interpolations.\nEvaluate shape functions, derivatives of shape functions etc. for the different interpolations and quadrature rules.\nEvaluate functions and derivatives in the finite element space.\nGenerate simple grids.\nExport grids and solutions to VTK.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to get started with Ferrite is to look at the documented examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nFerrite is still under development. If you find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the Ferrite GitHub page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install Ferrite from the Pkg REPL (press ] in the Julia REPL to enter pkg> mode):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Ferrite-FEM/Ferrite.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nAlternative installation method:julia> import Pkg; Pkg.add(PackageSpec(url = \"https://github.com/Ferrite-FEM/Ferrite.jl.git\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ferrite","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/assembly/#Assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"When the local stiffness matrix and force vector have been calculated they should be assembled into the global stiffness matrix and the global force vector. This is just a matter of adding the local matrix and vector to the global one, at the correct place. Consider e.g. assembling the local stiffness matrix ke and the local force vector fe into the global K and f respectively. These should be assembled into the row/column which corresponds to the degrees of freedom for the cell:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K[celldofs, celldofs] += ke\nf[celldofs]           += fe","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"where celldofs is the vector containing the degrees of freedom for the cell. The method above is very inefficient – it is especially costly to index into the sparse matrix K directly. Therefore we will instead use an Assembler that will help with the assembling of both the global stiffness matrix and the global force vector. It is also often convenient to create the sparse matrix just once, and reuse the allocated matrix. This is useful for e.g. iterative solvers or time dependent problems where the sparse matrix structure, or Sparsity Pattern will stay the same in every iteration/ time step.","category":"page"},{"location":"manual/assembly/#Sparsity-Pattern","page":"Assembly","title":"Sparsity Pattern","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler we can obtain the corresponding sparse matrix by using the create_sparsity_pattern function. This will setup a SparseMatrixCSC with stored values on all the places corresponding to the degree of freedom numbering in the DofHandler. This means that when we assemble into the global stiffness matrix there is no need to change the internal representation of the sparse matrix since the sparse structure will not change.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Often the finite element problem is symmetric and will result in a symmetric sparse matrix. This information is often something that the sparse solver can take advantage of. If the solver only needs half the matrix there is no need to assemble both halves. For this purpose there is a create_symmetric_sparsity_pattern function that will only create the upper half of the matrix, and return a Symmetric wrapped SparseMatrixCSC.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler dh we can obtain the (symmetric) sparsity pattern as","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nK = create_symmetric_sparsity_pattern(dh)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"The returned sparse matrix will be used together with an Assembler, which assembles efficiently into the matrix, without modifying the internal representation.","category":"page"},{"location":"manual/assembly/#Assembler","page":"Assembly","title":"Assembler","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Assembling efficiently into the sparse matrix requires some extra workspace. This workspace is allocated in an Assembler. start_assemble is used to create an Assembler:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"A = start_assemble(K)\nA = start_assemble(K, f)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"where K is the global stiffness matrix, and f the global force vector. It is optional to give the force vector to the assembler – sometimes there is no need to assemble a global force vector.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"fds","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"assemble!(A, celldofs, ke)\nassemble!(A, celldofs, ke, fe)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"To give a more","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nf = zeros(ndofs(dh))\nA = start_assemble(K, f)\n\nfor cell in CellIterator(dh)\n    ke, fe = ...\n    assemble!(A, celldofs(cell), ke, fe)\nend","category":"page"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ConstraintHandler\nDirichlet\nadd!\nclose!","category":"page"},{"location":"reference/boundary_conditions/#Ferrite.ConstraintHandler","page":"Boundary Conditions","title":"Ferrite.ConstraintHandler","text":"ConstraintHandler\n\nCollection of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.Dirichlet","page":"Boundary Conditions","title":"Ferrite.Dirichlet","text":"Dirichlet(u, ∂Ω, f)\nDirichlet(u, ∂Ω, f, component)\n\nCreate a Dirichlet boundary condition on u on the ∂Ω part of the boundary. f is a function that takes two arguments, x and t where x is the spatial coordinate and t is the current time, and returns the prescribed value. For example, here we create a Dirichlet condition for the :u field, on the faceset called ∂Ω and the value given by the sin function:\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t))\n\nIf :u is a vector field we can specify which component the condition should be applied to by specifying component. component can be given either as an integer, or as a vector, for example:\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t), 1)      # applied to component 1\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t), [1, 3]) # applied to component 1 and 3\n\nDirichlet boundary conditions are added to a ConstraintHandler which applies the condition via apply!.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.add!","page":"Boundary Conditions","title":"Ferrite.add!","text":"add!(ch::ConstraintHandler, dbc::Dirichlet)\n\nAdd a Dirichlet boundary condition to the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.close!","page":"Boundary Conditions","title":"Ferrite.close!","text":"close!(dh::MixedDofHandler)\n\nCloses the dofhandler and creates degrees of freedom for each cell. Dofs are created in the following order: Go through each FieldHandler in the order they were added. For each field in the FieldHandler, create dofs for the cell. This means that dofs on a particular cell will be numbered according to the fields; first dofs for field 1, then field 2, etc.\n\n\n\n\n\nclose!(ch::ConstraintHandler)\n\nClose and finalize the ConstraintHandler.\n\n\n\n\n\n","category":"function"}]
}
