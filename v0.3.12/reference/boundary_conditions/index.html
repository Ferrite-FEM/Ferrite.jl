<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Conditions · Ferrite.jl</title><meta name="title" content="Boundary Conditions · Ferrite.jl"/><meta property="og:title" content="Boundary Conditions · Ferrite.jl"/><meta property="twitter:title" content="Boundary Conditions · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/boundary_conditions/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/boundary_conditions/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/boundary_conditions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs (Ctrl + /)"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../manual/fe_intro/">Introduction to FEM</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../manual/assembly/">Assembly</a></li><li><a class="tocitem" href="../../manual/boundary_conditions/">Initial and Boundary Conditions</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/grid/">Grid</a></li><li><a class="tocitem" href="../../manual/export/">Export</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../overview/">Documentation of examples</a></li><li><a class="tocitem" href="../../examples/heat_equation/">Heat Equation</a></li><li><a class="tocitem" href="../../examples/postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../../examples/helmholtz/">Helmholtz equation</a></li><li><a class="tocitem" href="../../examples/incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="tocitem" href="../../examples/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../examples/threaded_assembly/">Threaded Assembly</a></li><li><a class="tocitem" href="../../examples/plasticity/">von Mises plasticity</a></li><li><a class="tocitem" href="../../examples/transient_heat_equation/">Time Dependent Problems</a></li><li><a class="tocitem" href="../../examples/landau/">Ginzburg-Landau model energy minimization</a></li><li><a class="tocitem" href="../../examples/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../examples/quasi_incompressible_hyperelasticity/">Nearly Incompressible Hyperelasticity</a></li><li><a class="tocitem" href="../../examples/ns_vs_diffeq/">Incompressible Navier-Stokes Equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../examples/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../examples/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../examples/topology_optimization/">Topology optimization</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../interpolations/">Interpolation</a></li><li><a class="tocitem" href="../fevalues/">FEValues</a></li><li><a class="tocitem" href="../dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li class="is-active"><a class="tocitem" href>Boundary Conditions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Initial-conditions"><span>Initial conditions</span></a></li></ul></li><li><a class="tocitem" href="../grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../export/">Postprocessing</a></li><li><a class="tocitem" href="../utils/">Development utility functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Boundary Conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Conditions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/reference/boundary_conditions.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h1><ul><li><a href="#Ferrite.ConstraintHandler"><code>Ferrite.ConstraintHandler</code></a></li><li><a href="#Ferrite.Dirichlet"><code>Ferrite.Dirichlet</code></a></li><li><a href="#Ferrite.PeriodicDirichlet"><code>Ferrite.PeriodicDirichlet</code></a></li><li><a href="#Ferrite.RHSData"><code>Ferrite.RHSData</code></a></li><li><a href="#Ferrite.add!"><code>Ferrite.add!</code></a></li><li><a href="#Ferrite.apply!"><code>Ferrite.apply!</code></a></li><li><a href="#Ferrite.apply_analytical!"><code>Ferrite.apply_analytical!</code></a></li><li><a href="#Ferrite.apply_assemble!"><code>Ferrite.apply_assemble!</code></a></li><li><a href="#Ferrite.apply_local!"><code>Ferrite.apply_local!</code></a></li><li><a href="#Ferrite.apply_rhs!"><code>Ferrite.apply_rhs!</code></a></li><li><a href="#Ferrite.apply_zero!"><code>Ferrite.apply_zero!</code></a></li><li><a href="#Ferrite.close!"><code>Ferrite.close!</code></a></li><li><a href="#Ferrite.collect_periodic_faces"><code>Ferrite.collect_periodic_faces</code></a></li><li><a href="#Ferrite.collect_periodic_faces!"><code>Ferrite.collect_periodic_faces!</code></a></li><li><a href="#Ferrite.get_rhs_data"><code>Ferrite.get_rhs_data</code></a></li><li><a href="#Ferrite.update!"><code>Ferrite.update!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Ferrite.ConstraintHandler" href="#Ferrite.ConstraintHandler"><code>Ferrite.ConstraintHandler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstraintHandler</code></pre><p>Collection of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.Dirichlet" href="#Ferrite.Dirichlet"><code>Ferrite.Dirichlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dirichlet(u::Symbol, ∂Ω::Set, f::Function, components=nothing)</code></pre><p>Create a Dirichlet boundary condition on <code>u</code> on the <code>∂Ω</code> part of the boundary. <code>f</code> is a function of the form <code>f(x)</code> or <code>f(x, t)</code> where <code>x</code> is the spatial coordinate and <code>t</code> is the current time, and returns the prescribed value. <code>components</code> specify the components of <code>u</code> that are prescribed by this condition. By default all components of <code>u</code> are prescribed.</p><p>For example, here we create a Dirichlet condition for the <code>:u</code> field, on the faceset called <code>∂Ω</code> and the value given by the <code>sin</code> function:</p><p><em>Examples</em></p><pre><code class="language-julia hljs"># Obtain the faceset from the grid
∂Ω = getfaceset(grid, &quot;boundary-1&quot;)

# Prescribe scalar field :s on ∂Ω to sin(t)
dbc = Dirichlet(:s, ∂Ω, (x, t) -&gt; sin(t))

# Prescribe all components of vector field :v on ∂Ω to 0
dbc = Dirichlet(:v, ∂Ω, x -&gt; 0 * x)

# Prescribe component 2 and 3 of vector field :v on ∂Ω to [sin(t), cos(t)]
dbc = Dirichlet(:v, ∂Ω, (x, t) -&gt; [sin(t), cos(t)], [2, 3])</code></pre><p><code>Dirichlet</code> boundary conditions are added to a <a href="#Ferrite.ConstraintHandler"><code>ConstraintHandler</code></a> which applies the condition via <a href="#Ferrite.apply!"><code>apply!</code></a> and/or <a href="#Ferrite.apply_zero!"><code>apply_zero!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L2-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.PeriodicDirichlet" href="#Ferrite.PeriodicDirichlet"><code>Ferrite.PeriodicDirichlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicDirichlet(u::Symbol, face_mapping, components=nothing)
PeriodicDirichlet(u::Symbol, face_mapping, R::AbstractMatrix, components=nothing)
PeriodicDirichlet(u::Symbol, face_mapping, f::Function, components=nothing)</code></pre><p>Create a periodic Dirichlet boundary condition for the field <code>u</code> on the face-pairs given in <code>face_mapping</code>. The mapping can be computed with <a href="#Ferrite.collect_periodic_faces"><code>collect_periodic_faces</code></a>. The constraint ensures that degrees-of-freedom on the mirror face are constrained to the corresponding degrees-of-freedom on the image face. <code>components</code> specify the components of <code>u</code> that are prescribed by this condition. By default all components of <code>u</code> are prescribed.</p><p>If the mapping is not aligned with the coordinate axis (e.g. rotated) a rotation matrix <code>R</code> should be passed to the constructor. This matrix rotates dofs on the mirror face to the image face. Note that this is only applicable for vector-valued problems.</p><p>To construct an inhomogeneous periodic constraint it is possible to pass a function <code>f</code>. Note that this is currently only supported when the periodicity is aligned with the coordinate axes.</p><p>See the manual section on <a href="../../manual/boundary_conditions/#Periodic-boundary-conditions">Periodic boundary conditions</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L1021-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.collect_periodic_faces" href="#Ferrite.collect_periodic_faces"><code>Ferrite.collect_periodic_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collect_periodic_faces(grid::Grid, mset, iset, transform::Union{Function,Nothing}=nothing)</code></pre><p>Match all mirror faces in <code>mset</code> with a corresponding image face in <code>iset</code>. Return a dictionary which maps each mirror face to a image face. The result can then be passed to <a href="#Ferrite.PeriodicDirichlet"><code>PeriodicDirichlet</code></a>.</p><p><code>mset</code> and <code>iset</code> can be given as a <code>String</code> (an existing face set in the grid) or as a <code>Set{FaceIndex}</code> directly.</p><p>By default this function looks for a matching face in the directions of the coordinate system. For other types of periodicities the <code>transform</code> function can be used. The <code>transform</code> function is applied on the coordinates of the image face, and is expected to transform the coordinates to the matching locations in the mirror set.</p><p>See also: <a href="#Ferrite.collect_periodic_faces!"><code>collect_periodic_faces!</code></a>, <a href="#Ferrite.PeriodicDirichlet"><code>PeriodicDirichlet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L1390-L1406">source</a></section><section><div><pre><code class="language-julia hljs">collect_periodic_faces(grid::Grid, all_faces::Union{Set{FaceIndex},String,Nothing}=nothing)</code></pre><p>Split all faces in <code>all_faces</code> into image and mirror sets. For each matching pair, the face located further along the vector <code>(1, 1, 1)</code> becomes the image face.</p><p>If no set is given, all faces on the outer boundary of the grid (i.e. all faces that do not have a neighbor) is used.</p><p>See also: <a href="#Ferrite.collect_periodic_faces!"><code>collect_periodic_faces!</code></a>, <a href="#Ferrite.PeriodicDirichlet"><code>PeriodicDirichlet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L1411-L1421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.collect_periodic_faces!" href="#Ferrite.collect_periodic_faces!"><code>Ferrite.collect_periodic_faces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collect_periodic_faces!(face_map::Vector{PeriodicFacePair}, grid::Grid, mset, iset, transform::Union{Function,Nothing})</code></pre><p>Same as <a href="#Ferrite.collect_periodic_faces"><code>collect_periodic_faces</code></a> but adds all matches to the existing <code>face_map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L1427-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.add!" href="#Ferrite.add!"><code>Ferrite.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add!(dh::AbstractDofHandler, name::Symbol, dim::Int[, ip::Interpolation])</code></pre><p>Add a <code>dim</code>-dimensional <code>Field</code> called <code>name</code> which is approximated by <code>ip</code> to <code>dh</code>.</p><p>The field is added to all cells of the underlying grid. In case no interpolation <code>ip</code> is given, the default interpolation of the grid&#39;s celltype is used.  If the grid uses several celltypes, <a href="../dofhandler/#Ferrite.add!-Tuple{MixedDofHandler, FieldHandler}"><code>add!(dh::MixedDofHandler, fh::FieldHandler)</code></a> must be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/DofHandler.jl#L106-L114">source</a></section><section><div><pre><code class="language-julia hljs">add!(dh::MixedDofHandler, fh::FieldHandler)</code></pre><p>Add all fields of the <a href="../dofhandler/#Ferrite.FieldHandler"><code>FieldHandler</code></a> <code>fh</code> to <code>dh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/MixedDofHandler.jl#L135-L139">source</a></section><section><div><pre><code class="language-julia hljs">add!(ch::ConstraintHandler, dbc::Dirichlet)</code></pre><p>Add a <code>Dirichlet</code> boundary condition to the <code>ConstraintHandler</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L236-L240">source</a></section><section><div><pre><code class="language-julia hljs">add!(ch::ConstraintHandler, ac::AffineConstraint)</code></pre><p>Add the <code>AffineConstraint</code> to the <code>ConstraintHandler</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.close!" href="#Ferrite.close!"><code>Ferrite.close!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">close!(dh::AbstractDofHandler)</code></pre><p>Closes <code>dh</code> and creates degrees of freedom for each cell.</p><p>If there are several fields, the dofs are added in the following order: For a <code>MixedDofHandler</code>, go through each <code>FieldHandler</code> in the order they were added. For each field in the <code>FieldHandler</code> or in the <code>DofHandler</code> (again, in the order the fields were added), create dofs for the cell. This means that dofs on a particular cell, the dofs will be numbered according to the fields; first dofs for field 1, then field 2, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/MixedDofHandler.jl#L190-L201">source</a></section><section><div><pre><code class="language-julia hljs">close!(ch::ConstraintHandler)</code></pre><p>Close and finalize the <code>ConstraintHandler</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.update!" href="#Ferrite.update!"><code>Ferrite.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update!(ch::ConstraintHandler, time::Real=0.0)</code></pre><p>Update time-dependent inhomogeneities for the new time. This calls <code>f(x)</code> or <code>f(x, t)</code> when applicable, where <code>f</code> is the function(s) corresponding to the constraints in the handler, to compute the inhomogeneities.</p><p>Note that this is called implicitly in <code>close!(::ConstraintHandler)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L403-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.apply!" href="#Ferrite.apply!"><code>Ferrite.apply!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)</code></pre><p>Adjust the matrix <code>K</code> and right hand side <code>rhs</code> to account for the Dirichlet boundary conditions specified in <code>ch</code> such that <code>K \ rhs</code> gives the expected solution.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>apply!(K, rhs, ch)</code> essentially calculates</p><p><code>rhs[free_dofs] = rhs[free_dofs] - K[free_dofs, constrained_dofs] * a[constrained]</code></p><p>where <code>a[constrained]</code> are the inhomogeneities.  Consequently, the sign of <code>rhs</code> matters (in contrast to for <code>apply_zero!</code>).</p><p>apply!(v::AbstractVector, ch::ConstraintHandler)</p></div></div><p>Apply Dirichlet boundary conditions and affine constraints, specified in <code>ch</code>, to the solution vector <code>v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">K, f = assemble_system(...) # Assemble system
apply!(K, f, ch)            # Adjust K and f to account for boundary conditions
u = K \ f                   # Solve the system, u should be &quot;approximately correct&quot;
apply!(u, ch)               # Explicitly make sure bcs are correct</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The last operation is not strictly necessary since the boundary conditions should already be fulfilled after <code>apply!(K, f, ch)</code>. However, solvers of linear systems are not exact, and thus <code>apply!(u, ch)</code> can be used to make sure the boundary conditions are fulfilled exactly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L542-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.apply_zero!" href="#Ferrite.apply_zero!"><code>Ferrite.apply_zero!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_zero!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)</code></pre><p>Adjust the matrix <code>K</code> and the right hand side <code>rhs</code> to account for prescribed Dirichlet boundary conditions and affine constraints such that <code>du = K \ rhs</code> gives the expected  result (e.g. <code>du</code> zero for all prescribed degrees of freedom).</p><pre><code class="nohighlight hljs">apply_zero!(v::AbstractVector, ch::ConstraintHandler)</code></pre><p>Zero-out values in <code>v</code> corresponding to prescribed degrees of freedom and update values  prescribed by affine constraints, such that if <code>a</code> fullfills the constraints, <code>a ± v</code> also will.</p><p>These methods are typically used in e.g. a Newton solver where the increment, <code>du</code>, should be prescribed to zero even for non-homogeneouos boundary conditions.</p><p>See also: <a href="#Ferrite.apply!"><code>apply!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">u = un + Δu                 # Current guess
K, g = assemble_system(...) # Assemble residual and tangent for current guess
apply_zero!(K, g, ch)       # Adjust tangent and residual to take prescribed values into account
ΔΔu = K \ g                # Compute the (negative) increment, prescribed values are &quot;approximately&quot; zero
apply_zero!(ΔΔu, ch)        # Make sure values are exactly zero
Δu .-= ΔΔu                  # Update current guess</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The last call to <code>apply_zero!</code> is only strictly necessary for affine constraints.  However, even if the Dirichlet boundary conditions should be fulfilled after  <code>apply!(K, g, ch)</code>, solvers of linear systems are not exact.  <code>apply!(ΔΔu, ch)</code> can be used to make sure the values for the prescribed degrees of freedom are fulfilled exactly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L578-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.apply_local!" href="#Ferrite.apply_local!"><code>Ferrite.apply_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_local!(
    local_matrix::AbstractMatrix, local_vector::AbstractVector,
    global_dofs::AbstractVector, ch::ConstraintHandler;
    apply_zero::Bool = false
)</code></pre><p>Similar to <a href="#Ferrite.apply!"><code>apply!</code></a> but perform condensation of constrained degrees-of-freedom locally in <code>local_matrix</code> and <code>local_vector</code> <em>before</em> they are to be assembled into the global system.</p><p>When the keyword argument <code>apply_zero</code> is <code>true</code> all inhomogeneities are set to <code>0</code> (cf. <a href="#Ferrite.apply!"><code>apply!</code></a> vs <a href="#Ferrite.apply_zero!"><code>apply_zero!</code></a>).</p><p>This method can only be used if all constraints are &quot;local&quot;, i.e. no constraint couples with dofs outside of the element dofs (<code>global_dofs</code>) since condensation of such constraints requires writing to entries in the global matrix/vector. For such a case, <a href="#Ferrite.apply_assemble!"><code>apply_assemble!</code></a> can be used instead.</p><p>Note that this method is destructive since it, by definition, modifies <code>local_matrix</code> and <code>local_vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L1713-L1734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.apply_assemble!" href="#Ferrite.apply_assemble!"><code>Ferrite.apply_assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_assemble!(
    assembler::AbstractSparseAssembler, ch::ConstraintHandler,
    global_dofs::AbstractVector{Int},
    local_matrix::AbstractMatrix, local_vector::AbstractVector;
    apply_zero::Bool = false
)</code></pre><p>Assemble <code>local_matrix</code> and <code>local_vector</code> into the global system in <code>assembler</code> by first doing constraint condensation using <a href="#Ferrite.apply_local!"><code>apply_local!</code></a>.</p><p>This is similar to using <a href="#Ferrite.apply_local!"><code>apply_local!</code></a> followed by <a href="../assembly/#Ferrite.assemble!"><code>assemble!</code></a> with the advantage that non-local constraints can be handled, since this method can write to entries of the global matrix and vector outside of the indices in <code>global_dofs</code>.</p><p>When the keyword argument <code>apply_zero</code> is <code>true</code> all inhomogeneities are set to <code>0</code> (cf. <a href="#Ferrite.apply!"><code>apply!</code></a> vs <a href="#Ferrite.apply_zero!"><code>apply_zero!</code></a>).</p><p>Note that this method is destructive since it modifies <code>local_matrix</code> and <code>local_vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/assembler.jl#L242-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.get_rhs_data" href="#Ferrite.get_rhs_data"><code>Ferrite.get_rhs_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_rhs_data(ch::ConstraintHandler, A::SparseMatrixCSC) -&gt; RHSData</code></pre><p>Returns the needed <a href="#Ferrite.RHSData"><code>RHSData</code></a> for <a href="#Ferrite.apply_rhs!"><code>apply_rhs!</code></a>.</p><p>This must be used when the same stiffness matrix is reused for multiple steps, for example when timestepping, with different non-homogeneouos Dirichlet boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L111-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.apply_rhs!" href="#Ferrite.apply_rhs!"><code>Ferrite.apply_rhs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_rhs!(data::RHSData, f::AbstractVector, ch::ConstraintHandler, applyzero::Bool=false)</code></pre><p>Applies the boundary condition to the right-hand-side vector without modifying the stiffness matrix.</p><p>See also: <a href="#Ferrite.get_rhs_data"><code>get_rhs_data</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.RHSData" href="#Ferrite.RHSData"><code>Ferrite.RHSData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RHSData</code></pre><p>Stores the constrained columns and mean of the diagonal of stiffness matrix <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/ConstraintHandler.jl#L101-L105">source</a></section></article><h1 id="Initial-conditions"><a class="docs-heading-anchor" href="#Initial-conditions">Initial conditions</a><a id="Initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-conditions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Ferrite.apply_analytical!" href="#Ferrite.apply_analytical!"><code>Ferrite.apply_analytical!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_analytical!(
    a::AbstractVector, dh::AbstractDofHandler, fieldname::Symbol, 
    f::Function, cellset=1:getncells(dh.grid))</code></pre><p>Apply a solution <code>f(x)</code> by modifying the values in the degree of freedom vector <code>a</code> pertaining to the field <code>fieldname</code> for all cells in <code>cellset</code>. The function <code>f(x)</code> are given the spatial coordinate of the degree of freedom. For scalar fields, <code>f(x)::Number</code>, and for vector fields with dimension <code>dim</code>, <code>f(x)::Vec{dim}</code>.</p><p>This function can be used to apply initial conditions for time dependent problems.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function only works for standard nodal finite element interpolations when the function value at the (algebraic) node is equal to the corresponding degree of freedom value. This holds for e.g. Lagrange and Serendipity interpolations, including sub- and superparametric elements.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/ac098f085cc311bffa45eb57fce833ec4b75e9fe/src/Dofs/apply_analytical.jl#L12-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../assembly/">« Assembly</a><a class="docs-footer-nextpage" href="../grid/">Grid &amp; AbstractGrid »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 28 February 2023 13:49">Tuesday 28 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
