var documenterSearchIndex = {"docs":
[{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/incompressible_elasticity.jl\"","category":"page"},{"location":"examples/incompressible_elasticity/#Incompressible-Elasticity","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: incompressible_elasticity.ipynb","category":"page"},{"location":"examples/incompressible_elasticity/#Introduction","page":"Incompressible Elasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Mixed elements can be used to overcome locking when the material becomes incompressible. However, for an element to be stable, it needs to fulfill the LBB condition. In this example we will consider two different element formulations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"linear displacement with linear pressure approximation (does not fulfill LBB)\nquadratic displacement with linear pressure approximation (does fulfill LBB)","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The quadratic/linear element is also known as the Taylor-Hood element. We will consider Cook's Membrane with an applied traction on the right hand side.","category":"page"},{"location":"examples/incompressible_elasticity/#Commented-Program","page":"Incompressible Elasticity","title":"Commented Program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing BlockArrays, SparseArrays, LinearAlgebra","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"First we generate a simple grid, specifying the 4 corners of Cooks membrane.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Next we define a function to set up our cell- and facevalues.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We create a DofHandler, with two fields, :u and :p, with possibly different interpolations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We also need to add Dirichlet boundary conditions on the \"clamped\" faceset. We specify a homogeneous Dirichlet bc on the displacement field, :u.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The material is linear elastic, which is here specified by the shear and bulk moduli","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct LinearElasticity{T}\n    G::T\n    K::T\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Now to the assembling of the stiffness matrix. This mixed formulation leads to a blocked element matrix. Since Ferrite does not force us to use any particular matrix type we will use a PseudoBlockArray from BlockArrays.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function doassemble(cellvalues_u::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim},\n                    facevalues_u::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, mp::LinearElasticity) where {dim}\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    # traction vector\n    t = Vec{2}((0.0, 1/16))\n    # cache ɛdev outside the element routine to avoid some unnecessary allocations\n    ɛdev = [zero(SymmetricTensor{2, dim}) for i in 1:getnbasefunctions(cellvalues_u)]\n\n    for cell in CellIterator(dh)\n        fill!(ke, 0)\n        fill!(fe, 0)\n        assemble_up!(ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n        assemble!(assembler, celldofs(cell), fe, ke)\n    end\n\n    return K, f\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The element routine integrates the local stiffness and force vector for all elements. Since the problem results in a symmetric matrix we choose to only assemble the lower part, and then symmetrize it after the loop over the quadrature points.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function assemble_up!(Ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    u▄, p▄ = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    @inbounds for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ɛdev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            divδu = shape_divergence(cellvalues_u, q_point, i)\n            δu = shape_value(cellvalues_u, q_point, i)\n            for j in 1:i\n                Ke[BlockIndex((u▄, u▄), (i, j))] += 2 * mp.G * ɛdev[i] ⊡ ɛdev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδu = shape_divergence(cellvalues_u, q_point, j)\n                Ke[BlockIndex((p▄, u▄), (i, j))] += -δp * divδu * dΩ\n            end\n            for j in 1:i\n                p = shape_value(cellvalues_p, q_point, j)\n                Ke[BlockIndex((p▄, p▄), (i, j))] += - 1/mp.K * δp * p * dΩ\n            end\n\n        end\n    end\n\n    symmetrize_lower!(Ke)\n\n    # We integrate the Neumann boundary using the facevalues.\n    # We loop over all the faces in the cell, then check if the face\n    # is in our `\"traction\"` faceset.\n    @inbounds for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"traction\")\n            reinit!(facevalues_u, cell, face)\n            for q_point in 1:getnquadpoints(facevalues_u)\n                dΓ = getdetJdV(facevalues_u, q_point)\n                for i in 1:n_basefuncs_u\n                    δu = shape_value(facevalues_u, q_point, i)\n                    fe[i] += (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Now we have constructed all the necessary components, we just need a function to put it all together.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function solve(ν, interpolation_u, interpolation_p)\n    # material\n    Emod = 1.\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    mp = LinearElasticity(Gmod, Kmod)\n\n    # grid, dofhandler, boundary condition\n    n = 50\n    grid = create_cook_grid(n, n)\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    dbc = create_bc(dh)\n\n    # cellvalues\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # assembly and solve\n    K = create_sparsity_pattern(dh);\n    K, f = doassemble(cellvalues_u, cellvalues_p, facevalues_u, K, grid, dh, mp);\n    apply!(K, f, dbc)\n    u = Symmetric(K) \\ f;\n\n    # export\n    filename = \"cook_\" * (isa(interpolation_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\") *\n                         \"_linear\"\n    vtk_grid(filename, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\n    return u\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"All that is left is to solve the problem. We choose a value of Poissons ratio that is near incompressibility – ν = 05 – and thus expect the linear/linear approximation to return garbage, and the quadratic/linear approximation to be stable.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"linear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\n\nu1 = solve(0.4999999, linear, linear)\nu2 = solve(0.4999999, quadratic, linear);\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#incompressible_elasticity-plain-program","page":"Incompressible Elasticity","title":"Plain Program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Below follows a version of the program without any comments. The file is also available here: incompressible_elasticity.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing BlockArrays, SparseArrays, LinearAlgebra\n\nfunction create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\n\nstruct LinearElasticity{T}\n    G::T\n    K::T\nend\n\nfunction doassemble(cellvalues_u::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim},\n                    facevalues_u::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, mp::LinearElasticity) where {dim}\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    # traction vector\n    t = Vec{2}((0.0, 1/16))\n    # cache ɛdev outside the element routine to avoid some unnecessary allocations\n    ɛdev = [zero(SymmetricTensor{2, dim}) for i in 1:getnbasefunctions(cellvalues_u)]\n\n    for cell in CellIterator(dh)\n        fill!(ke, 0)\n        fill!(fe, 0)\n        assemble_up!(ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n        assemble!(assembler, celldofs(cell), fe, ke)\n    end\n\n    return K, f\nend;\n\nfunction assemble_up!(Ke, fe, cell, cellvalues_u, cellvalues_p, facevalues_u, grid, mp, ɛdev, t)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    u▄, p▄ = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    @inbounds for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ɛdev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            divδu = shape_divergence(cellvalues_u, q_point, i)\n            δu = shape_value(cellvalues_u, q_point, i)\n            for j in 1:i\n                Ke[BlockIndex((u▄, u▄), (i, j))] += 2 * mp.G * ɛdev[i] ⊡ ɛdev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδu = shape_divergence(cellvalues_u, q_point, j)\n                Ke[BlockIndex((p▄, u▄), (i, j))] += -δp * divδu * dΩ\n            end\n            for j in 1:i\n                p = shape_value(cellvalues_p, q_point, j)\n                Ke[BlockIndex((p▄, p▄), (i, j))] += - 1/mp.K * δp * p * dΩ\n            end\n\n        end\n    end\n\n    symmetrize_lower!(Ke)\n\n    # We integrate the Neumann boundary using the facevalues.\n    # We loop over all the faces in the cell, then check if the face\n    # is in our `\"traction\"` faceset.\n    @inbounds for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"traction\")\n            reinit!(facevalues_u, cell, face)\n            for q_point in 1:getnquadpoints(facevalues_u)\n                dΓ = getdetJdV(facevalues_u, q_point)\n                for i in 1:n_basefuncs_u\n                    δu = shape_value(facevalues_u, q_point, i)\n                    fe[i] += (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nfunction solve(ν, interpolation_u, interpolation_p)\n    # material\n    Emod = 1.\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    mp = LinearElasticity(Gmod, Kmod)\n\n    # grid, dofhandler, boundary condition\n    n = 50\n    grid = create_cook_grid(n, n)\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    dbc = create_bc(dh)\n\n    # cellvalues\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # assembly and solve\n    K = create_sparsity_pattern(dh);\n    K, f = doassemble(cellvalues_u, cellvalues_p, facevalues_u, K, grid, dh, mp);\n    apply!(K, f, dbc)\n    u = Symmetric(K) \\ f;\n\n    # export\n    filename = \"cook_\" * (isa(interpolation_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\") *\n                         \"_linear\"\n    vtk_grid(filename, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\n    return u\nend\n\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\n\nu1 = solve(0.4999999, linear, linear)\nu2 = solve(0.4999999, quadratic, linear);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/postprocessing.jl\"","category":"page"},{"location":"examples/postprocessing/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"(Image: )","category":"page"},{"location":"examples/postprocessing/#Introduction","page":"Postprocessing","title":"Introduction","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"After running a simulation, we usually want to visualize the results in different ways. The L2Projector and the PointEvalHandler build a pipeline for doing so. With the L2Projector, integration point quantities can be projected to the nodes. The PointEvalHandler enables evaluation of the finite element approximated function in any coordinate in the domain. Thus with the combination of both functionalities, both nodal quantities and integration point quantities can be evaluated in any coordinate, allowing for example cut-planes through 3D structures or cut-lines through 2D-structures.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"This example continues from the Heat equation example, where the temperature field was determined on a square domain. In this example, we first compute the heat flux in each integration point (based on the solved temperature field) and then we do an L2-projection of the fluxes to the nodes of the mesh. By doing this, we can more easily visualize integration points quantities. Finally, we visualize the temperature field and the heat fluxes along a cut-line.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"The L2-projection is defined as follows: Find projection q(boldsymbolx) in L_2(Omega) such that","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"int v q  mathrmdOmega = int v d  mathrmdOmega quad forall v in L_2(Omega)","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"where d is the quadrature data to project. Since the flux is a vector the projection function will be solved with multiple right hand sides, e.g. with d = q_x and d = q_y for this 2D problem.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Ferrite has functionality for doing much of this automatically, as displayed in the code below. In particular L2Projector for assembling the left hand side, and project for assembling the right hand sides and solving for the projection.","category":"page"},{"location":"examples/postprocessing/#Implementation","page":"Postprocessing","title":"Implementation","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Start by simply running the Heat equation example to solve the problem","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"include(\"heat_equation.jl\");\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Next we define a function that computes the heat flux for each integration point in the domain. Fourier's law is adopted, where the conductivity tensor is assumed to be isotropic with unit conductivity lambda = 1  q = - nabla u, where u is the temperature.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"function compute_heat_fluxes(cellvalues::CellScalarValues{dim,T}, dh::DofHandler, a) where {dim,T}\n\n    n = getnbasefunctions(cellvalues)\n    cell_dofs = zeros(Int, n)\n    nqp = getnquadpoints(cellvalues)\n\n    # Allocate storage for the fluxes to store\n    q = [Vec{2,T}[] for _ in 1:getncells(dh.grid)]\n\n    for (cell_num, cell) in enumerate(CellIterator(dh))\n        q_cell = q[cell_num]\n        celldofs!(cell_dofs, dh, cell_num)\n        aᵉ = a[cell_dofs]\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:nqp\n            q_qp = - function_gradient(cellvalues, q_point, aᵉ)\n            push!(q_cell, q_qp)\n        end\n    end\n    return q\nend\nnothing # hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Now call the function to get all the fluxes.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"q_gp = compute_heat_fluxes(cellvalues, dh, u);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Next, create an L2Projector using the same interpolation as was used to approximate the temperature field. On instantiation, the projector assembles the coefficient matrix M and computes the Cholesky factorization of it. By doing so, the projector can be reused without having to invert M every time.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"projector = L2Projector(ip, grid);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Project the integration point values to the nodal values","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"q_projected = project(projector, q_gp, qr; project_to_nodes=false); # TODO: this should be default.\nnothing #hide","category":"page"},{"location":"examples/postprocessing/#Exporting-to-VTK","page":"Postprocessing","title":"Exporting to VTK","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"To visualize the heat flux, we export the projected field q_projected to a VTK-file, which can be viewed in e.g. ParaView.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"vtk_grid(\"heat_equation_flux\", grid) do vtk\n    # TODO: This doesn't work (correctly) yet (https://github.com/Ferrite-FEM/Ferrite.jl/issues/278)\n    vtk_point_data(vtk, q_projected, \"q\")\nend;\nnothing #hide","category":"page"},{"location":"examples/postprocessing/#Point-Evaluation","page":"Postprocessing","title":"Point Evaluation","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"(Image: )","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Consider a cut-line through the domain, like the black line in the figure above. We will evaluate the temperature and the heat flux distribution along a horizontal line.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"points = [Vec((x, 0.75)) for x in range(-1.0, 1.0, length=101)];\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"First, we need to generate a PointEvalHandler. This will find and store the cells containing the input points.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"ph = PointEvalHandler(grid, points);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"After the L2-Projection, the heat fluxes q_projected are stored in the DoF-ordering determined by the projector's internal DoFHandler, so to evalute the flux q at our points we give the PointEvalHandler, the L2Projector and the values q_projected.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"q_points = get_point_values(ph, projector, q_projected);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"We can also extract the field values, here the temperature, right away from the result vector of the simulation, that is stored in u. These values are stored in the order of our initial DofHandler so the input is not the PointEvalHandler, the original DofHandler, the dof-vector u, and (optionally for single-field problems) the name of the field. from the L2Projection, the values are stored in the order of the degrees of freedom.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"u_points = Ferrite.get_point_values(ph, dh, u, :u);\nnothing #hide","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Now, we can plot the temperature and flux values with the help of any plotting library, e.g. Plots.jl. To do this, we need to import the package:","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"import Plots","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Firstly, we are going to plot the temperature values along the given line.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Plots.plot(getindex.(points,1), u_points, xlabel=\"x (coordinate)\", ylabel=\"u (temperature)\", label=nothing)","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Secondly, the horizontal heat flux (i.e. the first component of the heat flux vector) is plotted.","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Plots.plot(getindex.(points,1), getindex.(q_points,1), xlabel=\"x (coordinate)\", ylabel=\"q_x (flux in x-direction)\", label=nothing)","category":"page"},{"location":"examples/postprocessing/#postprocessing-plain-program","page":"Postprocessing","title":"Plain Program","text":"","category":"section"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Below follows a version of the program without any comments. The file is also available here: postprocessing.jl","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"include(\"heat_equation.jl\");\n\nfunction compute_heat_fluxes(cellvalues::CellScalarValues{dim,T}, dh::DofHandler, a) where {dim,T}\n\n    n = getnbasefunctions(cellvalues)\n    cell_dofs = zeros(Int, n)\n    nqp = getnquadpoints(cellvalues)\n\n    # Allocate storage for the fluxes to store\n    q = [Vec{2,T}[] for _ in 1:getncells(dh.grid)]\n\n    for (cell_num, cell) in enumerate(CellIterator(dh))\n        q_cell = q[cell_num]\n        celldofs!(cell_dofs, dh, cell_num)\n        aᵉ = a[cell_dofs]\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:nqp\n            q_qp = - function_gradient(cellvalues, q_point, aᵉ)\n            push!(q_cell, q_qp)\n        end\n    end\n    return q\nend\n\nq_gp = compute_heat_fluxes(cellvalues, dh, u);\n\nprojector = L2Projector(ip, grid);\n\nq_projected = project(projector, q_gp, qr; project_to_nodes=false); # TODO: this should be default.\n\nvtk_grid(\"heat_equation_flux\", grid) do vtk\n    # TODO: This doesn't work (correctly) yet (https://github.com/Ferrite-FEM/Ferrite.jl/issues/278)\n    vtk_point_data(vtk, q_projected, \"q\")\nend;\n\npoints = [Vec((x, 0.75)) for x in range(-1.0, 1.0, length=101)];\n\nph = PointEvalHandler(grid, points);\n\nq_points = get_point_values(ph, projector, q_projected);\n\nu_points = Ferrite.get_point_values(ph, dh, u, :u);\n\nimport Plots\n\nPlots.plot(getindex.(points,1), u_points, xlabel=\"x (coordinate)\", ylabel=\"u (temperature)\", label=nothing)\n\nPlots.plot(getindex.(points,1), getindex.(q_points,1), xlabel=\"x (coordinate)\", ylabel=\"q_x (flux in x-direction)\", label=nothing)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"","category":"page"},{"location":"examples/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"reference/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ConstraintHandler\nDirichlet\nadd!\nclose!","category":"page"},{"location":"reference/boundary_conditions/#Ferrite.ConstraintHandler","page":"Boundary Conditions","title":"Ferrite.ConstraintHandler","text":"ConstraintHandler\n\nCollection of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.Dirichlet","page":"Boundary Conditions","title":"Ferrite.Dirichlet","text":"Dirichlet(u, ∂Ω, f)\nDirichlet(u, ∂Ω, f, component)\n\nCreate a Dirichlet boundary condition on u on the ∂Ω part of the boundary. f is a function that takes two arguments, x and t where x is the spatial coordinate and t is the current time, and returns the prescribed value. For example, here we create a Dirichlet condition for the :u field, on the faceset called ∂Ω and the value given by the sin function:\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t))\n\nIf :u is a vector field we can specify which component the condition should be applied to by specifying component. component can be given either as an integer, or as a vector, for example:\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t), 1)      # applied to component 1\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> sin(t), [1, 3]) # applied to component 1 and 3\n\nDirichlet boundary conditions are added to a ConstraintHandler which applies the condition via apply!.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary_conditions/#Ferrite.add!","page":"Boundary Conditions","title":"Ferrite.add!","text":"add!(ch::ConstraintHandler, dbc::Dirichlet)\n\nAdd a Dirichlet boundary condition to the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary_conditions/#Ferrite.close!","page":"Boundary Conditions","title":"Ferrite.close!","text":"close!(dh::MixedDofHandler)\n\nCloses the dofhandler and creates degrees of freedom for each cell. Dofs are created in the following order: Go through each FieldHandler in the order they were added. For each field in the FieldHandler, create dofs for the cell. This means that dofs on a particular cell will be numbered according to the fields; first dofs for field 1, then field 2, etc.\n\n\n\n\n\nclose!(ch::ConstraintHandler)\n\nClose and finalize the ConstraintHandler.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/interpolations/#reference-interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"Interpolation\ngetnbasefunctions\ngetdim\ngetrefshape\ngetorder","category":"page"},{"location":"reference/interpolations/#Ferrite.Interpolation","page":"Interpolation","title":"Ferrite.Interpolation","text":"Interpolation{dim, ref_shape, order}()\n\nReturn an Interpolation of given dimension dim, reference shape (see see AbstractRefShape) ref_shape and order order. order corresponds to the highest order term in the polynomial. The interpolation is used to define shape functions to interpolate a function between nodes.\n\nThe following interpolations are implemented:\n\nLagrange{1,RefCube,1}\nLagrange{1,RefCube,2}\nLagrange{2,RefCube,1}\nLagrange{2,RefCube,2}\nLagrange{2,RefTetrahedron,1}\nLagrange{2,RefTetrahedron,2}\nLagrange{3,RefCube,1}\nSerendipity{2,RefCube,2}\nSerendipity{3,RefCube,2}\nLagrange{3,RefTetrahedron,1}\nLagrange{3,RefTetrahedron,2}\n\nExamples\n\njulia> ip = Lagrange{2,RefTetrahedron,2}()\nFerrite.Lagrange{2,Ferrite.RefTetrahedron,2}()\n\njulia> getnbasefunctions(ip)\n6\n\n\n\n\n\n","category":"type"},{"location":"reference/interpolations/#Ferrite.getnbasefunctions","page":"Interpolation","title":"Ferrite.getnbasefunctions","text":"Return the number of base functions for an Interpolation or Values object.\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getdim","page":"Interpolation","title":"Ferrite.getdim","text":"Return the dimension of an Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getrefshape","page":"Interpolation","title":"Ferrite.getrefshape","text":"Return the reference shape of an Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/interpolations/#Ferrite.getorder","page":"Interpolation","title":"Ferrite.getorder","text":"Return the polynomial order of the Interpolation\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/fevalues/#FEValues","page":"FEValues","title":"FEValues","text":"","category":"section"},{"location":"reference/fevalues/#reference-cellvalues","page":"FEValues","title":"CellValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"CellValues\nreinit!\ngetnquadpoints\ngetdetJdV\n\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\n\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate","category":"page"},{"location":"reference/fevalues/#Ferrite.CellValues","page":"FEValues","title":"Ferrite.CellValues","text":"CellScalarValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\nCellVectorValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA CellValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. in the finite element cell. There are two different types of CellValues: CellScalarValues and CellVectorValues. As the names suggest, CellScalarValues utilizes scalar shape functions and CellVectorValues utilizes vectorial shape functions. For a scalar field, the CellScalarValues type should be used. For vector field, both subtypes can be used.\n\nArguments:\n\nT: an optional argument (default to Float64) to determine the type the internal data is stored as.\nquad_rule: an instance of a QuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of a Interpolation which is used to interpolate the geometry\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.reinit!","page":"FEValues","title":"Ferrite.reinit!","text":"reinit!(cv::CellValues, x::Vector)\nreinit!(bv::FaceValues, x::Vector, face::Int)\n\nUpdate the CellValues/FaceValues object for a cell or face with coordinates x. The derivatives of the shape functions, and the new integration weights are computed.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.getnquadpoints","page":"FEValues","title":"Ferrite.getnquadpoints","text":"getnquadpoints(fe_v::Values)\n\nReturn the number of quadrature points for the Values object.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.getdetJdV","page":"FEValues","title":"Ferrite.getdetJdV","text":"getdetJdV(fe_v::Values, q_point::Int)\n\nReturn the product between the determinant of the Jacobian and the quadrature point weight for the given quadrature point: det(J(mathbfx)) w_q\n\nThis value is typically used when one integrates a function on a finite element cell or face as\n\nintlimits_Omega f(mathbfx) d Omega approx sumlimits_q = 1^n_q f(mathbfx_q) det(J(mathbfx)) w_q intlimits_Gamma f(mathbfx) d Gamma approx sumlimits_q = 1^n_q f(mathbfx_q) det(J(mathbfx)) w_q\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_value","page":"FEValues","title":"Ferrite.shape_value","text":"shape_value(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the value of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_gradient","page":"FEValues","title":"Ferrite.shape_gradient","text":"shape_gradient(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_symmetric_gradient","page":"FEValues","title":"Ferrite.shape_symmetric_gradient","text":"shape_symmetric_gradient(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the symmetric gradient of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.shape_divergence","page":"FEValues","title":"Ferrite.shape_divergence","text":"shape_divergence(fe_v::Values, q_point::Int, base_function::Int)\n\nReturn the divergence of shape function base_function evaluated in quadrature point q_point.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_value","page":"FEValues","title":"Ferrite.function_value","text":"function_value(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the value of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe value of a scalar valued function is computed as u(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) u_i where u_i are the value of u in the nodes. For a vector valued function the value is calculated as mathbfu(mathbfx) = sumlimits_i = 1^n N_i (mathbfx) mathbfu_i where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_gradient","page":"FEValues","title":"Ferrite.function_gradient","text":"function_gradient(fe_v::Values{dim}, q_point::Int, u::AbstractVector)\n\nCompute the gradient of the function in a quadrature point. u is a vector with values for the degrees of freedom. For a scalar valued function, u contains scalars. For a vector valued function, u can be a vector of scalars (for use of VectorValues) or u can be a vector of Vecs (for use with ScalarValues).\n\nThe gradient of a scalar function or a vector valued function with use of VectorValues is computed as mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx) u_i or mathbfnabla u(mathbfx) = sumlimits_i = 1^n mathbfnabla mathbfN_i (mathbfx) u_i respectively, where u_i are the nodal values of the function. For a vector valued function with use of ScalarValues the gradient is computed as mathbfnabla mathbfu(mathbfx) = sumlimits_i = 1^n mathbfu_i otimes mathbfnabla N_i (mathbfx) where mathbfu_i are the nodal values of mathbfu.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_symmetric_gradient","page":"FEValues","title":"Ferrite.function_symmetric_gradient","text":"function_symmetric_gradient(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the symmetric gradient of the function, see function_gradient. Return a SymmetricTensor.\n\nThe symmetric gradient of a scalar function is computed as left mathbfnabla  mathbfu(mathbfx_q) right^textsym =  sumlimits_i = 1^n  frac12 left mathbfnabla N_i (mathbfx_q) otimes mathbfu_i + mathbfu_i  otimes  mathbfnabla N_i (mathbfx_q) right where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.function_divergence","page":"FEValues","title":"Ferrite.function_divergence","text":"function_divergence(fe_v::Values, q_point::Int, u::AbstractVector)\n\nCompute the divergence of the vector valued function in a quadrature point.\n\nThe divergence of a vector valued functions in the quadrature point mathbfx_q) is computed as mathbfnabla cdot mathbfu(mathbfx_q) = sumlimits_i = 1^n mathbfnabla N_i (mathbfx_q) cdot mathbfu_i where mathbfu_i are the nodal values of the function.\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#Ferrite.spatial_coordinate","page":"FEValues","title":"Ferrite.spatial_coordinate","text":"spatial_coordinate(fe_v::Values{dim}, q_point::Int, x::AbstractVector)\n\nCompute the spatial coordinate in a quadrature point. x contains the nodal coordinates of the cell.\n\nThe coordinate is computed, using the geometric interpolation, as mathbfx = sumlimits_i = 1^n M_i (mathbfx) mathbfhatx_i\n\n\n\n\n\n","category":"function"},{"location":"reference/fevalues/#reference-facevalues","page":"FEValues","title":"FaceValues","text":"","category":"section"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"All of the methods for CellValues apply for FaceValues as well. In addition, there are some methods that are unique for FaecValues:","category":"page"},{"location":"reference/fevalues/","page":"FEValues","title":"FEValues","text":"FaceValues\ngetcurrentface","category":"page"},{"location":"reference/fevalues/#Ferrite.FaceValues","page":"FEValues","title":"Ferrite.FaceValues","text":"FaceScalarValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\nFaceVectorValues([::Type{T}], quad_rule::QuadratureRule, func_interpol::Interpolation, [geom_interpol::Interpolation])\n\nA FaceValues object facilitates the process of evaluating values of shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc. on the faces of finite elements. There are two different types of FaceValues: FaceScalarValues and FaceVectorValues. As the names suggest, FaceScalarValues utilizes scalar shape functions and FaceVectorValues utilizes vectorial shape functions. For a scalar field, the FaceScalarValues type should be used. For vector field, both subtypes can be used.\n\nnote: Note\nThe quadrature rule for the face should be given with one dimension lower. I.e. for a 3D case, the quadrature rule should be in 2D.\n\nArguments:\n\nT: an optional argument to determine the type the internal data is stored as.\nquad_rule: an instance of a QuadratureRule\nfunc_interpol: an instance of an Interpolation used to interpolate the approximated function\ngeom_interpol: an optional instance of an Interpolation which is used to interpolate the geometry\n\nCommon methods:\n\nreinit!\ngetnquadpoints\ngetdetJdV\nshape_value\nshape_gradient\nshape_symmetric_gradient\nshape_divergence\nfunction_value\nfunction_gradient\nfunction_symmetric_gradient\nfunction_divergence\nspatial_coordinate\n\n\n\n\n\n","category":"type"},{"location":"reference/fevalues/#Ferrite.getcurrentface","page":"FEValues","title":"Ferrite.getcurrentface","text":"getcurrentface(fv::FaceValues)\n\nReturn the current active face of the FaceValues object (from last reinit!).\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/assembly/#Assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"start_assemble\nassemble!\nend_assemble","category":"page"},{"location":"reference/assembly/#Ferrite.start_assemble","page":"Assembly","title":"Ferrite.start_assemble","text":"start_assemble([N=0]) -> Assembler\n\nCall before starting an assembly.\n\nReturns an Assembler type that is used to hold the intermediate data before an assembly is finished.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.assemble!","page":"Assembly","title":"Ferrite.assemble!","text":"assemble!(a, Ke, edof)\n\nAssembles the element matrix Ke into a.\n\n\n\n\n\nassemble!(g, ge, edof)\n\nAssembles the element residual ge into the global residual vector g.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.end_assemble","page":"Assembly","title":"Ferrite.end_assemble","text":"end_assemble(a::Assembler) -> K\n\nFinalizes an assembly. Returns a sparse matrix with the assembled values.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/","page":"Assembly","title":"Assembly","text":"create_sparsity_pattern\ncreate_symmetric_sparsity_pattern","category":"page"},{"location":"reference/assembly/#Ferrite.create_sparsity_pattern","page":"Assembly","title":"Ferrite.create_sparsity_pattern","text":"create_sparsity_pattern(dh::DofHandler)\n\nCreate the sparsity pattern corresponding to the degree of freedom numbering in the DofHandler. Return a SparseMatrixCSC with stored values in the correct places.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\n","category":"function"},{"location":"reference/assembly/#Ferrite.create_symmetric_sparsity_pattern","page":"Assembly","title":"Ferrite.create_symmetric_sparsity_pattern","text":"create_symmetric_sparsity_pattern(dh::DofHandler)\n\nCreate the symmetric sparsity pattern corresponding to the degree of freedom numbering in the DofHandler by only considering the upper triangle of the matrix. Return a Symmetric{SparseMatrixCSC}.\n\nSee the Sparsity Pattern section of the manual.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/export/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/export/#Project-to-nodes","page":"Postprocessing","title":"Project to nodes","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"L2Projector\nproject","category":"page"},{"location":"reference/export/#Ferrite.L2Projector","page":"Postprocessing","title":"Ferrite.L2Projector","text":"L2Projector(func_ip::Interpolation, grid::AbstractGrid; kwargs...)\n\nCreate an L2Projector used for projecting quadrature data. func_ip is the function interpolation used for the projection and grid the grid over which the projection is applied.\n\nKeyword arguments:\n\nqr_lhs: quadrature for the left hand side. Defaults to a quadrature which exactly integrates a mass matrix with func_ip as the interpolation.\nset: element set over which the projection applies. Defaults to all elements in the grid.\ngeom_ip: geometric interpolation. Defaults to the default interpolation for the grid.\n\nThe L2Projector acts as the integrated left hand side of the projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project.\n\nUse project to integrate the right hand side and solve for the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.project","page":"Postprocessing","title":"Ferrite.project","text":"project(proj::L2Projector, vals::Vector{Vector{T}}}, qr_rhs::QuadratureRule; project_to_nodes=true)\n\nMakes a L2 projection of data vals to the nodes of the grid using the projector proj (see L2Projector).\n\nproject integrates the right hand side, and solves the projection u from the following projection equation: Find projection u in L_2(Omega) such that\n\nint v u  mathrmdOmega = int v f  mathrmdOmega quad forall v in L_2(Omega)\n\nwhere f is the data to project, i.e. vals.\n\nThe data vals should be a vector, with length corresponding to number of elements, of vectors, with length corresponding to number of quadrature points per element, matching the number of points in qr_rhs. Example scalar input data:\n\nvals = [\n    [0.44, 0.98, 0.32], # data for quadrature point 1, 2, 3 of element 1\n    [0.29, 0.48, 0.55], # data for quadrature point 1, 2, 3 of element 2\n    # ...\n]\n\nSupported data types to project are Numbers and AbstractTensors.\n\nIf the parameter project_to_nodes is true, then the projection returns the values in the order of the mesh nodes (suitable format for exporting). If false, it returns the values corresponding to the degrees of freedom for a scalar field over the domain, which is useful if one wants to interpolate the projected values.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#Postprocessing-2","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"PointEvalHandler\nget_point_values","category":"page"},{"location":"reference/export/#Ferrite.PointEvalHandler","page":"Postprocessing","title":"Ferrite.PointEvalHandler","text":"PointEvalHandler(grid::Grid, points::AbstractVector{Vec{dim,T}}) where {dim, T}\n\nA PointEvalHandler computes the corresponding cell for each point in points and its local coordinate within the cell.\n\n\n\n\n\n","category":"type"},{"location":"reference/export/#Ferrite.get_point_values","page":"Postprocessing","title":"Ferrite.get_point_values","text":"get_point_values(ph::PointEvalHandler, proj::L2Projector, dof_values::Vector{T}) where T\nget_point_values(ph::PointEvalHandler, dh::AbstractDofHandler, dof_values::Vector{T}, [fieldname::Symbol]) where T\n\nReturn a Vector{T} (for a 1-dimensional field) or a Vector{Vec{fielddim, T}} (for a vector field) with the field values of field fieldname in the points of the PointEvalHandler. The fieldname can be omitted if only one field is stored in dh. The field values are computed based on the dof_values and interpolated to the local coordinates by the function interpolation of the corresponding field stored in the AbstractDofHandler or the L2Projector.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"reshape_to_nodes","category":"page"},{"location":"reference/export/#Ferrite.reshape_to_nodes","page":"Postprocessing","title":"Ferrite.reshape_to_nodes","text":"reshape_to_nodes(dh::AbstractDofHandler, u::Vector{T}, fieldname::Symbol) where T\n\nReshape the entries of the dof-vector u which correspond to the field fieldname in nodal order. Return a matrix with a column for every node and a row for every dimension of the field. For superparametric fields only the entries corresponding to nodes of the grid will be returned. Do not use this function for subparametric approximations.\n\n\n\n\n\n","category":"function"},{"location":"reference/export/#VTK-Export","page":"Postprocessing","title":"VTK Export","text":"","category":"section"},{"location":"reference/export/","page":"Postprocessing","title":"Postprocessing","text":"vtk_grid(filename::AbstractString, grid::Grid{dim,C,T}; compress::Bool) where {dim,C,T} \nvtk_point_data(vtk::WriteVTK.DatasetFile, data::Union{Vector{SymmetricTensor{2,dim,T,M}}},name::AbstractString) where {dim,T,M}\nvtk_point_data(vtk::WriteVTK.DatasetFile, data::Union{ Vector{Tensor{order,dim,T,M}}, Vector{SymmetricTensor{order,dim,T,M}}}, name::AbstractString) where {order,dim,T,M}\nvtk_cellset","category":"page"},{"location":"reference/export/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{C}, Tuple{dim}, Tuple{AbstractString, Grid{dim, C, T}}} where {dim, C, T}","page":"Postprocessing","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString, grid::Grid)\n\nCreate a unstructured VTK grid from a Grid. Return a DatasetFile which data can be appended to, see vtk_point_data and vtk_cell_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#WriteVTK.vtk_point_data-Union{Tuple{M}, Tuple{T}, Tuple{dim}, Tuple{WriteVTK.DatasetFile, Array{SymmetricTensor{2, dim, T, M}, 1}, AbstractString}} where {dim, T, M}","page":"Postprocessing","title":"WriteVTK.vtk_point_data","text":"vtk_point_data(vtk, data::Vector{<:SymmetricTensor{2}}, name)\n\nWrite the second order tensor field data to the vtk file. Twodimensional tensors are padded with zeros. The tensor field is written such that Paraview recognizes the tensor components, where XX corresponds to the [1,1] component and so on.\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#WriteVTK.vtk_point_data-Union{Tuple{M}, Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{WriteVTK.DatasetFile, Union{Array{SymmetricTensor{order, dim, T, M}, 1}, Array{Tensor{order, dim, T, M}, 1}}, AbstractString}} where {order, dim, T, M}","page":"Postprocessing","title":"WriteVTK.vtk_point_data","text":"vtk_point_data(vtk, data::Vector{<:Tensor}, name)\n\nWrite the tensor field data to the vtk file. Only writes the tensor values available in data. In the vtu-file, ordering of the tensor components is column-wise (just like Julia). [1 2  3 4] => 1, 3, 2, 4\n\n\n\n\n\n","category":"method"},{"location":"reference/export/#Ferrite.vtk_cellset","page":"Postprocessing","title":"Ferrite.vtk_cellset","text":"vtk_cellset(vtk, grid::Grid)\n\nExport all cell sets in the grid. Each cell set is exported with vtk_cell_data with value 1 if the cell is in the set, and 0 otherwise.\n\n\n\n\n\nvtk_cellset(vtk, grid::Grid, cellset::String)\n\nExport the cell set specified by cellset as cell data with value 1 if the cell is in the set and 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/threaded_assembly.jl\"","category":"page"},{"location":"examples/threaded_assembly/#Threaded-Assembly","page":"Threaded Assembly","title":"Threaded Assembly","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"tip: Tip\nThis example is also available as a Jupyter notebook: threaded_assembly.ipynb","category":"page"},{"location":"examples/threaded_assembly/#Example-of-a-colored-grid","page":"Threaded Assembly","title":"Example of a colored grid","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Creates a simple 2D grid and colors it. Save the example grid to a VTK file to show the coloring. No cells with the same color has any shared nodes (dofs). This means that it is safe to assemble in parallel as long as we only assemble one color at a time.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"using Ferrite, SparseArrays\n\nfunction create_example_2d_grid()\n    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))\n    cell_colors, colors = Ferrite.create_coloring(grid)\n    vtk_grid(\"colored\", grid) do vtk\n        Ferrite.vtk_cell_data_colors(vtk, grid, colors)\n    end\nend;\n\ncreate_example_2d_grid()","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"(Image: )","category":"page"},{"location":"examples/threaded_assembly/#Cantilever-beam-in-3D-with-threaded-assembly","page":"Threaded Assembly","title":"Cantilever beam in 3D with threaded assembly","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"We will now look at an example where we assemble the stiffness matrix using multiple threads. We set up a simple grid and create a coloring, then create a DofHandler, and define the material stiffness","category":"page"},{"location":"examples/threaded_assembly/#Grid-for-the-beam","page":"Threaded Assembly","title":"Grid for the beam","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_colored_cantilever_grid(celltype, n)\n    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))\n    cell_colors, final_colors = Ferrite.create_coloring(grid)\n    return grid, final_colors\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#DofHandler","page":"Threaded Assembly","title":"DofHandler","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_dofhandler(grid::Grid{dim}) where {dim}\n    dh = DofHandler(grid)\n    push!(dh, :u, dim) # Add a displacement field\n    close!(dh)\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Stiffness-tensor-for-linear-elasticity","page":"Threaded Assembly","title":"Stiffness tensor for linear elasticity","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_stiffness(::Val{dim}) where {dim}\n    E = 200e9\n    ν = 0.3\n    λ = E*ν / ((1+ν) * (1 - 2ν))\n    μ = E / (2(1+ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n    C = SymmetricTensor{4, dim}(g);\n    return C\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Threaded-data-structures","page":"Threaded Assembly","title":"Threaded data structures","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"ScratchValues is a thread-local collection of data that each thread needs to own, since we need to be able to mutate the data in the threads independently","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"struct ScratchValues{T, CV <: CellValues, FV <: FaceValues, TT <: AbstractTensor, dim, Ti}\n    Ke::Matrix{T}\n    fe::Vector{T}\n    cellvalues::CV\n    facevalues::FV\n    global_dofs::Vector{Int}\n    ɛ::Vector{TT}\n    coordinates::Vector{Vec{dim, T}}\n    assembler::Ferrite.AssemblerSparsityPattern{T, Ti}\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Each thread need its own CellValues and FaceValues (although, for this example we don't use the FaceValues)","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_values(refshape, dim, order::Int)\n    # Interpolations and values\n    interpolation_space = Lagrange{dim, refshape, 1}()\n    quadrature_rule = QuadratureRule{dim, refshape}(order)\n    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)\n    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    return cellvalues, facevalues\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Create a ScratchValues for each thread with the thread local data","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}\n    nthreads = Threads.nthreads()\n    assemblers = [start_assemble(K, f) for i in 1:nthreads]\n    cellvalues, facevalues = create_values(RefCube, dim, 2)\n\n    n_basefuncs = getnbasefunctions(cellvalues[1])\n    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]\n\n    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector\n    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]\n\n    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]\n\n    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]\n\n    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],\n                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]\nend;\nnothing #hide","category":"page"},{"location":"examples/threaded_assembly/#Threaded-assemble","page":"Threaded Assembly","title":"Threaded assemble","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"The assembly function loops over each color and does a threaded assembly for that color","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}\n\n    f = zeros(ndofs(dh))\n    scratches = create_scratchvalues(K, f, dh)\n    b = Vec{3}((0.0, 0.0, 0.0)) # Body force\n\n    for color in colors\n        # Each color is safe to assemble threaded\n        Threads.@threads for i in 1:length(color)\n            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)\n        end\n    end\n\n    return K, f\nend","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"The cell assembly function is written the same way as if it was a single threaded example. The only difference is that we unpack the variables from our scratch.","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"function assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,\n                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}\n\n    # Unpack our stuff from the scratch\n    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =\n         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,\n         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler\n\n    fill!(Ke, 0)\n    fill!(fe, 0)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n\n    # Fill up the coordinates\n    nodeids = grid.cells[cell].nodes\n    for j in 1:length(coordinates)\n        coordinates[j] = grid.nodes[nodeids[j]].x\n    end\n\n    reinit!(cellvalues, coordinates)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        for i in 1:n_basefuncs\n            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))\n        end\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(cellvalues, q_point, i)\n            fe[i] += (δu ⋅ b) * dΩ\n            ɛC = ɛ[i] ⊡ C\n            for j in 1:n_basefuncs\n                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ\n            end\n        end\n    end\n\n    celldofs!(global_dofs, dh, cell)\n    assemble!(assembler, global_dofs, fe, Ke)\nend;\n\nfunction run_assemble()\n    refshape = RefCube\n    quadrature_order = 2\n    dim = 3\n    n = 20\n    grid, colors = create_colored_cantilever_grid(Hexahedron, n);\n    dh = create_dofhandler(grid);\n\n    K = create_sparsity_pattern(dh);\n    C = create_stiffness(Val{3}());\n    # compilation\n    doassemble(K, colors, grid, dh, C);\n    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);\n    return b\nend\n\nrun_assemble()","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Running the code with different number of threads give the following runtimes:","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"1 thread  2.46 seconds\n2 threads 1.19 seconds\n3 threads 0.83 seconds\n4 threads 0.75 seconds","category":"page"},{"location":"examples/threaded_assembly/#threaded_assembly-plain-program","page":"Threaded Assembly","title":"Plain Program","text":"","category":"section"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"Below follows a version of the program without any comments. The file is also available here: threaded_assembly.jl","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"using Ferrite, SparseArrays\n\nfunction create_example_2d_grid()\n    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))\n    cell_colors, colors = Ferrite.create_coloring(grid)\n    vtk_grid(\"colored\", grid) do vtk\n        Ferrite.vtk_cell_data_colors(vtk, grid, colors)\n    end\nend;\n\ncreate_example_2d_grid()\n\nfunction create_colored_cantilever_grid(celltype, n)\n    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))\n    cell_colors, final_colors = Ferrite.create_coloring(grid)\n    return grid, final_colors\nend;\n\nfunction create_dofhandler(grid::Grid{dim}) where {dim}\n    dh = DofHandler(grid)\n    push!(dh, :u, dim) # Add a displacement field\n    close!(dh)\nend;\n\nfunction create_stiffness(::Val{dim}) where {dim}\n    E = 200e9\n    ν = 0.3\n    λ = E*ν / ((1+ν) * (1 - 2ν))\n    μ = E / (2(1+ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n    C = SymmetricTensor{4, dim}(g);\n    return C\nend;\n\nstruct ScratchValues{T, CV <: CellValues, FV <: FaceValues, TT <: AbstractTensor, dim, Ti}\n    Ke::Matrix{T}\n    fe::Vector{T}\n    cellvalues::CV\n    facevalues::FV\n    global_dofs::Vector{Int}\n    ɛ::Vector{TT}\n    coordinates::Vector{Vec{dim, T}}\n    assembler::Ferrite.AssemblerSparsityPattern{T, Ti}\nend;\n\nfunction create_values(refshape, dim, order::Int)\n    # Interpolations and values\n    interpolation_space = Lagrange{dim, refshape, 1}()\n    quadrature_rule = QuadratureRule{dim, refshape}(order)\n    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)\n    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];\n    return cellvalues, facevalues\nend;\n\nfunction create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}\n    nthreads = Threads.nthreads()\n    assemblers = [start_assemble(K, f) for i in 1:nthreads]\n    cellvalues, facevalues = create_values(RefCube, dim, 2)\n\n    n_basefuncs = getnbasefunctions(cellvalues[1])\n    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]\n\n    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector\n    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]\n\n    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]\n\n    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]\n\n    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],\n                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]\nend;\n\nfunction doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}\n\n    f = zeros(ndofs(dh))\n    scratches = create_scratchvalues(K, f, dh)\n    b = Vec{3}((0.0, 0.0, 0.0)) # Body force\n\n    for color in colors\n        # Each color is safe to assemble threaded\n        Threads.@threads for i in 1:length(color)\n            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)\n        end\n    end\n\n    return K, f\nend\n\nfunction assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,\n                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}\n\n    # Unpack our stuff from the scratch\n    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =\n         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,\n         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler\n\n    fill!(Ke, 0)\n    fill!(fe, 0)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n\n    # Fill up the coordinates\n    nodeids = grid.cells[cell].nodes\n    for j in 1:length(coordinates)\n        coordinates[j] = grid.nodes[nodeids[j]].x\n    end\n\n    reinit!(cellvalues, coordinates)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        for i in 1:n_basefuncs\n            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))\n        end\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(cellvalues, q_point, i)\n            fe[i] += (δu ⋅ b) * dΩ\n            ɛC = ɛ[i] ⊡ C\n            for j in 1:n_basefuncs\n                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ\n            end\n        end\n    end\n\n    celldofs!(global_dofs, dh, cell)\n    assemble!(assembler, global_dofs, fe, Ke)\nend;\n\nfunction run_assemble()\n    refshape = RefCube\n    quadrature_order = 2\n    dim = 3\n    n = 20\n    grid, colors = create_colored_cantilever_grid(Hexahedron, n);\n    dh = create_dofhandler(grid);\n\n    K = create_sparsity_pattern(dh);\n    C = create_stiffness(Val{3}());\n    # compilation\n    doassemble(K, colors, grid, dh, C);\n    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);\n    return b\nend\n\nrun_assemble()\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"","category":"page"},{"location":"examples/threaded_assembly/","page":"Threaded Assembly","title":"Threaded Assembly","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"using Ferrite","category":"page"},{"location":"manual/degrees_of_freedom/#Degrees-of-Freedom","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The distribution and numbering of degrees of freedom (dofs) are handled by the DofHandler. The DofHandler will be used to query information about the dofs. For example we can obtain the dofs for a particular cell, which we need when assembling the system.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"The DofHandler is based on the grid. Here we create a simple grid with Triangle cells, and then create a DofHandler based on the grid","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"grid = generate_grid(Triangle, (20, 20))\ndh = DofHandler(grid)\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/#Fields","page":"Degrees of Freedom","title":"Fields","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Before we can distribute the dofs we need to specify fields. A field is simply the unknown function(s) we are solving for. To add a field we need a name (a Symbol) and we also need to specify number of components for the field. Here we add a vector field :u (2 components for a 2D problem) and a scalar field :p.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"push!(dh, :u, 2)\npush!(dh, :p, 1)\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"Finally, when we have added all the fields, we have to close! the DofHandler. When the DofHandler is closed it will traverse the grid and distribute all the dofs for the fields we added.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"close!(dh)","category":"page"},{"location":"manual/degrees_of_freedom/#Specifying-interpolation-for-a-field","page":"Degrees of Freedom","title":"Specifying interpolation for a field","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"In the example above we did not specify which interpolation should be used for our fields :u and :p. By default iso-parametric elements will be used meaning that the interpolation that matches the grid will be used – for a linear grid a linear interpolation will be used etc. It is sometimes useful to separate the grid interpolation from the interpolation that is used to approximate our fields (e.g. sub- and super-parametric elements).","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"We can specify which interpolation that should be used for the approximation when we add the fields to the dofhandler. For example, here we add our vector field :u with a quadratic interpolation, and our :p field with a linear approximation.","category":"page"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"dh = DofHandler(grid) # hide\npush!(dh, :u, 2, Lagrange{2,RefTetrahedron,2}())\npush!(dh, :p, 1, Lagrange{2,RefTetrahedron,1}())\n# hide","category":"page"},{"location":"manual/degrees_of_freedom/#Ordering-of-Dofs","page":"Degrees of Freedom","title":"Ordering of Dofs","text":"","category":"section"},{"location":"manual/degrees_of_freedom/","page":"Degrees of Freedom","title":"Degrees of Freedom","text":"ordered in the same order as we add to dofhandler nodes -> (edges ->) faces -> cells","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/ns_vs_diffeq.jl\"","category":"page"},{"location":"examples/ns_vs_diffeq/#Incompressible-Navier-Stokes-Equations-via-DifferentialEquations.jl","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"In this example we focus on a simple but visually appealing problem from fluid dynamics, namely vortex shedding. This problem is also known as von-Karman vortex streets. Within this example, we show how to utilize DifferentialEquations.jl in tandem with Ferrite.jl to solve this space-time problem. To keep things simple we use a naive approach to discretize the system.","category":"page"},{"location":"examples/ns_vs_diffeq/#Remarks-on-DifferentialEquations.jl","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Remarks on DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Many \"time step solvers\" of DifferentialEquations.jl assume that that the problem is provided in mass matrix form. The incompressible Navier-Stokes equations as stated above yield a DAE in this form after applying a spatial discretization technique - in our case FEM. The mass matrix form of ODEs and DAEs is given as:","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"  M(t) mathrmd_t u = f(ut)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where M is a possibly time-dependent and not necessarily invertible mass matrix, u the vector of unknowns and f the right-hand-side (RHS). For us f can be interpreted as the spatial discretization of all linear and nonlinear operators depending on u and t, but not on the time derivative of u.","category":"page"},{"location":"examples/ns_vs_diffeq/#Some-Theory-on-the-Incompressible-Navier-Stokes-Equations","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Some Theory on the Incompressible Navier-Stokes Equations","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/#Problem-Description-in-Strong-Form","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Problem Description in Strong Form","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"The incompressible Navier-Stokes equations can be stated as the system","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" beginaligned\n   partial_t v = underbracenu Delta v_textviscosity - underbrace(v cdot nabla) v_textadvection - underbracenabla p_textpressure \n              0 = underbracenabla cdot v_textincompressibility\n endaligned","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where v is the unknown velocity field, p the unknown pressure field, nu the dynamic viscosity and Delta the Laplacian. In the derivation we assumed a constant density of 1 for the fluid and negligible coupling between the velocity components. Finally we see that the pressure term appears only in combination with the gradient operator, so for any solution p the function p + c is also an admissible solution, if we do not impose Dirichlet conditions on the pressure. To resolve this we introduce the implicit constraint that $ \\int_\\Omega p = 0 $.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Our setup is derived from Turek's DFG benchmark. We model a channel with size 041 times 22 and a hole of radius 005 centered at (02 02). The left side has a parabolic inflow profile, which is ramped up over time, modeled as the time dependent Dirichlet condition","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" v(xyt)\n =\n beginbmatrix\n     4 v_in(t) y (041-y)041^2 \n     0\n endbmatrix","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where v_in(t) = textclamp(t 00 10). With a dynamic viscosity of nu = 0001 this is enough to induce turbulence behind the cylinder which leads to vortex shedding. The top and bottom of our channel have no-slip conditions, i.e. v = 00^textrmT, while the right boundary has the do-nothing boundary condtion nu partial_textrmn v - p n = 0 to model outflow. With these boundary conditions we can choose the zero solution as a feasible initial condition.","category":"page"},{"location":"examples/ns_vs_diffeq/#Derivation-of-Semi-Discrete-Weak-Form","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Derivation of Semi-Discrete Weak Form","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"By multiplying test functions varphi and psi from a suitable test function space on the strong form, followed by integrating over the domain and applying partial integration to the pressure and viscosity terms we can obtain the following weak form","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" beginaligned\n   int_Omega partial_t v cdot varphi = - int_Omega nu nabla v  nabla varphi - int_Omega (v cdot nabla) v cdot varphi + int_Omega p (nabla cdot varphi) + int_partial Omega_N underbrace(nu partial_n v - p n )_=0 cdot varphi \n                                 0 = int_Omega (nabla cdot v) psi\n endaligned","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"for all possible test functions from the suitable space.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we can discretize the problem as usual with the finite element method utilizing Taylor-Hood elements (Q2Q1) to yield a stable discretization in mass matrix form:","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":" underbracebeginbmatrix\n     M_v  0 \n      0   0\n endbmatrix_=M\n beginbmatrix\n     mathrmd_thatv \n     mathrmd_thatp\n endbmatrix\n =\n underbracebeginbmatrix\n      A  B^textrmT \n      B  0\n endbmatrix_=K\n beginbmatrix\n     hatv \n     hatp\n endbmatrix\n +\n beginbmatrix\n     N(hatv hatv hatvarphi) \n     0\n endbmatrix","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Here M is the singular block mass matrix, K is the discretized Stokes operator and N the nonlinear advection term, which is also called trilinear form. hatv and hatp represent the time-dependent vectors of nodal values of the discretizations of v and p respectively, while hatvarphi is the choice for the test function in the discretization. The hats are dropped in the implementation and only stated for clarity in this section.","category":"page"},{"location":"examples/ns_vs_diffeq/#Commented-Implementation","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Commented Implementation","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we solve the problem with Ferrite and DifferentialEquations.jl. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"First we load Ferrite and some other packages we need","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"using Ferrite, SparseArrays, BlockArrays, LinearAlgebra, UnPack","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Since we do not need the complete DifferentialEquations suite, we just load the required ODE infrastructure, which can also handle DAEs in mass matrix form.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"We start off by defining our only material parameter.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"ν = 1.0/1000.0; #dynamic viscosity\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next a fine 2D rectangular grid has to be generated. We leave the cell size parametric for flexibility when playing around with the code. Note that the mesh is pretty fine, leading to a high memory consumption when feeding the equation system to direct solvers.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"dim = 2\ncell_scale_factor = 2.0\nx_cells = round(Int, cell_scale_factor*220)\ny_cells = round(Int, cell_scale_factor*41)\nx_cells = round(Int, 55/3)                  #hide\ny_cells = round(Int, 41/3)                  #hide\ngrid = generate_grid(Quadrilateral, (x_cells, y_cells), Vec{2}((0.0, 0.0)), Vec{2}((2.2, 0.41)));\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next we carve a hole B_005(0202) in the mesh by deleting the cells and update the boundary face sets. This code will be replaced once a proper mesh interface is avaliable.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"cell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05, 1:length(grid.cells))\nhole_cell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))<=0.05, 1:length(grid.cells));\nhole_face_ring = Set{FaceIndex}()\nfor hci ∈ hole_cell_indices\n    push!(hole_face_ring, FaceIndex((hci+1, 4)))\n    push!(hole_face_ring, FaceIndex((hci-1, 2)))\n    push!(hole_face_ring, FaceIndex((hci-x_cells, 3)))\n    push!(hole_face_ring, FaceIndex((hci+x_cells, 1)))\nend\ngrid.facesets[\"hole\"] = Set(filter(x->x.idx[1] ∉ hole_cell_indices, collect(hole_face_ring)));\ncell_indices_map = map(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05 ? indexin([ci], cell_indices)[1] : 0, 1:length(grid.cells))\ngrid.cells = grid.cells[cell_indices]\nfor facesetname in keys(grid.facesets)\n    grid.facesets[facesetname] = Set(map(fi -> FaceIndex( cell_indices_map[fi.idx[1]] ,fi.idx[2]), collect(grid.facesets[facesetname])))\nend;\n\ngrid = generate_grid(Quadrilateral, (x_cells, y_cells), Vec{2}((0.0, 0.0)), Vec{2}((0.55, 0.41)));   #hide\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Function-Space","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Function Space","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"To ensure stability we utilize the Taylor-Hood element pair Q2-Q1. We have to utilize the same quadrature rule for the pressure as for the velocity, because in the weak form the linear pressure term is tested against a quadratic function.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"ip_v = Lagrange{dim, RefCube, 2}()\nip_geom = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(4)\ncellvalues_v = CellVectorValues(qr, ip_v, ip_geom);\n\nip_p = Lagrange{dim, RefCube, 1}()\ncellvalues_p = CellScalarValues(qr, ip_p, ip_geom);\n\ndh = DofHandler(grid)\npush!(dh, :v, dim, ip_v)\npush!(dh, :p, 1, ip_p)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Boundary-Conditions","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Boundary Conditions","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"As in the DFG benchmark we apply no-slip conditions to the top, bottom and cylinder boundary. The no-slip condition states that the velocity of the fluid on this portion of the boundary is fixed to be zero.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"ch = ConstraintHandler(dh);\n\nnosplip_face_names = [\"top\", \"bottom\", \"hole\"];\nnosplip_face_names = [\"top\", \"bottom\"]                                  #hide\n∂Ω_noslip = union(getfaceset.((grid, ), nosplip_face_names)...);\nnoslip_bc = Dirichlet(:v, ∂Ω_noslip, (x, t) -> [0,0], [1,2])\nadd!(ch, noslip_bc);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"The left boundary has a parabolic inflow with peak velocity of 1.0. This ensures that for the given geometry the Reynolds number is 100, which is already enough to obtain some simple vortex streets. By increasing the velocity further we can obtain stronger vortices - which may need additional refinement of the grid.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"∂Ω_inflow = getfaceset(grid, \"left\");\n\nvᵢₙ(t) = clamp(t, 0.0, 1.0)*1.0 #inflow velocity\nvᵢₙ(t) = clamp(t, 0.0, 1.0)*0.3 #hide\nparabolic_inflow_profile((x,y),t) = [4*vᵢₙ(t)*y*(0.41-y)/0.41^2,0]\ninflow_bc = Dirichlet(:v, ∂Ω_inflow, parabolic_inflow_profile, [1,2])\nadd!(ch, inflow_bc);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"The outflow boundary condition has been applied on the right side of the cylinder when the weak form has been derived by setting the boundary integral to zero. It is also called the do-nothing condition. Other outflow conditions are also possible.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"∂Ω_free = getfaceset(grid, \"right\");\n\nclose!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Linear-System-Assembly","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Linear System Assembly","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next we describe how the block mass matrix and the Stokes matrix are assembled.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"For the block mass matrix M we remember that only the first equation had a time derivative and that the block mass matrix corresponds to the term arising from discretizing the time derivatives. Hence, only the upper left block has non-zero components.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"function assemble_mass_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, M::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Allocate a buffer for the local matrix and some helpers, together with the assembler.\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Mₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # It follows the assembly loop as explained in the basic tutorials.\n    mass_assembler = start_assemble(M)\n    @inbounds for cell in CellIterator(dh)\n        fill!(Mₑ, 0)\n        Ferrite.reinit!(cellvalues_v, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            # Remember that we assemble a vector mass term, hence the dot product.\n            for i in 1:n_basefuncs_v\n                φᵢ = shape_value(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    φⱼ = shape_value(cellvalues_v, q_point, j)\n                    Mₑ[BlockIndex((v▄, v▄), (i, j))] += φᵢ ⋅ φⱼ * dΩ\n                end\n            end\n        end\n        assemble!(mass_assembler, celldofs(cell), Mₑ)\n    end\n\n    return M\nend;\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Next we discuss the assembly of the Stokes matrix. Remember that we use the same function spaces for trial and test, hence the matrix has the following block form","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"  K = beginbmatrix\n      A  B^textrmT \n      B  0\n  endbmatrix","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"which is also called saddle point matrix. These problems are known to have a non-trivial kernel, which is a reflection of the strong form as discussed in the theory portion if this example.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"function assemble_stokes_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, ν, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Again, some buffers and helpers\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Kₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # Assembly loop\n    stiffness_assembler = start_assemble(K)\n    @inbounds for cell in CellIterator(dh)\n        # Don't forget to initialize everything\n        fill!(Kₑ, 0)\n\n        Ferrite.reinit!(cellvalues_v, cell)\n        Ferrite.reinit!(cellvalues_p, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Assemble local viscosity block of A","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"            for i in 1:n_basefuncs_v\n                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    ∇φⱼ = shape_gradient(cellvalues_v, q_point, j)\n                    Kₑ[BlockIndex((v▄, v▄), (i, j))] -= ν * ∇φᵢ ⊡ ∇φⱼ * dΩ\n                end\n            end","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Assemble local pressure and incompressibility blocks of B^textrmT and B.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"            for j in 1:n_basefuncs_p\n                ψ = shape_value(cellvalues_p, q_point, j)\n                for i in 1:n_basefuncs_v\n                    divφ = shape_divergence(cellvalues_v, q_point, i)\n                    Kₑ[BlockIndex((v▄, p▄), (i, j))] += (divφ * ψ) * dΩ\n                    Kₑ[BlockIndex((p▄, v▄), (j, i))] += (ψ * divφ) * dΩ\n                end\n            end\n        end\n\n        # Assemble `Kₑ` into the Stokes matrix `K`.\n        assemble!(stiffness_assembler, celldofs(cell), Kₑ)\n    end\n    return K\nend;\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#Solution-of-the-semi-discretized-system-via-DifferentialEquations.jl","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Solution of the semi-discretized system via DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"First we assemble the linear portions for efficiency. These matrices are assumed to be constant over time.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"T = 10.0\nΔt₀ = 0.01\nΔt_save = 0.1\n\nM = create_sparsity_pattern(dh);\nM = assemble_mass_matrix(cellvalues_v, cellvalues_p, M, dh);\n\nK = create_sparsity_pattern(dh);\nK = assemble_stokes_matrix(cellvalues_v, cellvalues_p, ν, K, dh);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"These are our initial conditions. We start from the zero solution, because it is trivially admissible if the Dirichlet conditions are zero everywhere on the Dirichlet boundary for t=0. Note that the time stepper is also doing fine if the Dirichlet condition is non-zero and not too pathological.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"u₀ = zeros(ndofs(dh))\napply!(u₀, ch);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"DifferentialEquations assumes dense matrices by default, which is not feasible for semi-discretization of finite element models. We communicate that a sparse matrix with specified pattern should be utilized through the jac_prototyp argument. It is simple to see that the Jacobian and the stiffness matrix share the same sparsity pattern, since they share the same relation between trial and test functions.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"jac_sparsity = sparse(K);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"To apply the nonlinear portion of the Navier-Stokes problem we simply hand over the dof handler and cell values to the right-hand-side (RHS) as a parameter. Further the pre-assembled linear part (which is time independent) is passed to save some runtime. To apply the time-dependent Dirichlet BCs, we also hand over the constraint handler. The basic idea to apply the Dirichlet BCs consistently is that we copy the current solution u, apply the Dirichlet BCs on the copy, evaluate the discretized RHS of the Navier-Stokes equations with this vector and finally set the RHS to zero on every constraint. This way we obtain a correct solution for all dofs which are not Dirichlet constrained. These dofs are then corrected in a post-processing step, when evaluating the solution vector at specific time points. It should be finally noted that this trick does not work out of the box for constraining algebraic portion of the DAE, i.e. if we would like to put a Dirichlet BC on pressure dofs. As a workaround we have to set f_textrmi = 1 instead of f_textrmi = 0, because otherwise the equation system gets singular. This is obvious when we remember that our mass matrix is zero for these dofs, such that we obtain the equation 0 cdot mathrmd_t p_textrmi = 1 cdot p_textrmi, which now has a unique solution.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"struct RHSparams\n    K::SparseMatrixCSC\n    ch::ConstraintHandler\n    dh::DofHandler\n    cellvalues_v::CellVectorValues\nend\np = RHSparams(K, ch, dh, cellvalues_v)\n\nfunction navierstokes!(du,u_uc,p,t)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Unpack the struct to save some allocations.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    @unpack K,ch,dh,cellvalues_v = p","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"We start by applying the time-dependent Dirichlet BCs. Note that we are not allowed to mutate u_uc! We also can not pre-allocate this variable if we want to use AD to derive the Jacobian matrix, which appears in the utilized implicit Euler. If we hand over the Jacobian analytically to the solver, or when utilizing a method which does not require building the Jacobian, then we could also hand over a buffer for u in our RHSparams structure to save the allocations made here.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    u = u_uc\n    update!(ch, t)\n    apply!(u, ch)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we apply the rhs of the Navier-Stokes equations","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    # Linear contribution (Stokes operator)\n    du .= K * u\n\n    # nonlinear contribution\n    n_basefuncs = getnbasefunctions(cellvalues_v)\n    for cell in CellIterator(dh)\n        Ferrite.reinit!(cellvalues_v, cell)\n        all_celldofs = celldofs(cell)\n        v_celldofs = all_celldofs[dof_range(dh, :v)]\n        v_cell = u[v_celldofs]\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            ∇v = function_gradient(cellvalues_v, q_point, v_cell)\n            v = function_value(cellvalues_v, q_point, v_cell)\n            for j in 1:n_basefuncs\n                φⱼ = shape_value(cellvalues_v, q_point, j)","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Note that in Tensors.jl the definition textrmgrad v = nabla v holds. With this information it can be quickly shown in index notation that","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"(v cdot nabla) v_textrmi = v_textrmj (partial_textrmj v_textrmi) = v (nabla v)^textrmT_textrmi","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"where we should pay attentation to the transpose of the gradient.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"                du[v_celldofs[j]] -= v ⋅ ∇v' ⋅ φⱼ * dΩ\n            end\n        end\n    end","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"For now we have to ingore the evolution of the Dirichlet BCs. The DBC dofs in the solution vector will be corrected in a post-processing step.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    apply_zero!(du, ch)\nend;\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Finally, together with our pre-assembled mass matrix, we are now able to define our problem in mass matrix form.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"rhs = ODEFunction(navierstokes!, mass_matrix=M; jac_prototype=jac_sparsity)\nproblem = ODEProblem(rhs, u₀, (0.0,T), p);\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Now we can put everything together by specifying how to solve the problem. We want to use the adaptive implicit Euler method with our custom linear solver, which helps in the enforcement of the Dirichlet BCs. Further we enable the progress bar with the progess and progress_steps arguments. Finally we have to communicate the time step length and initialization algorithm. Since we start with a valid initial state we do not use one of DifferentialEquations.jl initialization algorithms. NOTE: At the time of writing this no Hessenberg index 2 initialization is implemented.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"To visualize the result we export the grid and our fields to VTK-files, which can be viewed in ParaView by utilizing the corresponding pvd file.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"timestepper = ImplicitEuler()\nintegrator = init(\n    problem, timestepper, initializealg=NoInit(), dt=Δt₀,\n    adaptive=true, abstol=1e-3, reltol=1e-3,\n    progress=true, progress_steps=1,\n    saveat=Δt_save);\n\npvd = paraview_collection(\"vortex-street.pvd\");\nintegrator = TimeChoiceIterator(integrator, 0.0:Δt_save:T)\nfor (u_uc,t) in integrator","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"We ignored the Dirichlet constraints in the solution vector up to now, so we have to bring them back now.","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"    update!(ch, t)\n    u = u_uc\n    apply!(u, ch)\n    #compress=false flag because otherwise each vtk file will be stored in memory\n    vtk_grid(\"vortex-street-$t.vtu\", dh; compress=false) do vtk\n        vtk_point_data(vtk,dh,u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\nend\nvtk_save(pvd);\n\nusing Test                                                                  #hide\nfunction compute_divergence(dh, u, cellvalues_v)                            #hide\n    divv = 0.0                                                              #hide\n    @inbounds for (i,cell) in enumerate(CellIterator(dh))                   #hide\n        Ferrite.reinit!(cellvalues_v, cell)                                 #hide\n        for q_point in 1:getnquadpoints(cellvalues_v)                       #hide\n            dΩ = getdetJdV(cellvalues_v, q_point)                           #hide\n                                                                            #hide\n            all_celldofs = celldofs(cell)                                   #hide\n            v_celldofs = all_celldofs[dof_range(dh, :v)]                    #hide\n            v_cell = u[v_celldofs]                                          #hide\n                                                                            #hide\n            divv += function_divergence(cellvalues_v, q_point, v_cell) * dΩ #hide\n        end                                                                 #hide\n    end                                                                     #hide\n    return divv                                                             #hide\nend                                                                         #hide\n@testset \"INS OrdinaryDiffEq\" begin                                         #hide\n    u = integrator.integrator.u                                             #hide\n    Δdivv = abs(compute_divergence(dh, u, cellvalues_v))                    #hide\n    @test isapprox(Δdivv, 0.0, atol=1e-12)                                  #hide\n                                                                            #hide\n    Δv = 0.0                                                                #hide\n    for cell in CellIterator(dh)                                            #hide\n        Ferrite.reinit!(cellvalues_v, cell)                                 #hide\n        all_celldofs = celldofs(cell)                                       #hide\n        v_celldofs = all_celldofs[dof_range(dh, :v)]                        #hide\n        v_cell = u[v_celldofs]                                              #hide\n        coords = getcoordinates(cell)                                       #hide\n        for q_point in 1:getnquadpoints(cellvalues_v)                       #hide\n            dΩ = getdetJdV(cellvalues_v, q_point)                           #hide\n            coords_qp = spatial_coordinate(cellvalues_v, q_point, coords)   #hide\n            v = function_value(cellvalues_v, q_point, v_cell)               #hide\n            Δv += norm(v - parabolic_inflow_profile(coords_qp, T))^2*dΩ     #hide\n        end                                                                 #hide\n    end                                                                     #hide\n    @test isapprox(sqrt(Δv), 0.0, atol=1e-3)                                #hide\nend;                                                                        #hide\nnothing #hide","category":"page"},{"location":"examples/ns_vs_diffeq/#ns_vs_diffeq-plain-program","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Plain Program","text":"","category":"section"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"Below follows a version of the program without any comments. The file is also available here: nsvsdiffeq.jl","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"using Ferrite, SparseArrays, BlockArrays, LinearAlgebra, UnPack\n\nusing OrdinaryDiffEq\n\nν = 1.0/1000.0; #dynamic viscosity\n\ndim = 2\ncell_scale_factor = 2.0\nx_cells = round(Int, cell_scale_factor*220)\ny_cells = round(Int, cell_scale_factor*41)\ngrid = generate_grid(Quadrilateral, (x_cells, y_cells), Vec{2}((0.0, 0.0)), Vec{2}((2.2, 0.41)));\n\ncell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05, 1:length(grid.cells))\nhole_cell_indices = filter(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))<=0.05, 1:length(grid.cells));\nhole_face_ring = Set{FaceIndex}()\nfor hci ∈ hole_cell_indices\n    push!(hole_face_ring, FaceIndex((hci+1, 4)))\n    push!(hole_face_ring, FaceIndex((hci-1, 2)))\n    push!(hole_face_ring, FaceIndex((hci-x_cells, 3)))\n    push!(hole_face_ring, FaceIndex((hci+x_cells, 1)))\nend\ngrid.facesets[\"hole\"] = Set(filter(x->x.idx[1] ∉ hole_cell_indices, collect(hole_face_ring)));\ncell_indices_map = map(ci->norm(mean(map(i->grid.nodes[i].x-[0.2,0.2], Ferrite.vertices(grid.cells[ci]))))>0.05 ? indexin([ci], cell_indices)[1] : 0, 1:length(grid.cells))\ngrid.cells = grid.cells[cell_indices]\nfor facesetname in keys(grid.facesets)\n    grid.facesets[facesetname] = Set(map(fi -> FaceIndex( cell_indices_map[fi.idx[1]] ,fi.idx[2]), collect(grid.facesets[facesetname])))\nend;\n\n\nip_v = Lagrange{dim, RefCube, 2}()\nip_geom = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(4)\ncellvalues_v = CellVectorValues(qr, ip_v, ip_geom);\n\nip_p = Lagrange{dim, RefCube, 1}()\ncellvalues_p = CellScalarValues(qr, ip_p, ip_geom);\n\ndh = DofHandler(grid)\npush!(dh, :v, dim, ip_v)\npush!(dh, :p, 1, ip_p)\nclose!(dh);\n\nch = ConstraintHandler(dh);\n\nnosplip_face_names = [\"top\", \"bottom\", \"hole\"];\n∂Ω_noslip = union(getfaceset.((grid, ), nosplip_face_names)...);\nnoslip_bc = Dirichlet(:v, ∂Ω_noslip, (x, t) -> [0,0], [1,2])\nadd!(ch, noslip_bc);\n\n∂Ω_inflow = getfaceset(grid, \"left\");\n\nvᵢₙ(t) = clamp(t, 0.0, 1.0)*1.0 #inflow velocity\nparabolic_inflow_profile((x,y),t) = [4*vᵢₙ(t)*y*(0.41-y)/0.41^2,0]\ninflow_bc = Dirichlet(:v, ∂Ω_inflow, parabolic_inflow_profile, [1,2])\nadd!(ch, inflow_bc);\n\n∂Ω_free = getfaceset(grid, \"right\");\n\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction assemble_mass_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, M::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Allocate a buffer for the local matrix and some helpers, together with the assembler.\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Mₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # It follows the assembly loop as explained in the basic tutorials.\n    mass_assembler = start_assemble(M)\n    @inbounds for cell in CellIterator(dh)\n        fill!(Mₑ, 0)\n        Ferrite.reinit!(cellvalues_v, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            # Remember that we assemble a vector mass term, hence the dot product.\n            for i in 1:n_basefuncs_v\n                φᵢ = shape_value(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    φⱼ = shape_value(cellvalues_v, q_point, j)\n                    Mₑ[BlockIndex((v▄, v▄), (i, j))] += φᵢ ⋅ φⱼ * dΩ\n                end\n            end\n        end\n        assemble!(mass_assembler, celldofs(cell), Mₑ)\n    end\n\n    return M\nend;\n\nfunction assemble_stokes_matrix(cellvalues_v::CellVectorValues{dim}, cellvalues_p::CellScalarValues{dim}, ν, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    # Again, some buffers and helpers\n    n_basefuncs_v = getnbasefunctions(cellvalues_v)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    n_basefuncs = n_basefuncs_v + n_basefuncs_p\n    v▄, p▄ = 1, 2\n    Kₑ = PseudoBlockArray(zeros(n_basefuncs, n_basefuncs), [n_basefuncs_v, n_basefuncs_p], [n_basefuncs_v, n_basefuncs_p])\n\n    # Assembly loop\n    stiffness_assembler = start_assemble(K)\n    @inbounds for cell in CellIterator(dh)\n        # Don't forget to initialize everything\n        fill!(Kₑ, 0)\n\n        Ferrite.reinit!(cellvalues_v, cell)\n        Ferrite.reinit!(cellvalues_p, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n\n            for i in 1:n_basefuncs_v\n                ∇φᵢ = shape_gradient(cellvalues_v, q_point, i)\n                for j in 1:n_basefuncs_v\n                    ∇φⱼ = shape_gradient(cellvalues_v, q_point, j)\n                    Kₑ[BlockIndex((v▄, v▄), (i, j))] -= ν * ∇φᵢ ⊡ ∇φⱼ * dΩ\n                end\n            end\n\n            for j in 1:n_basefuncs_p\n                ψ = shape_value(cellvalues_p, q_point, j)\n                for i in 1:n_basefuncs_v\n                    divφ = shape_divergence(cellvalues_v, q_point, i)\n                    Kₑ[BlockIndex((v▄, p▄), (i, j))] += (divφ * ψ) * dΩ\n                    Kₑ[BlockIndex((p▄, v▄), (j, i))] += (ψ * divφ) * dΩ\n                end\n            end\n        end\n\n        # Assemble `Kₑ` into the Stokes matrix `K`.\n        assemble!(stiffness_assembler, celldofs(cell), Kₑ)\n    end\n    return K\nend;\n\nT = 10.0\nΔt₀ = 0.01\nΔt_save = 0.1\n\nM = create_sparsity_pattern(dh);\nM = assemble_mass_matrix(cellvalues_v, cellvalues_p, M, dh);\n\nK = create_sparsity_pattern(dh);\nK = assemble_stokes_matrix(cellvalues_v, cellvalues_p, ν, K, dh);\n\nu₀ = zeros(ndofs(dh))\napply!(u₀, ch);\n\njac_sparsity = sparse(K);\n\nstruct RHSparams\n    K::SparseMatrixCSC\n    ch::ConstraintHandler\n    dh::DofHandler\n    cellvalues_v::CellVectorValues\nend\np = RHSparams(K, ch, dh, cellvalues_v)\n\nfunction navierstokes!(du,u_uc,p,t)\n\n    @unpack K,ch,dh,cellvalues_v = p\n\n    u = u_uc\n    update!(ch, t)\n    apply!(u, ch)\n\n    # Linear contribution (Stokes operator)\n    du .= K * u\n\n    # nonlinear contribution\n    n_basefuncs = getnbasefunctions(cellvalues_v)\n    for cell in CellIterator(dh)\n        Ferrite.reinit!(cellvalues_v, cell)\n        all_celldofs = celldofs(cell)\n        v_celldofs = all_celldofs[dof_range(dh, :v)]\n        v_cell = u[v_celldofs]\n        for q_point in 1:getnquadpoints(cellvalues_v)\n            dΩ = getdetJdV(cellvalues_v, q_point)\n            ∇v = function_gradient(cellvalues_v, q_point, v_cell)\n            v = function_value(cellvalues_v, q_point, v_cell)\n            for j in 1:n_basefuncs\n                φⱼ = shape_value(cellvalues_v, q_point, j)\n\n                du[v_celldofs[j]] -= v ⋅ ∇v' ⋅ φⱼ * dΩ\n            end\n        end\n    end\n\n    apply_zero!(du, ch)\nend;\n\nrhs = ODEFunction(navierstokes!, mass_matrix=M; jac_prototype=jac_sparsity)\nproblem = ODEProblem(rhs, u₀, (0.0,T), p);\n\ntimestepper = ImplicitEuler()\nintegrator = init(\n    problem, timestepper, initializealg=NoInit(), dt=Δt₀,\n    adaptive=true, abstol=1e-3, reltol=1e-3,\n    progress=true, progress_steps=1,\n    saveat=Δt_save);\n\npvd = paraview_collection(\"vortex-street.pvd\");\nintegrator = TimeChoiceIterator(integrator, 0.0:Δt_save:T)\nfor (u_uc,t) in integrator\n\n    update!(ch, t)\n    u = u_uc\n    apply!(u, ch)\n    #compress=false flag because otherwise each vtk file will be stored in memory\n    vtk_grid(\"vortex-street-$t.vtu\", dh; compress=false) do vtk\n        vtk_point_data(vtk,dh,u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\nend\nvtk_save(pvd);\n\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"","category":"page"},{"location":"examples/ns_vs_diffeq/","page":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","title":"Incompressible Navier-Stokes Equations via DifferentialEquations.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/hyperelasticity.jl\"","category":"page"},{"location":"examples/hyperelasticity/#Hyperelasticity","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Keywords: hyperelasticity, finite strain, large deformations, Newton's method, conjugate gradient, automatic differentiation","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"(Image: hyperelasticity.png)","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: hyperelasticity.ipynb","category":"page"},{"location":"examples/hyperelasticity/#Introduction","page":"Hyperelasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"In this example we will solve a problem in a finite strain setting using an hyperelastic material model. In order to compute the stress we will use automatic differentiation, to solve the non-linear system we use Newton's method, and for solving the Newton increment we use conjugate gradient.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The weak format is expressed in terms of the first Piola-Kirchoff stress mathbfP as follows: Find u in mathbbU such that","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":" int_Omega delta mathbfu otimes nabla  mathbfP(mathbfu) mathrmdOmega =\nint_Omega delta mathbfu cdot mathbfb mathrmdOmega + int_Gamma^mathrmN\nmathbfu cdot mathbft mathrmdGamma\nquad forall delta mathbfu in mathbbU^0","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where mathbfu is the unknown displacement field, mathbfb is the body force, mathbft is the traction on the Neumann part of the boundary, and where mathbbU and mathbbU^0 are suitable trial and test sets.","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Ferrite, Tensors, TimerOutputs, ProgressMeter\nimport KrylovMethods, IterativeSolvers","category":"page"},{"location":"examples/hyperelasticity/#Hyperelastic-material-model","page":"Hyperelasticity","title":"Hyperelastic material model","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The stress can be derived from an energy potential, defined in terms of the right Cauchy-Green tensor mathbfC. We shall use a neo-Hookean model, where the potential can be written as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Psi(mathbfC) = fracmu2 (I_C - 3) - mu ln(J) + fraclambda2 ln(J)^2","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"where I_C = mathrmtr(C), J = sqrtdet(C) and mu and lambda material parameters. From the potential we obtain the second Piola-Kirchoff stress mathbfS as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"mathbfS = 2 fracpartial Psipartial mathbfC","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"and the tangent of mathbfS as","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"fracpartial mathbfSpartial mathbfC = 4 fracpartial Psipartial mathbfC","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"We can implement the material model as follows, where we utilize automatic differentiation for the stress and the tangent, and thus only define the potential:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"struct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 4.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Finally, for the finite element problem we need mathbfP and fracpartial mathbfPpartial mathbfF, which can be obtained by the following transformations","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"beginalign*\nmathbfP = mathbfF cdot mathbfS\nfracpartial mathbfPpartial mathbfF = mathbfF barotimes mathbfI \nfracpartial mathbfSpartial mathbfC  mathbfF^mathrmT barotimes mathbfI\n+ mathbfI barotimes mathbfS\nendalign*","category":"page"},{"location":"examples/hyperelasticity/#Finite-element-assembly","page":"Hyperelasticity","title":"Finite element assembly","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The element routine for assembling the residual and tangent stiffness is implemented as usual, with loops over quadrature points and shape functions:","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    t = Vec{3}((0.1, 0.0, 0.0)) # Traction\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F)\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function + gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face)\n            reinit!(fv, cell, face)\n            for q_point in 1:getnquadpoints(fv)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Assembling global residual and tangent","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function assemble_global!(K, f, dh, cv, fv, mp, u)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and f\n    assembler = start_assemble(K, f)\n\n    # Loop over all cells in the grid\n    @timeit \"assemble\" for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n        assemble!(assembler, global_dofs, ge, ke)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Define a main function, with a loop for Newton iterations","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"function solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    qr = QuadratureRule{3, RefTetrahedron}(1)\n    qr_face = QuadratureRule{2, RefTetrahedron}(1)\n    cv = CellVectorValues(qr, ip)\n    fv = FaceVectorValues(qr_face, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    push!(dh, :u, 3) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t, θ = deg2rad(60.0))\n        x, y, z = X\n        return t * Vec{3}(\n            (0.0,\n            L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n            L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n            ))\n    end\n\n    dbcs = ConstraintHandler(dh)\n    # Add a homogenous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(dbcs, dbc)\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\n    add!(dbcs, dbc)\n    close!(dbcs)\n    t = 0.5\n    Ferrite.update!(dbcs, t)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u  = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, dbcs)\n\n    # Create sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    g = zeros(_ndofs)\n\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1e-8\n    prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\n    while true; newton_itr += 1\n        u .= un .+ Δu # Current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u)\n        normg = norm(g[Ferrite.free_dofs(dbcs)])\n        apply_zero!(K, g, dbcs)\n        ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > 30\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using cg! from IterativeSolvers.jl\n        @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n        @assert flag == 0\n        @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n        apply_zero!(ΔΔu, dbcs)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        vtk_grid(\"hyperelasticity\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Run the simulation","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"u = solve();\nnothing #hide","category":"page"},{"location":"examples/hyperelasticity/#Plain-Program","page":"Hyperelasticity","title":"Plain Program","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Below follows a version of the program without any comments. The file is also available here: hyperelasticity.jl","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Ferrite, Tensors, TimerOutputs, ProgressMeter\nimport KrylovMethods, IterativeSolvers\n\nstruct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 4.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\n\nfunction assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    t = Vec{3}((0.1, 0.0, 0.0)) # Traction\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F)\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function + gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face)\n            reinit!(fv, cell, face)\n            for q_point in 1:getnquadpoints(fv)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\nend;\n\nfunction assemble_global!(K, f, dh, cv, fv, mp, u)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and f\n    assembler = start_assemble(K, f)\n\n    # Loop over all cells in the grid\n    @timeit \"assemble\" for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n        assemble!(assembler, global_dofs, ge, ke)\n    end\nend;\n\nfunction solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    qr = QuadratureRule{3, RefTetrahedron}(1)\n    qr_face = QuadratureRule{2, RefTetrahedron}(1)\n    cv = CellVectorValues(qr, ip)\n    fv = FaceVectorValues(qr_face, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    push!(dh, :u, 3) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t, θ = deg2rad(60.0))\n        x, y, z = X\n        return t * Vec{3}(\n            (0.0,\n            L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n            L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n            ))\n    end\n\n    dbcs = ConstraintHandler(dh)\n    # Add a homogenous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(dbcs, dbc)\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\n    add!(dbcs, dbc)\n    close!(dbcs)\n    t = 0.5\n    Ferrite.update!(dbcs, t)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u  = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, dbcs)\n\n    # Create sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    g = zeros(_ndofs)\n\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1e-8\n    prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\n    while true; newton_itr += 1\n        u .= un .+ Δu # Current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u)\n        normg = norm(g[Ferrite.free_dofs(dbcs)])\n        apply_zero!(K, g, dbcs)\n        ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > 30\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using cg! from IterativeSolvers.jl\n        @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n        @assert flag == 0\n        @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n        apply_zero!(ΔΔu, dbcs)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        vtk_grid(\"hyperelasticity\", dh) do vtkfile\n            vtk_point_data(vtkfile, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend\n\nu = solve();\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"page"},{"location":"examples/hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#von-Mises-plasticity","page":"von Mises plasticity","title":"von Mises plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"(Image: Shows the von Mises stress distribution in a cantilever beam.) Figure 1. A coarse mesh solution of a cantilever beam subjected to a load causing plastic deformations. The initial yield limit is 200 MPa but due to hardening it increases up to approximately 240 MPa.","category":"page"},{"location":"examples/plasticity/#Introduction","page":"von Mises plasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This example illustrates the use of a nonlinear material model in Ferrite. The particular model is von Mises plasticity (also know as J₂-plasticity) with isotropic hardening. The model is fully 3D, meaning that no assumptions like plane stress or plane strain are introduced.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Also note that the theory of the model is not described here, instead one is referred to standard textbooks on material modeling.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"To illustrate the use of the plasticity model, we setup and solve a FE-problem consisting of a cantilever beam loaded at its free end. But first, we shortly describe the parts of the implementation deadling with the material modeling.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: plasticity.ipynb","category":"page"},{"location":"examples/plasticity/#Material-modeling","page":"von Mises plasticity","title":"Material modeling","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This section describes the structs and methods used to implement the material model","category":"page"},{"location":"examples/plasticity/#Material-parameters-and-state-variables","page":"von Mises plasticity","title":"Material parameters and state variables","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Start by loading some necessary packages","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra, Printf","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"We define a J₂-plasticity-material, containing material parameters and the elastic stiffness Dᵉ (since it is constant)","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"struct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}}\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Next, we define a constructor for the material instance.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function J2Plasticity(E, ν, σ₀, H)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"note: Note\nAbove, we defined a constructor J2Plasticity(E, ν, σ₀, H) in terms of the more common material parameters E and ν - simply as a convenience for the user.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Define a struct to store the material state for a Gauss point.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"struct MaterialState{T, S <: SecondOrderTensor{3, T}}\n    # Store \"converged\" values\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Constructor for initializing a material state. Every quantity is set to zero.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function MaterialState()\n    return MaterialState(\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0)\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"For later use, during the post-processing step, we define a function to compute the von Mises effective stress.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function vonMises(σ)\n    s = dev(σ)\n    return sqrt(3.0/2.0 * s ⊡ s)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Constitutive-driver","page":"von Mises plasticity","title":"Constitutive driver","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This is the actual method which computes the stress and material tangent stiffness in a given integration point. Input is the current strain and the material state from the previous timestep.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function compute_stress_tangent(ϵ::SymmetricTensor{2, 3}, material::J2Plasticity, state::MaterialState)\n    # unpack some material parameters\n    G = material.G\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ   # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effective trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        return σᵗ, material.Dᵉ, MaterialState(state.ϵᵖ, σᵗ, state.k)\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Return new state\n        Δϵᵖ = 3/2 * μ / σₑ * s # plastic strain\n        ϵᵖ = state.ϵᵖ + Δϵᵖ    # plastic strain\n        k = state.k + μ        # hardening variable\n        return σ, D, MaterialState(ϵᵖ, σ, k)\n    end\nend","category":"page"},{"location":"examples/plasticity/#FE-problem","page":"von Mises plasticity","title":"FE-problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"What follows are methods for assembling and and solving the FE-problem.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_values(interpolation)\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for u)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    return cellvalues_u, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Add-degrees-of-freedom","page":"von Mises plasticity","title":"Add degrees of freedom","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_dofhandler(grid, interpolation)\n    dh = DofHandler(grid)\n    dim = 3\n    push!(dh, :u, dim, interpolation) # add a displacement field with 3 components\n    close!(dh)\n    return dh\nend","category":"page"},{"location":"examples/plasticity/#Boundary-conditions","page":"von Mises plasticity","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function create_bc(dh, grid)\n    dbcs = ConstraintHandler(dh)\n    # Clamped on the left side\n    dofs = [1, 2, 3]\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], dofs)\n    add!(dbcs, dbc)\n    close!(dbcs)\n    return dbcs\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Assembling-of-element-contributions","page":"von Mises plasticity","title":"Assembling of element contributions","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Residual vector r\nTangent stiffness K","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function doassemble(cellvalues::CellVectorValues{dim},\n                    facevalues::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, material::J2Plasticity, u, states, states_old, t) where {dim}\n    r = zeros(ndofs(dh))\n    assembler = start_assemble(K, r)\n    nu = getnbasefunctions(cellvalues)\n    re = zeros(nu)     # element residual vector\n    ke = zeros(nu, nu) # element tangent matrix\n\n    for (i, cell) in enumerate(CellIterator(dh))\n        fill!(ke, 0)\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        ue = u[eldofs]\n        state = @view states[:, i]\n        state_old = @view states_old[:, i]\n        assemble_cell!(ke, re, cell, cellvalues, facevalues, grid, material,\n                       ue, state, state_old, t)\n        assemble!(assembler, eldofs, re, ke)\n    end\n    return K, r\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Compute element contribution to the residual and the tangent.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"note: Note\nDue to symmetry, we only compute the lower half of the tangent and then symmetrize it.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function assemble_cell!(Ke, re, cell, cellvalues, facevalues, grid, material,\n                        ue, state, state_old, t)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    reinit!(cellvalues, cell)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state_old[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i # loop only over lower half\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\n\n    # Add traction as a negative contribution to the element residual `re`:\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n            reinit!(facevalues, cell, face)\n            for q_point in 1:getnquadpoints(facevalues)\n                dΓ = getdetJdV(facevalues, q_point)\n                for i in 1:n_basefuncs\n                    δu = shape_value(facevalues, q_point, i)\n                    re[i] -= (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Helper function to symmetrize the material tangent","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Define a function which solves the FE-problem.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"function solve()\n    # Define material parameters\n    E = 200.0e9 # [Pa]\n    H = E/20   # [Pa]\n    ν = 0.3     # [-]\n    σ₀ = 200e6  # [Pa]\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0 # beam length [m]\n    w = 1.0  # beam width [m]\n    h = 1.0  # beam height[m]\n    n_timesteps = 10\n    u_max = zeros(n_timesteps)\n    traction_magnitude = 1.e7 * range(0.5, 1.0, length=n_timesteps)\n\n    # Create geometry, dofs and boundary conditions\n    n = 2\n    nels = (10n, n, 2n) # number of elements in each spatial direction\n    P1 = Vec((0.0, 0.0, 0.0))  # start point for geometry\n    P2 = Vec((L, w, h))        # end point for geometry\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}() # Linear tet with 3 unknowns/node\n\n    dh = create_dofhandler(grid, interpolation) # JuaFEM helper function\n    dbcs = create_bc(dh, grid) # create Dirichlet boundary-conditions\n\n    cellvalues, facevalues = create_values(interpolation)\n\n    # Pre-allocate solution vectors, etc.\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)  # solution vector\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    # Create material states. One array for each cell, where each element is an array of material-\n    # states - one for each integration point\n    nqp = getnquadpoints(cellvalues)\n    states = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n    states_old = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n    print(\"\\n Starting Netwon iterations:\\n\")\n\n    for timestep in 1:n_timesteps\n        t = timestep # actual time (used for evaluating d-bndc)\n        traction = Vec((0.0, 0.0, traction_magnitude[timestep]))\n        newton_itr = -1\n        print(\"\\n Time step @time = $timestep:\\n\")\n        update!(dbcs, t) # evaluates the D-bndc at time t\n        apply!(u, dbcs)  # set the prescribed values in the solution vector\n\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, states_old, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            print(\"Iteration: $newton_itr \\tresidual: $(@sprintf(\"%.8f\", norm_r))\\n\")\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        # Update the old states with the converged values for next timestep\n        states_old .= states\n\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # ## Postprocessing\n    # Only a vtu-file corrsponding to the last time-step is exported.\n    #\n    # The following is a quick (and dirty) way of extracting average cell data for export.\n    mises_values = zeros(getncells(grid))\n    κ_values = zeros(getncells(grid))\n    for (el, cell_states) in enumerate(eachcol(states))\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n            κ_values[el] += state.k*material.H\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n        κ_values[el] /= length(cell_states)     # average drag stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n        vtk_cell_data(vtkfile, κ_values, \"Drag stress [Pa]\")\n    end\n\n    return u_max, traction_magnitude\nend","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Solve the FE-problem and for each time-step extract maximum displacement and the corresponding traction load. Also compute the limit-traction-load","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"u_max, traction_magnitude = solve();\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Finally we plot the load-displacement curve.","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Plots\nplot(\n    vcat(0.0, u_max),                # add the origin as a point\n    vcat(0.0, traction_magnitude),\n    linewidth=2,\n    title=\"Traction-displacement\",\n    label=nothing,\n    markershape=:auto\n    )\nylabel!(\"Traction [Pa]\")\nxlabel!(\"Maximum deflection [m]\")","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Figure 2. Load-displacement-curve for the beam, showing a clear decrease in stiffness as more material starts to yield.","category":"page"},{"location":"examples/plasticity/#plasticity-raw-code","page":"von Mises plasticity","title":"Raw source","text":"","category":"section"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"Below follows a version of the program without any comments. The file is also available here: plasticity.jl","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra, Printf\n\nstruct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}}\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend;\n\nfunction J2Plasticity(E, ν, σ₀, H)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\n\nstruct MaterialState{T, S <: SecondOrderTensor{3, T}}\n    # Store \"converged\" values\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\nend\n\nfunction MaterialState()\n    return MaterialState(\n                zero(SymmetricTensor{2, 3}),\n                zero(SymmetricTensor{2, 3}),\n                0.0)\nend\n\nfunction vonMises(σ)\n    s = dev(σ)\n    return sqrt(3.0/2.0 * s ⊡ s)\nend;\n\nfunction compute_stress_tangent(ϵ::SymmetricTensor{2, 3}, material::J2Plasticity, state::MaterialState)\n    # unpack some material parameters\n    G = material.G\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ   # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effective trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        return σᵗ, material.Dᵉ, MaterialState(state.ϵᵖ, σᵗ, state.k)\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Return new state\n        Δϵᵖ = 3/2 * μ / σₑ * s # plastic strain\n        ϵᵖ = state.ϵᵖ + Δϵᵖ    # plastic strain\n        k = state.k + μ        # hardening variable\n        return σ, D, MaterialState(ϵᵖ, σ, k)\n    end\nend\n\nfunction create_values(interpolation)\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for u)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    return cellvalues_u, facevalues_u\nend;\n\nfunction create_dofhandler(grid, interpolation)\n    dh = DofHandler(grid)\n    dim = 3\n    push!(dh, :u, dim, interpolation) # add a displacement field with 3 components\n    close!(dh)\n    return dh\nend\n\nfunction create_bc(dh, grid)\n    dbcs = ConstraintHandler(dh)\n    # Clamped on the left side\n    dofs = [1, 2, 3]\n    dbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], dofs)\n    add!(dbcs, dbc)\n    close!(dbcs)\n    return dbcs\nend;\n\nfunction doassemble(cellvalues::CellVectorValues{dim},\n                    facevalues::FaceVectorValues{dim}, K::SparseMatrixCSC, grid::Grid,\n                    dh::DofHandler, material::J2Plasticity, u, states, states_old, t) where {dim}\n    r = zeros(ndofs(dh))\n    assembler = start_assemble(K, r)\n    nu = getnbasefunctions(cellvalues)\n    re = zeros(nu)     # element residual vector\n    ke = zeros(nu, nu) # element tangent matrix\n\n    for (i, cell) in enumerate(CellIterator(dh))\n        fill!(ke, 0)\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        ue = u[eldofs]\n        state = @view states[:, i]\n        state_old = @view states_old[:, i]\n        assemble_cell!(ke, re, cell, cellvalues, facevalues, grid, material,\n                       ue, state, state_old, t)\n        assemble!(assembler, eldofs, re, ke)\n    end\n    return K, r\nend\n\nfunction assemble_cell!(Ke, re, cell, cellvalues, facevalues, grid, material,\n                        ue, state, state_old, t)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    reinit!(cellvalues, cell)\n\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state_old[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i # loop only over lower half\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\n\n    # Add traction as a negative contribution to the element residual `re`:\n    for face in 1:nfaces(cell)\n        if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n            reinit!(facevalues, cell, face)\n            for q_point in 1:getnquadpoints(facevalues)\n                dΓ = getdetJdV(facevalues, q_point)\n                for i in 1:n_basefuncs\n                    δu = shape_value(facevalues, q_point, i)\n                    re[i] -= (δu ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nfunction solve()\n    # Define material parameters\n    E = 200.0e9 # [Pa]\n    H = E/20   # [Pa]\n    ν = 0.3     # [-]\n    σ₀ = 200e6  # [Pa]\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0 # beam length [m]\n    w = 1.0  # beam width [m]\n    h = 1.0  # beam height[m]\n    n_timesteps = 10\n    u_max = zeros(n_timesteps)\n    traction_magnitude = 1.e7 * range(0.5, 1.0, length=n_timesteps)\n\n    # Create geometry, dofs and boundary conditions\n    n = 2\n    nels = (10n, n, 2n) # number of elements in each spatial direction\n    P1 = Vec((0.0, 0.0, 0.0))  # start point for geometry\n    P2 = Vec((L, w, h))        # end point for geometry\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}() # Linear tet with 3 unknowns/node\n\n    dh = create_dofhandler(grid, interpolation) # JuaFEM helper function\n    dbcs = create_bc(dh, grid) # create Dirichlet boundary-conditions\n\n    cellvalues, facevalues = create_values(interpolation)\n\n    # Pre-allocate solution vectors, etc.\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)  # solution vector\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    # Create material states. One array for each cell, where each element is an array of material-\n    # states - one for each integration point\n    nqp = getnquadpoints(cellvalues)\n    states = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n    states_old = [MaterialState() for _ in 1:nqp, _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n    print(\"\\n Starting Netwon iterations:\\n\")\n\n    for timestep in 1:n_timesteps\n        t = timestep # actual time (used for evaluating d-bndc)\n        traction = Vec((0.0, 0.0, traction_magnitude[timestep]))\n        newton_itr = -1\n        print(\"\\n Time step @time = $timestep:\\n\")\n        update!(dbcs, t) # evaluates the D-bndc at time t\n        apply!(u, dbcs)  # set the prescribed values in the solution vector\n\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, states_old, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            print(\"Iteration: $newton_itr \\tresidual: $(@sprintf(\"%.8f\", norm_r))\\n\")\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        # Update the old states with the converged values for next timestep\n        states_old .= states\n\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # ## Postprocessing\n    # Only a vtu-file corrsponding to the last time-step is exported.\n    #\n    # The following is a quick (and dirty) way of extracting average cell data for export.\n    mises_values = zeros(getncells(grid))\n    κ_values = zeros(getncells(grid))\n    for (el, cell_states) in enumerate(eachcol(states))\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n            κ_values[el] += state.k*material.H\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n        κ_values[el] /= length(cell_states)     # average drag stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n        vtk_cell_data(vtkfile, κ_values, \"Drag stress [Pa]\")\n    end\n\n    return u_max, traction_magnitude\nend\n\nu_max, traction_magnitude = solve();\n\nusing Plots\nplot(\n    vcat(0.0, u_max),                # add the origin as a point\n    vcat(0.0, traction_magnitude),\n    linewidth=2,\n    title=\"Traction-displacement\",\n    label=nothing,\n    markershape=:auto\n    )\nylabel!(\"Traction [Pa]\")\nxlabel!(\"Maximum deflection [m]\")\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"von Mises plasticity","title":"von Mises plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/helmholtz.jl\"","category":"page"},{"location":"examples/helmholtz/#Helmholtz-equation","page":"Helmholtz equation","title":"Helmholtz equation","text":"","category":"section"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"In this example, we want to solve a (variant of) of the Helmholtz equation. The example is inspired by an dealii step_7 on the standard square.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":" - Delta u + u = f","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"With boundary conditions given by","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"u = g_1 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"and","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"n cdot nabla u = g_2 quad x in Gamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"Here Γ₁ is the union of the top and the right boundary of the square, while Γ₂ is the union of the bottom and the left boundary.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"(Image: )","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"We will use the following weak formulation:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int nabla δu cdot nabla u dOmega\n+ int δu cdot u dOmega\n- int δu cdot f dOmega\n+ int δu cdot (n cdot nabla u - g_2) dGamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"where δu is a suitable test function that satisfies:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"δu = 0 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"and u is a suitable function that satisfies:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"u = g_1 quad x in Gamma_1","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"The example highlights the following interesting features:","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"There are two kinds of boundary conditions, \"Dirichlet\" and \"Von Neumann\"\nThe example contains boundary integrals\nThe Dirichlet condition is imposed strongly and the Von Neumann condition is imposed weakly.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"using Ferrite\nusing Tensors\nusing SparseArrays\nusing LinearAlgebra\n\nconst ∇ = Tensors.gradient\nconst Δ = Tensors.hessian;\n\ngrid = generate_grid(Quadrilateral, (150, 150))\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\nqr_face = QuadratureRule{dim-1, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nfacevalues = FaceScalarValues(qr_face, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"We will set things up, so that a known analytic solution is approximately reproduced. This is a good testing strategy for PDE codes and known as the method of manufactured solutions.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"function u_ana(x::Vec{2, T}) where {T}\n    xs = (Vec{2}((-0.5,  0.5)),\n          Vec{2}((-0.5, -0.5)),\n          Vec{2}(( 0.5,  -0.5)))\n    σ = 1/8\n    s = zero(eltype(x))\n    for i in 1:3\n        s += exp(- norm(x - xs[i])^2 / σ^2)\n    end\n    return max(1e-15 * one(T), s) # Denormals, be gone\nend;\n\ndbcs = ConstraintHandler(dh)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"The (strong) Dirichlet boundary condition can be handled automatically by the Ferrite library.","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"dbc = Dirichlet(:u, union(getfaceset(grid, \"top\"), getfaceset(grid, \"right\")), (x,t) -> u_ana(x))\nadd!(dbcs, dbc)\nclose!(dbcs)\nupdate!(dbcs, 0.0)\n\nK = create_sparsity_pattern(dh);\n\nfunction doassemble(cellvalues::CellScalarValues{dim}, facevalues::FaceScalarValues{dim},\n                         K::SparseMatrixCSC, dh::DofHandler) where {dim}\n    b = 1.0\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    global_dofs = zeros(Int, ndofs_per_cell(dh))\n\n    fe = zeros(n_basefuncs) # Local force vector\n    Ke = zeros(n_basefuncs, n_basefuncs) # Local stiffness mastrix\n\n    @inbounds for (cellcount, cell) in enumerate(CellIterator(dh))\n        fill!(Ke, 0)\n        fill!(fe, 0)\n        coords = getcoordinates(cell)\n\n        reinit!(cellvalues, cell)","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"First we derive the non boundary part of the variation problem from the destined solution u_ana","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int nabla δu cdot nabla u dOmega\n+ int δu cdot u dOmega\n- int δu cdot f dOmega","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n            coords_qp = spatial_coordinate(cellvalues, q_point, coords)\n            f_true = -LinearAlgebra.tr(hessian(u_ana, coords_qp)) + u_ana(coords_qp)\n            for i in 1:n_basefuncs\n                δu = shape_value(cellvalues, q_point, i)\n                ∇δu = shape_gradient(cellvalues, q_point, i)\n                fe[i] += (δu * f_true) * dΩ\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇δu ⋅ ∇u + δu * u) * dΩ\n                end\n            end\n        end","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"Now we manually add the von Neumann boundary terms","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"int δu cdot (n cdot nabla u - g_2) dGamma_2","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"        for face in 1:nfaces(cell)\n            if onboundary(cell, face) &&\n                   ((cellcount, face) ∈ getfaceset(grid, \"left\") ||\n                    (cellcount, face) ∈ getfaceset(grid, \"bottom\"))\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    coords_qp = spatial_coordinate(facevalues, q_point, coords)\n                    n = getnormal(facevalues, q_point)\n                    g = gradient(u_ana, coords_qp) ⋅ n\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:n_basefuncs\n                        δu = shape_value(facevalues, q_point, i)\n                        fe[i] += -(δu * g) * dΓ\n                        for j in 1:n_basefuncs\n                            ∇u = shape_gradient(cellvalues, q_point, j)\n                            Ke[i, j] += (δu * ∇u ⋅ n) * dΓ\n                        end\n                    end\n                end\n            end\n        end\n\n        celldofs!(global_dofs, cell)\n        assemble!(assembler, global_dofs, fe, Ke)\n    end\n    return K, f\nend;\n\nK, f = doassemble(cellvalues, facevalues, K, dh);\napply!(K, f, dbcs)\nu = Symmetric(K) \\ f;\n\nvtkfile = vtk_grid(\"helmholtz\", dh)\nvtk_point_data(vtkfile, dh, u)\nvtk_save(vtkfile)\nprintln(\"Helmholtz successful\")","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"","category":"page"},{"location":"examples/helmholtz/","page":"Helmholtz equation","title":"Helmholtz equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"In Ferrite a Grid is a collection of Nodes and Cells and is parameterized in its physical dimensionality and cell type. Nodes are points in the physical space and can be initialized by a N-Tuple, where N corresponds to the dimensions.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"n1 = Node((0.0, 0.0))","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Cells are defined based on the Node IDs. Hence, they collect IDs in a N-Tuple. Consider the following 2D mesh:","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"(Image: global mesh)","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The cells of the grid can be described in the following way","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> elements = [\n              (1,2,5,4),\n              (2,3,6,5),\n              (4,5,8,7),\n              (5,6,9,8)\n       ]","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Additionally, the data structure Grid can hold node-, face- and cellsets.  All of these three sets are defined by a dictionary that maps a string key to a Set.  For the special case of node- and cellsets the dictionary's value is of type Set{Int}, i.e. a keyword is mapped to a node or cell ID, respectively. ","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Facesets are a more elaborate construction. They map a String key to a Set{Int, Int} consisting of (global_cell_id, local_face_id). In order to understand the local_face_id properly, one has to consider the reference space of the element, which typically is spanned by a product of the interval -1 1 and in this particular example -1 1 times -1 1.  In this space a local numbering of nodes and faces exists, i.e.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"(Image: local element)","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The example shows a local face ID ordering, defined as:","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"faces(::Lagrange{2,RefCube,1}) = ((1,2), (2,3), (3,4), (4,1))","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"Other face ID definitions can be found in the src files in the corresponding faces dispatch.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The highlighted face, i.e. the two lines from node ID 3 to 6 and from 6 to 9, on the right hand side of our test mesh can now be described as","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> edges = [\n           (3,6),\n           (6,9)\n       ]","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"The local ID can be constructed based on elements, corresponding edges and chosen interpolation, since the face ordering is interpolation dependent.","category":"page"},{"location":"manual/grid/","page":"Grid","title":"Grid","text":"julia> function compute_faceset(elements, edges, ip::Interpolation{dim}) where {dim}\n           local_faces = Ferrite.faces(ip)\n           nodes_per_face = length(local_faces[1])\n           d = Dict{NTuple{nodes_per_face, Int}, Tuple{Int, Int}}()\n           for (e, element) in enumerate(elements) # e is global element number\n               for (f, face) in enumerate(local_faces) # f is local face number\n                   # store the global nodes for the particular element, local face combination\n                   d[ntuple(i-> element[face[i]], nodes_per_face)] = (e, f)\n               end\n           end\n       \n           faces = Set{Tuple{Int, Int}}()\n           for edge in edges\n               # lookup the element, local face combination for this edge\n               push!(faces, d[edge])\n           end\n       \n           return faces\n       end\n\njulia> interpolation = Lagrange{2, RefTetrahedron, 1}()\n\njulia> compute_faceset(elements, edges, interpolation)\nSet{Tuple{Int64,Int64}} with 2 elements:\n  (2, 2)\n  (4, 2)","category":"page"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"CurrentModule = Ferrite\nDocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"reference/quadrature/","page":"Quadrature","title":"Quadrature","text":"QuadratureRule\nAbstractRefShape\ngetpoints\ngetweights","category":"page"},{"location":"reference/quadrature/#Ferrite.QuadratureRule","page":"Quadrature","title":"Ferrite.QuadratureRule","text":"QuadratureRule{dim,shape}([quad_rule_type::Symbol], order::Int)\n\nCreate a QuadratureRule used for integration. dim is the space dimension, shape an AbstractRefShape and order the order of the quadrature rule. quad_rule_type is an optional argument determining the type of quadrature rule, currently the :legendre and :lobatto rules are implemented.\n\nA QuadratureRule is used to approximate an integral on a domain by a weighted sum of function values at specific points:\n\nintlimits_Omega f(mathbfx) textd Omega approx sumlimits_q = 1^n_q f(mathbfx_q) w_q\n\nThe quadrature rule consists of n_q points in space mathbfx_q with corresponding weights w_q.\n\nIn Ferrite, the QuadratureRule type is mostly used as one of the components to create a CellValues or FaceValues object.\n\nCommon methods:\n\ngetpoints : the points of the quadrature rule\ngetweights : the weights of the quadrature rule\n\nExample:\n\njulia> QuadratureRule{2, RefTetrahedron}(1)\nFerrite.QuadratureRule{2,Ferrite.RefTetrahedron,Float64}([0.5], Tensors.Tensor{1,2,Float64,2}[[0.333333, 0.333333]])\n\njulia> QuadratureRule{1, RefCube}(:lobatto, 2)\nFerrite.QuadratureRule{1,Ferrite.RefCube,Float64}([1.0, 1.0], Tensors.Tensor{1,1,Float64,1}[[-1.0], [1.0]])\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.AbstractRefShape","page":"Quadrature","title":"Ferrite.AbstractRefShape","text":"Represents a reference shape which quadrature rules and interpolations are defined on. Currently, the only concrete types that subtype this type are RefCube in 1, 2 and 3 dimensions, and RefTetrahedron in 2 and 3 dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference/quadrature/#Ferrite.getpoints","page":"Quadrature","title":"Ferrite.getpoints","text":"getpoints(qr::QuadratureRule)\n\nReturn the points of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{2, RefTetrahedron}(:legendre, 2);\n\njulia> getpoints(qr)\n3-element Array{Tensors.Tensor{1,2,Float64,2},1}:\n [0.166667, 0.166667]\n [0.166667, 0.666667]\n [0.666667, 0.166667]\n\n\n\n\n\n","category":"function"},{"location":"reference/quadrature/#Ferrite.getweights","page":"Quadrature","title":"Ferrite.getweights","text":"getweights(qr::QuadratureRule)\n\nReturn the weights of the quadrature rule.\n\nExamples\n\njulia> qr = QuadratureRule{2, RefTetrahedron}(:legendre, 2);\n\njulia> getweights(qr)\n3-element Array{Float64,1}:\n 0.166667\n 0.166667\n 0.166667\n\n\n\n\n\n","category":"function"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/transient_heat_equation.jl\"","category":"page"},{"location":"examples/transient_heat_equation/#Time-Dependent-Problems","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"(Image: )","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"tip: Tip\nThis example is also available as a Jupyter notebook: transient_heat_equation.ipynb","category":"page"},{"location":"examples/transient_heat_equation/#Introduction","page":"Time Dependent Problems","title":"Introduction","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In this example we extend the heat equation by a time dependent term, i.e.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":" fracpartial upartial t-nabla cdot (k nabla u) = f  quad x in Omega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set f = 1 and k = 1. We define homogeneous Dirichlet boundary conditions along the left and right edge of the domain.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"u(xt) = 0 quad x in partial Omega_1","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where partial Omega_1 denotes the left and right boundary of Omega.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Further, we define heterogeneous Dirichlet boundary conditions at the top and bottom edge partial Omega_2. We choose a linearly increasing function a(t) that describes the temperature at this boundary","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"u(xt) = a(t) quad x in partial Omega_2","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"The semidiscrete weak form is given by","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"int_Omegafracpartial upartial tcdot v  dOmega + int_Omega nabla v cdot nabla u  dOmega = int_Omega v  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where v is a suitable test function. Now, we still need to discretize the time derivative. An implicit Euler scheme is applied, which yields:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"int_Omegau_n+1cdot v  dOmega + Delta tint_Omega nabla v cdot nabla u_n+1  dOmega = Delta tint_Omega v  dOmega + int_Omega u_ncdot v  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"If we assemble the discrete operators, we get the following algebraic system:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"mathbfM mathbfu_n+1 + Δt mathbfK mathbfu_n+1 = Δt mathbff + mathbfM mathbfu_n","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In this example we apply the boundary conditions to the assembled discrete operators (mass matrix mathbfM and stiffnes matrix mathbfK) only once. We utilize the fact that in finite element computations Dirichlet conditions can be applied by zero out rows and columns that correspond to a prescribed dof in the system matrix (mathbfA = Δt mathbfK + mathbfM) and setting the value of the right-hand side vector to the value of the Dirichlet condition. Thus, we only need to apply in every time step the Dirichlet condition to the right-hand side of the problem.","category":"page"},{"location":"examples/transient_heat_equation/#Commented-Program","page":"Time Dependent Problems","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"First we load Ferrite, and some other packages we need.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"using Ferrite, SparseArrays","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We create the same grid as in the heat equation example.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"grid = generate_grid(Quadrilateral, (100, 100));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Trial-and-test-functions","page":"Time Dependent Problems","title":"Trial and test functions","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Again, we define the structs that are responsible for the shape_value and shape_gradient evaluation.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"dim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Degrees-of-freedom","page":"Time Dependent Problems","title":"Degrees of freedom","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"After this, we can define the DofHandler and distribute the DOFs of the problem.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"dh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"By means of the DofHandler we can allocate the needed SparseMatrixCSC. M refers here to the so called mass matrix, which always occurs in time related terms, i.e.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"M_ij = int_Omega u_i cdot v_j  dOmega","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"where u_i and v_j are trial and test functions, respectively.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"K = create_sparsity_pattern(dh);\nM = create_sparsity_pattern(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We also preallocate the right hand side","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"f = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Boundary-conditions","page":"Time Dependent Problems","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In order to define the time dependent problem, we need some end time T and something that describes the linearly increasing Dirichlet boundary condition on partial Omega_2.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"max_temp = 100\nΔt = 1\nT = 200\nch = ConstraintHandler(dh);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here, we define the boundary condition related to partial Omega_1.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"∂Ω₁ = union(getfaceset.((grid, ), [\"left\", \"right\"])...)\ndbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\nadd!(ch, dbc);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"While the next code block corresponds to the linearly increasing temperature description on partial Omega_2.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"∂Ω₂ = union(getfaceset.((grid, ), [\"top\", \"bottom\"])...)\ndbc = Dirichlet(:u, ∂Ω₂, (x, t) -> t*(max_temp/T))\nadd!(ch, dbc)\nclose!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#Assembling-the-linear-system","page":"Time Dependent Problems","title":"Assembling the linear system","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"As in the heat equation example we define a doassemble! function that assembles the diffusion parts of the equation:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"function doassemble_K!(K::SparseMatrixCSC, f::Vector, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\nnothing # hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In addition to the diffusive part, we also need a function that assembles the mass matrix M.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"function doassemble_M!(M::SparseMatrixCSC, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Me = zeros(n_basefuncs, n_basefuncs)\n\n    assembler = start_assemble(M)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Me, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    Me[i, j] += (v ⋅ u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), Me)\n    end\n    return M\nend\nnothing # hide","category":"page"},{"location":"examples/transient_heat_equation/#Solution-of-the-system","page":"Time Dependent Problems","title":"Solution of the system","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We first assemble all parts in the prior allocated SparseMatrixCSC.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"K, f = doassemble_K!(K, f, cellvalues, dh)\nM = doassemble_M!(M, cellvalues, dh)\nA = (Δt .* K) + M;\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Now, we need to save all boundary condition related values of the unaltered system matrix A, which is done by get_rhs_data. The function returns a RHSData struct, which contains all needed informations to apply the boundary conditions solely on the right-hand-side vector of the problem.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"rhsdata = get_rhs_data(ch, A);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"We set the initial time step, denoted by uₙ,  to mathbf0.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"uₙ = zeros(length(f));\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Here, we apply once the boundary conditions to the system matrix A.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"apply!(A, ch);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"To store the solution, we initialize a paraview_collection (.pvd) file.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"pvd = paraview_collection(\"transient-heat.pvd\");\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"At this point everything is set up and we can finally approach the time loop.","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"for t in 0:Δt:T\n    #First of all, we need to update the Dirichlet boundary condition values.\n    update!(ch, t)\n\n    #Secondly, we compute the right-hand-side of the problem.\n    b = Δt .* f .+ M * uₙ\n    #Then, we can apply the boundary conditions of the current time step.\n    apply_rhs!(rhsdata, b, ch)\n\n    #Finally, we can solve the time step and save the solution afterwards.\n    u = A \\ b;\n\n    vtk_grid(\"transient-heat-$t\", dh) do vtk\n        vtk_point_data(vtk, dh, u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\n   #At the end of the time loop, we set the previous solution to the current one and go to the next time step.\n   uₙ .= u\nend","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"In order to use the .pvd file we need to store it to the disk, which is done by:","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"vtk_save(pvd);\nnothing #hide","category":"page"},{"location":"examples/transient_heat_equation/#transient_heat_equation-plain-program","page":"Time Dependent Problems","title":"Plain Program","text":"","category":"section"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"Below follows a version of the program without any comments. The file is also available here: transientheatequation.jl","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"using Ferrite, SparseArrays\n\ngrid = generate_grid(Quadrilateral, (100, 100));\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\n\nK = create_sparsity_pattern(dh);\nM = create_sparsity_pattern(dh);\n\nf = zeros(ndofs(dh));\n\nmax_temp = 100\nΔt = 1\nT = 200\nch = ConstraintHandler(dh);\n\n∂Ω₁ = union(getfaceset.((grid, ), [\"left\", \"right\"])...)\ndbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\nadd!(ch, dbc);\n\n∂Ω₂ = union(getfaceset.((grid, ), [\"top\", \"bottom\"])...)\ndbc = Dirichlet(:u, ∂Ω₂, (x, t) -> t*(max_temp/T))\nadd!(ch, dbc)\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction doassemble_K!(K::SparseMatrixCSC, f::Vector, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\n\nfunction doassemble_M!(M::SparseMatrixCSC, cellvalues::CellScalarValues{dim}, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Me = zeros(n_basefuncs, n_basefuncs)\n\n    assembler = start_assemble(M)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Me, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                for j in 1:n_basefuncs\n                    u = shape_value(cellvalues, q_point, j)\n                    Me[i, j] += (v ⋅ u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), Me)\n    end\n    return M\nend\n\nK, f = doassemble_K!(K, f, cellvalues, dh)\nM = doassemble_M!(M, cellvalues, dh)\nA = (Δt .* K) + M;\n\nrhsdata = get_rhs_data(ch, A);\n\nuₙ = zeros(length(f));\n\napply!(A, ch);\n\npvd = paraview_collection(\"transient-heat.pvd\");\n\nfor t in 0:Δt:T\n    #First of all, we need to update the Dirichlet boundary condition values.\n    update!(ch, t)\n\n    #Secondly, we compute the right-hand-side of the problem.\n    b = Δt .* f .+ M * uₙ\n    #Then, we can apply the boundary conditions of the current time step.\n    apply_rhs!(rhsdata, b, ch)\n\n    #Finally, we can solve the time step and save the solution afterwards.\n    u = A \\ b;\n\n    vtk_grid(\"transient-heat-$t\", dh) do vtk\n        vtk_point_data(vtk, dh, u)\n        vtk_save(vtk)\n        pvd[t] = vtk\n    end\n   #At the end of the time loop, we set the previous solution to the current one and go to the next time step.\n   uₙ .= u\nend\n\nvtk_save(pvd);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"","category":"page"},{"location":"examples/transient_heat_equation/","page":"Time Dependent Problems","title":"Time Dependent Problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/landau.jl\"","category":"page"},{"location":"examples/landau/#Ginzburg-Landau-model-energy-minimization","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"(Image: landau_orig.png)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Original","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"(Image: landau_opt.png)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Optimized","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"In this example a basic Ginzburg-Landau model is solved. This example gives an idea of how the API together with ForwardDiff can be leveraged to performantly solve non standard problems on a FEM grid. A large portion of the code is there only for performance reasons, but since this usually really matters and is what takes the most time to optimize, it is included.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The key to using a method like this for minimizing a free energy function directly, rather than the weak form, as is usually done with FEM, is to split up the gradient and Hessian calculations. This means that they are performed for each cell seperately instead of for the grid as a whole.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"using ForwardDiff\nimport ForwardDiff: GradientConfig, HessianConfig, Chunk\nusing Ferrite\nusing Optim, LineSearches\nusing SparseArrays\nusing Tensors\nusing Base.Threads","category":"page"},{"location":"examples/landau/#Energy-terms","page":"Ginzburg-Landau model energy minimization","title":"Energy terms","text":"","category":"section"},{"location":"examples/landau/#th-order-Landau-free-energy","page":"Ginzburg-Landau model energy minimization","title":"4th order Landau free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function Fl(P::Vec{3, T}, α::Vec{3}) where T\n    P2 = Vec{3, T}((P[1]^2, P[2]^2, P[3]^2))\n    return (α[1] * sum(P2) +\n           α[2] * (P[1]^4 + P[2]^4 + P[3]^4)) +\n           α[3] * ((P2[1] * P2[2]  + P2[2]*P2[3]) + P2[1]*P2[3])\nend","category":"page"},{"location":"examples/landau/#Ginzburg-free-energy","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"@inline Fg(∇P, G) = 0.5(∇P ⊡ G) ⊡ ∇P","category":"page"},{"location":"examples/landau/#GL-free-energy","page":"Ginzburg-Landau model energy minimization","title":"GL free energy","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"F(P, ∇P, params)  = Fl(P, params.α) + Fg(∇P, params.G)","category":"page"},{"location":"examples/landau/#Parameters-that-characterize-the-model","page":"Ginzburg-Landau model energy minimization","title":"Parameters that characterize the model","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"struct ModelParams{V, T}\n    α::V\n    G::T\nend","category":"page"},{"location":"examples/landau/#ThreadCache","page":"Ginzburg-Landau model energy minimization","title":"ThreadCache","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This holds the values that each thread will use during the assembly.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"struct ThreadCache{CV, T, DIM, F <: Function, GC <: GradientConfig, HC <: HessianConfig}\n    cvP              ::CV\n    element_indices  ::Vector{Int}\n    element_dofs     ::Vector{T}\n    element_gradient ::Vector{T}\n    element_hessian  ::Matrix{T}\n    element_coords   ::Vector{Vec{DIM, T}}\n    element_potential::F\n    gradconf         ::GC\n    hessconf         ::HC\nend\nfunction ThreadCache(dpc::Int, nodespercell, cvP::CellValues{DIM, T}, modelparams, elpotential) where {DIM, T}\n    element_indices  = zeros(Int, dpc)\n    element_dofs     = zeros(dpc)\n    element_gradient = zeros(dpc)\n    element_hessian  = zeros(dpc, dpc)\n    element_coords   = zeros(Vec{DIM, T}, nodespercell)\n    potfunc          = x -> elpotential(x, cvP, modelparams)\n    gradconf         = GradientConfig(potfunc, zeros(dpc), Chunk{12}())\n    hessconf         = HessianConfig(potfunc, zeros(dpc), Chunk{12}())\n    return ThreadCache(cvP, element_indices, element_dofs, element_gradient, element_hessian, element_coords, potfunc, gradconf, hessconf)\nend","category":"page"},{"location":"examples/landau/#The-Model","page":"Ginzburg-Landau model energy minimization","title":"The Model","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"everything is combined into a model.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"mutable struct LandauModel{T, DH <: DofHandler, CH <: ConstraintHandler, TC <: ThreadCache}\n    dofs          ::Vector{T}\n    dofhandler    ::DH\n    boundaryconds ::CH\n    threadindices ::Vector{Vector{Int}}\n    threadcaches  ::Vector{TC}\nend\n\nfunction LandauModel(α, G, gridsize, left::Vec{DIM, T}, right::Vec{DIM, T}, elpotential) where {DIM, T}\n    grid = generate_grid(Tetrahedron, gridsize, left, right)\n    questionmark, threadindices = Ferrite.create_coloring(grid)\n\n    qr  = QuadratureRule{DIM, RefTetrahedron}(2)\n    cvP = CellVectorValues(qr, Lagrange{DIM, RefTetrahedron, 1}())\n\n    dofhandler = DofHandler(grid)\n    push!(dofhandler, :P, 3)\n    close!(dofhandler)\n\n    dofvector = zeros(ndofs(dofhandler))\n    startingconditions!(dofvector, dofhandler)\n    boundaryconds = ConstraintHandler(dofhandler)\n    #boundary conditions can be added but aren't necessary for optimization\n    #add!(boundaryconds, Dirichlet(:P, getfaceset(grid, \"left\"), (x, t) -> [0.0,0.0,0.53], [1,2,3]))\n    #add!(boundaryconds, Dirichlet(:P, getfaceset(grid, \"right\"), (x, t) -> [0.0,0.0,-0.53], [1,2,3]))\n    close!(boundaryconds)\n    update!(boundaryconds, 0.0)\n\n    apply!(dofvector, boundaryconds)\n\n    hessian = create_sparsity_pattern(dofhandler)\n    dpc = ndofs_per_cell(dofhandler)\n    cpc = length(grid.cells[1].nodes)\n    caches = [ThreadCache(dpc, cpc, copy(cvP), ModelParams(α, G), elpotential) for t=1:nthreads()]\n    return LandauModel(dofvector, dofhandler, boundaryconds, threadindices, caches)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"utility to quickly save a model","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function Ferrite.vtk_save(path, model, dofs=model.dofs)\n    vtkfile = vtk_grid(path, model.dofhandler)\n    vtk_point_data(vtkfile, model.dofhandler, dofs)\n    vtk_save(vtkfile)\nend","category":"page"},{"location":"examples/landau/#Assembly","page":"Ginzburg-Landau model energy minimization","title":"Assembly","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This macro defines most of the assembly step, since the structure is the same for the energy, gradient and Hessian calculations.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"macro assemble!(innerbody)\n    esc(quote\n        dofhandler = model.dofhandler\n        for indices in model.threadindices\n            @threads for i in indices\n                cache     = model.threadcaches[threadid()]\n                eldofs    = cache.element_dofs\n                nodeids   = dofhandler.grid.cells[i].nodes\n                for j=1:length(cache.element_coords)\n                    cache.element_coords[j] = dofhandler.grid.nodes[nodeids[j]].x\n                end\n                reinit!(cache.cvP, cache.element_coords)\n\n                celldofs!(cache.element_indices, dofhandler, i)\n                for j=1:length(cache.element_dofs)\n                    eldofs[j] = dofvector[cache.element_indices[j]]\n                end\n                $innerbody\n            end\n        end\n    end)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This calculates the total energy calculation of the grid","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function F(dofvector::Vector{T}, model) where T\n    outs = fill(zero(T), nthreads())\n    @assemble! begin\n        outs[threadid()] += cache.element_potential(eldofs)\n    end\n    return sum(outs)\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The gradient calculation for each dof","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function ∇F!(∇f::Vector{T}, dofvector::Vector{T}, model::LandauModel{T}) where T\n    fill!(∇f, zero(T))\n    @assemble! begin\n        ForwardDiff.gradient!(cache.element_gradient, cache.element_potential, eldofs, cache.gradconf)\n        @inbounds assemble!(∇f, cache.element_indices, cache.element_gradient)\n    end\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"The Hessian calculation for the whole grid","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function ∇²F!(∇²f::SparseMatrixCSC, dofvector::Vector{T}, model::LandauModel{T}) where T\n    assemblers = [start_assemble(∇²f) for t=1:nthreads()]\n    @assemble! begin\n        ForwardDiff.hessian!(cache.element_hessian, cache.element_potential, eldofs, cache.hessconf)\n        @inbounds assemble!(assemblers[threadid()], cache.element_indices, cache.element_hessian)\n    end\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"We can also calculate all things in one go!","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function calcall(∇²f::SparseMatrixCSC, ∇f::Vector{T}, dofvector::Vector{T}, model::LandauModel{T}) where T\n    outs = fill(zero(T), nthreads())\n    fill!(∇f, zero(T))\n    assemblers = [start_assemble(∇²f, ∇f) for t=1:nthreads()]\n    @assemble! begin\n        outs[threadid()] += cache.element_potential(eldofs)\n        ForwardDiff.hessian!(cache.element_hessian, cache.element_potential, eldofs, cache.hessconf)\n        ForwardDiff.gradient!(cache.element_gradient, cache.element_potential, eldofs, cache.gradconf)\n        @inbounds assemble!(assemblers[threadid()], cache.element_indices, cache.element_gradient, cache.element_hessian)\n    end\n    return sum(outs)\nend","category":"page"},{"location":"examples/landau/#Minimization","page":"Ginzburg-Landau model energy minimization","title":"Minimization","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"Now everything can be combined to minimize the energy, and find the equilibrium configuration.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function minimize!(model; kwargs...)\n    dh = model.dofhandler\n    dofs = model.dofs\n    ∇f = fill(0.0, length(dofs))\n    ∇²f = create_sparsity_pattern(dh)\n    function g!(storage, x)\n        ∇F!(storage, x, model)\n        apply_zero!(storage, model.boundaryconds)\n    end\n    function h!(storage, x)\n        ∇²F!(storage, x, model)\n        #apply!(storage, model.boundaryconds)\n    end\n    f(x) = F(x, model)\n\n    od = TwiceDifferentiable(f, g!, h!, model.dofs, 0.0, ∇f, ∇²f)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"this way of minimizing is only beneficial when the initial guess is completely off, then a quick couple of ConjuageGradient steps brings us easily closer to the minimum. res = optimize(od, model.dofs, ConjugateGradient(linesearch=BackTracking()), Optim.Options(showtrace=true, showevery=1, g_tol=1e-20, iterations=10)) model.dofs .= res.minimizer to get the final convergence, Newton's method is more ideal since the energy landscape should be almost parabolic","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"    res = optimize(od, model.dofs, Newton(linesearch=BackTracking()), Optim.Options(show_trace=true, show_every=1, g_tol=1e-20))\n    model.dofs .= res.minimizer\n    return res\nend","category":"page"},{"location":"examples/landau/#Testing-it","page":"Ginzburg-Landau model energy minimization","title":"Testing it","text":"","category":"section"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This calculates the contribution of each element to the total energy, it is also the function that will be put through ForwardDiff for the gradient and Hessian.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function element_potential(eldofs::AbstractVector{T}, cvP, params) where T\n    energy = zero(T)\n    for qp=1:getnquadpoints(cvP)\n        P  = function_value(cvP, qp, eldofs)\n        ∇P = function_gradient(cvP, qp, eldofs)\n        energy += F(P, ∇P, params) * getdetJdV(cvP, qp)\n    end\n    return energy\nend","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"now we define some starting conditions","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"function startingconditions!(dofvector, dofhandler)\n    for cell in CellIterator(dofhandler)\n        globaldofs = celldofs(cell)\n        it = 1\n        for i=1:3:length(globaldofs)\n            dofvector[globaldofs[i]]   = -2.0\n            dofvector[globaldofs[i+1]] = 2.0\n            dofvector[globaldofs[i+2]] = -2.0tanh(cell.coords[it][1]/20)\n            it += 1\n        end\n    end\nend\n\nδ(i, j) = i == j ? one(i) : zero(i)\nV2T(p11, p12, p44) = Tensor{4, 3}((i,j,k,l) -> p11 * δ(i,j)*δ(k,l)*δ(i,k) + p12*δ(i,j)*δ(k,l)*(1 - δ(i,k)) + p44*δ(i,k)*δ(j,l)*(1 - δ(i,j)))\n\nG = V2T(1.0e2, 0.0, 1.0e2)\nα = Vec{3}((-1.0, 1.0, 1.0))\nleft = Vec{3}((-75.,-25.,-2.))\nright = Vec{3}((75.,25.,2.))\nmodel = LandauModel(α, G, (50, 50, 2), left, right, element_potential)\n\nvtk_save(\"landauorig\", model)\n@time minimize!(model)\nvtk_save(\"landaufinal\", model)","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"as we can see this runs very quickly even for relatively large gridsizes. The key to get high performance like this is to minimize the allocations inside the threaded loops, ideally to 0.","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"","category":"page"},{"location":"examples/landau/","page":"Ginzburg-Landau model energy minimization","title":"Ginzburg-Landau model energy minimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/linear_shell.jl\"","category":"page"},{"location":"examples/linear_shell/#Linear-shell","page":"Linear shell","title":"Linear shell","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"(Image: )","category":"page"},{"location":"examples/linear_shell/#Introduction","page":"Linear shell","title":"Introduction","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"In this example we show how shell elements can be analyzed in Ferrite.jl. The shell implemented here comes from the book \"The finite elment method - Linear static and dynamic finite element analysis\" by Hughes (1987), and a brief description of it is given at the end of this tutorial.  The first part of the tutorial explains how to set up the problem.","category":"page"},{"location":"examples/linear_shell/#Setting-up-the-problem","page":"Linear shell","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"using Ferrite\nusing ForwardDiff\n\nfunction main() #wrap everything in a function...","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"First we generate a flat rectangular mesh. There is currently no built-in function for generating shell meshes in Ferrite, so we have to create our own simple mesh generator (see the function generate_shell_grid further down in this file).","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"nels = (10,10)\nsize = (10.0, 10.0)\ngrid = generate_shell_grid(nels, size)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Here we define the bi-linear interpolation used for the geometrical description of the shell. We also create two quadrature rules for the in-plane and out-of-plane directions. Note that we use under integration for the inplane integration, to avoid shear locking.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"ip = Lagrange{2,RefCube,1}()\nqr_inplane = QuadratureRule{2,RefCube}(1)\nqr_ooplane = QuadratureRule{1,RefCube}(2)\ncv = CellScalarValues(qr_inplane, ip)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Next we distribute displacement dofs,:u = (x,y,z) and rotational dofs, :θ = (θ₁,  θ₂).","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"dh = DofHandler(grid)\npush!(dh, :u, 3, ip)\npush!(dh, :θ, 2, ip)\nclose!(dh)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"In order to apply our boundary conditions, we first need to create some edge- and vertex-sets. This is done with addedgeset! and addvertexset! (similar to addfaceset!)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"addedgeset!(grid, \"left\",  (x) -> x[1] ≈ 0.0)\naddedgeset!(grid, \"right\", (x) -> x[1] ≈ size[1])\naddvertexset!(grid, \"corner\", (x) -> x[1] ≈ 0.0 && x[2] ≈ 0.0 && x[3] ≈ 0.0)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Here we define the boundary conditions. On the left edge, we lock the displacements in the x- and z- directions, and all the rotations.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"ch = ConstraintHandler(dh)\nadd!(ch,  Dirichlet(:u, getedgeset(grid, \"left\"), (x, t) -> (0.0, 0.0), [1,3])  )\nadd!(ch,  Dirichlet(:θ, getedgeset(grid, \"left\"), (x, t) -> (0.0, 0.0), [1,2])  )","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"On the right edge, we also lock the displacements in the x- and z- directions, but apply a precribed roation.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"add!(ch,  Dirichlet(:u, getedgeset(grid, \"right\"), (x, t) -> (0.0, 0.0), [1,3])  )\nadd!(ch,  Dirichlet(:θ, getedgeset(grid, \"right\"), (x, t) -> (0.0, pi/10), [1,2])  )","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"In order to not get rigid body motion, we lock the y-displacement in one fo the corners.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"add!(ch,  Dirichlet(:θ, getvertexset(grid, \"corner\"), (x, t) -> (0.0), [2])  )\n\nclose!(ch)\nupdate!(ch, 0.0)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Next we define relevant data for the shell, such as shear correction factor and stiffness matrix for the material. In this linear shell, plane stress is assumed, ie \\\\sigma_{zz} = 0 $. Therefor, the stiffness matrix is 5x5 (opposed to the normal 6x6).","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"κ = 5/6 # Shear correction factor\nE = 210.0\nν = 0.3\na = (1-ν)/2\nC = E/(1-ν^2) * [1 ν 0   0   0;\n                ν 1 0   0   0;\n                0 0 a*κ 0   0;\n                0 0 0   a*κ 0;\n                0 0 0   0   a*κ]\n\n\ndata = (thickness = 1.0, C = C); #Named tuple\nnothing #hide","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"We now assemble the problem in standard finite element fashion","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"nnodes = getnbasefunctions(ip)\nndofs_shell = ndofs_per_cell(dh)\n\nK = create_sparsity_pattern(dh)\nf = zeros(Float64, ndofs(dh))\n\nke = zeros(ndofs_shell, ndofs_shell)\nfe = zeros(ndofs_shell)\n\ncelldofs = zeros(Int, ndofs_shell)\ncellcoords = zeros(Vec{3,Float64}, nnodes)\n\nassembler = start_assemble(K, f)\nfor cellid in 1:getncells(grid)\n    fill!(ke, 0.0)\n\n    celldofs!(celldofs, dh, cellid)\n    getcoordinates!(cellcoords, grid, cellid)\n\n    #Call the element routine\n    integrate_shell!(ke, cv, qr_ooplane, cellcoords, data)\n\n    assemble!(assembler, celldofs, fe, ke)\nend","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Apply BC and solve.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"apply!(K, f, ch)\na = K\\f","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Output results.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"vtk_grid(\"linear_shell\", dh) do vtk\n    vtk_point_data(vtk, dh, a)\nend\n\nend; #end main functions\nnothing #hide","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Below is the function that creates the shell mesh. It simply generates a 2d-quadrature mesh, and appends a third coordinate (z-direction) to the node-positions.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function generate_shell_grid(nels, size)\n    _grid = generate_grid(Quadrilateral, nels, Vec((0.0,0.0)), Vec(size))\n    nodes = [(n.x[1], n.x[2], 0.0) |> Vec{3} |> Node  for n in _grid.nodes]\n    cells = [Quadrilateral3D(cell.nodes) for cell in _grid.cells]\n\n    grid = Grid(cells, nodes)\n\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#The-shell-element","page":"Linear shell","title":"The shell element","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The shell presented here comes from the book \"The finite elment method - Linear static and dynamic finite element analysis\" by Hughes (1987). The shell is a so called degenerate shell element, meaning it is based on a continuum element. A brief describtion of the shell is given here.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"note: Note\nThis element might experience various locking phenomenas, and should only be seen as a proof of concept.","category":"page"},{"location":"examples/linear_shell/#Fiber-coordinate-system","page":"Linear shell","title":"Fiber coordinate system","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The element uses two coordinate systems. The first coordianate system, called the fiber system, is created for each element node, and is used as a reference frame for the rotations. The function below implements an algorthim that return the fiber directions, boldsymbole^f_a1, boldsymbole^f_a2 and boldsymbole^f_a3, at each node a.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function fiber_coordsys(Ps::Vector{Vec{3,Float64}})\n\n    ef1 = Vec{3,Float64}[]\n    ef2 = Vec{3,Float64}[]\n    ef3 = Vec{3,Float64}[]\n    for P in Ps\n        a = abs.(P)\n        j = 1\n        if a[1] > a[3]; a[3] = a[1]; j = 2; end\n        if a[2] > a[3]; j = 3; end\n\n        e3 = P\n        e2 = Tensors.cross(P, basevec(Vec{3}, j))\n        e2 /= norm(e2)\n        e1 = Tensors.cross(e2, P)\n\n        push!(ef1, e1)\n        push!(ef2, e2)\n        push!(ef3, e3)\n    end\n    return ef1, ef2, ef3\n\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Lamina-coordinate-system","page":"Linear shell","title":"Lamina coordinate system","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The second coordinate system is the so called Lamina Coordinate system. It is created for each integration point, and is defined to be tangent to the mid-surface. It is in this system that we enforce that plane stress assumption, i.e. sigma_zz = 0. The function below returns the rotation matrix, boldsymbolq, for this coordinate system.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function lamina_coordsys(dNdξ, ζ, x, p, h)\n\n    e1 = zero(Vec{3})\n    e2 = zero(Vec{3})\n\n    for i in 1:length(dNdξ)\n        e1 += dNdξ[i][1] * x[i] + 0.5*h*ζ * dNdξ[i][1] * p[i]\n        e2 += dNdξ[i][2] * x[i] + 0.5*h*ζ * dNdξ[i][1] * p[i]\n    end\n\n    e1 /= norm(e1)\n    e2 /= norm(e2)\n\n    ez = Tensors.cross(e1,e2)\n    ez /= norm(ez)\n\n    a = 0.5*(e1 + e2)\n    a /= norm(a)\n\n    b = Tensors.cross(ez,a)\n    b /= norm(b)\n\n    ex = sqrt(2)/2 * (a - b)\n    ey = sqrt(2)/2 * (a + b)\n\n    return Tensor{2,3}(hcat(ex,ey,ez))\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Geometrical-description","page":"Linear shell","title":"Geometrical description","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"A material point in the shell is defined as","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"boldsymbol x(xi eta zeta) = sum_a=1^N_textnodes N_a(xi eta) boldsymbolbarx_a + ζ frach2 boldsymbolbarp_a","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"where boldsymbolbarx_a are nodal positions on the mid-surface, and boldsymbolbarp_a is an vector that defines the fiber direction on the reference surface. N_a arethe shape functions.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Based on the defintion of the position vector, we create an function for obtaining the Jacobian-matrix,","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"J_ij = fracpartial x_ipartial xi_j","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function getjacobian(q, N, dNdξ, ζ, X, p, h)\n\n    J = zeros(3,3)\n    for a in 1:length(N)\n        for i in 1:3, j in 1:3\n            _dNdξ = (j==3) ? 0.0 : dNdξ[a][j]\n            _dζdξ = (j==3) ? 1.0 : 0.0\n            _N = N[a]\n\n            J[i,j] += _dNdξ * X[a][i]  +  (_dNdξ*ζ + _N*_dζdξ) * h/2 * p[a][i]\n        end\n    end\n\n    return (q' * J) |> Tensor{2,3,Float64}\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Strains","page":"Linear shell","title":"Strains","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Small deformation is assumed,","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"varepsilon_ij= frac12(fracpartial u_ipartial x_j + fracpartial u_jpartial x_i)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The displacement field is calculated as:","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"boldsymbol u = sum_a=1^N_textnodes N_a barboldsymbol u_a +\n N_a ζfrach2(theta_a2 boldsymbol e^f_a1 - theta_a1 boldsymbol e^f_a2)\n","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"The gradient of the displacement (in the lamina coordinate system), then becomes:","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"fracpartial u_ipartial x_j = sum_m=1^3 q_im sum_a=1^N_textnodes fracpartial N_apartial x_j baru_am +\n fracpartial(N_a ζ)partial x_j frach2 (theta_a2 e^f_am1 - theta_a1 e^f_am2)","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function strain(dofvec::Vector{T}, N, dNdx, ζ, dζdx, q, ef1, ef2, h) where T\n\n    u = reinterpret(Vec{3,T}, dofvec[1:12])\n    θ = reinterpret(Vec{2,T}, dofvec[13:20])\n\n    dudx = zeros(T, 3, 3)\n    for m in 1:3, j in 1:3\n        for a in 1:length(N)\n            dudx[m,j] += dNdx[a][j] * u[a][m] + h/2 * (dNdx[a][j]*ζ + N[a]*dζdx[j]) * (θ[a][2]*ef1[a][m] - θ[a][1]*ef2[a][m])\n        end\n    end\n\n    dudx = q*dudx\n    ε = [dudx[1,1], dudx[2,2], dudx[1,2]+dudx[2,1], dudx[2,3]+dudx[3,2], dudx[1,3]+dudx[3,1]]\n    return ε\n\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/#Main-element-routine","page":"Linear shell","title":"Main element routine","text":"","category":"section"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Below is the main routine that calculates the stiffness matrix of the shell element. Since it is a so called degenerate shell element, the code is similar to that for an standard continuum element.","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"function integrate_shell!(ke, cv, qr_ooplane, X, data)\n    nnodes = getnbasefunctions(cv)\n    ndofs = nnodes*5\n    h = data.thickness\n\n    #Create the directors in each node.\n    #Note: For a more general case, the directors should\n    #be input parameters for the element routine.\n    p = zeros(Vec{3}, nnodes)\n    for i in 1:nnodes\n        a = Vec{3}((0.0, 0.0, 1.0))\n        p[i] = a/norm(a)\n    end\n\n    ef1, ef2, ef3 = fiber_coordsys(p)\n\n    for iqp in 1:getnquadpoints(cv)\n\n        dNdξ = cv.dNdξ[:,iqp]\n        N = cv.N[:,iqp]\n\n        for oqp in 1:length(qr_ooplane.weights)\n\n            ζ = qr_ooplane.points[oqp][1]\n\n            q = lamina_coordsys(dNdξ, ζ, X, p, h)\n            J = getjacobian(q, N, dNdξ, ζ, X, p, h)\n            Jinv = inv(J)\n\n            dζdx = Vec{3}((0.0, 0.0, 1.0)) ⋅ Jinv\n            dNdx = [Vec{3}((dNdξ[i][1], dNdξ[i][2], 0.0)) ⋅ Jinv for i in 1:nnodes]\n\n\n            #For simplicity, use automatic differentiation to construct the B-matrix from the strain.\n            B = ForwardDiff.jacobian(\n                (a) -> strain(a, N, dNdx, ζ, dζdx, q, ef1, ef2, h), zeros(Float64, ndofs) )\n\n            dV = det(J) * cv.qr_weights[iqp] * qr_ooplane.weights[oqp]\n            ke .+= B'*data.C*B * dV\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"Run everything:","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"main()","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"","category":"page"},{"location":"examples/linear_shell/","page":"Linear shell","title":"Linear shell","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/fe_intro/#Introduction-to-FEM","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Here we will present a very brief introduction to partial differential equations (PDEs) and to the finite element method (FEM). Perhaps the simplest PDE of all is the (linear) heat equation, also known as the Laplace equation. We will use this equation as a demonstrative example of the method, and demonstrate how we go from the strong format of the equation, to the weak form, and then finally to the discrete FE problem.","category":"page"},{"location":"manual/fe_intro/#Strong-format","page":"Introduction to FEM","title":"Strong format","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The strong format of the heat equation may be written as:","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"- mathbfnabla cdot mathbfq(u) = b quad x in Omega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where u is the unknown temperature field, mathbfq is the heat flux and b is an internal heat source. To complete the system of equations we need boundary conditions. There are different types of boundary conditions, but the most common ones are Dirichlet – which means that the solution u is known at some part of the boundary, and Neumann – which means that the gradient of the solution, mathbfnabla is known. For example","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u = u^mathrmp quad forall mathbfx in Gamma_mathrmD\nmathbfq cdot mathbfn = q^mathrmp quad forall mathbfx in Gamma_mathrmN","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"i.e. the temperature is presribed to u^mathrmp at the Dirichlet part of the boundary, Gamma_mathrmD, and the heat flux is prescribed to q^mathrmp at the Neumann part of the boundary, Gamma_mathrmN.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We also need a constitutive equation which links the temperature field, u, to the heat flux, mathbfq. The simplest case is to use Fourier's law","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"mathbfq = -k mathbfnablau","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where k is the conductivity of the material. For simplicity we will consider only constant conductivity k.","category":"page"},{"location":"manual/fe_intro/#Weak-format","page":"Introduction to FEM","title":"Weak format","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The solution to the equation above is usually calculated from the corresponding weak format. By multiplying the equation with an arbitrary test function delta u, integrating over the domain and using partial integration we obtain the weak form; Find u in mathbbU s.t.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"int_Omega mathbfdelta u cdot (k mathbfu) mathrmdOmega =\nint_Gamma_mathrmN delta u q^mathrmp mathrmdGamma +\nint_Omega delta u b mathrmdOmega quad forall delta u in mathbbU^0","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where mathbbU mathbbU^0 are function spaces with sufficiently regular functions. It can be shown that the solution to the weak form is identical to the solution to the strong format.","category":"page"},{"location":"manual/fe_intro/#FE-approximation","page":"Introduction to FEM","title":"FE-approximation","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We now introduce the finite element approximation u_h approx u as a sum of shape functions, N_i and nodal values, a_i. We approximate the test function in the same way (known as the Galerkin method):","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u_mathrmh = sum_i=1^mathrmN N_i a_iqquad\ndelta u_mathrmh = sum_i=1^mathrmN N_i delta a_i","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We may now inserted these approximations in the weak format, which results in","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"sum_i^N sum_j^N delta a_i int_Omega mathbfnabla N_i cdot (k cdot mathbfnabla N_j) mathrmdOmega a_j =\nsum_i^N delta a_i int_Gamma N_i q^mathrmp mathrmdGamma +\nsum_i^N delta a_i int_Omega N_i b mathrmdOmega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Since delta u can be chosen arbitrary, the nodal values delta a_i can be chosen arbitrary. Thus, the equation can be written as a linear system of equations","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlineK underlinea = underlinef","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where underlineK is the (tangent) stiffness matrix, underlinea is the solution vector with the nodal values and underlinef is the force vector. The elements of underlineK and underlinef are given by","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlineK_ij =\n    int_Omega mathbfnablaN_i cdot (k cdot mathbfnablaN_j) mathrmdOmega\n\nunderlinef_i =\n    int_Gamma N_i q^mathrmp mathrmdGamma + int_Omega N_i b mathrmdOmega","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The solution to the system (which in this case is linear) is simply given by inverting the matrix underlineK. We also need to take care of the Dirichlet boundary conditions, by enforcing the correct nodal values a_i to the prescribed values.","category":"page"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"underlinea = underlineK^-1 underlinef","category":"page"},{"location":"manual/fe_intro/#Implementation","page":"Introduction to FEM","title":"Implementation","text":"","category":"section"},{"location":"manual/fe_intro/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In practice, the shape functions N are only non-zero on parts of the domain Omega. Thus, the integrals are evaluated on sub-domains, called elements or cells. Each cell gives a contribution to the global stiffness matrix and force vector. For a solution of the heat equation, as implemented in Ferrite, check out this thoroughly commented example.","category":"page"},{"location":"reference/grid/","page":"Grid","title":"Grid","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"using Ferrite\ngrid = generate_grid(Triangle, (2, 2))\ndh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\nu = rand(ndofs(dh)); σ = rand(getncells(grid))","category":"page"},{"location":"manual/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"When the problem is solved, and the solution vector u is known we typically want to visualize it. The simplest way to do this is to write the solution to a VTK-file, which can be viewed in e.g. Paraview. To write VTK-files, Ferrite uses, and extends, functions from the WriteVTK.jl package to simplify the exporting.","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"First we need to create a file, based on the grid. This is done with the vtk_grid function:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", grid)\n# hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Next we have to add data to the file. We may add different kinds of data; point data using vtk_point_data or cell data using vtk_cell_data. Point data is data for each nodal coordinate in the grid, for example our solution vector. Point data can be either scalars or vectors. Cell data is – as the name suggests – data for each cell. This can be for example the stress. As an example, lets add a solution vector u as point data, and a vector with stress for each cell, σ, as cell data:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_point_data(vtk, u, \"my-point-data\")\nvtk_cell_data(vtk,  σ, \"my-cell-data\")\n# hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Finally, we need to save the file to disk, using vtk_save","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"Alternatively, all of the above can be done using a do block:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", grid) do vtk\n    vtk_point_data(vtk, u, \"my-point-data\")\n    vtk_cell_data(vtk, σ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"For other functionality, and more information refer to the WriteVTK.jl README. In particular, for exporting the solution at multiple time steps, the section on PVD files is useful.","category":"page"},{"location":"manual/export/#Exporting-with-DofHandler","page":"Export","title":"Exporting with DofHandler","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"There is an even more convenient way to export a solution vector u – using the DofHandler. The DofHandler already contains all of the information needed, such as the names of our fields and if they are scalar or vector fields. But most importantly the DofHandler knows about the numbering and distribution of degrees of freedom, and thus knows how to \"distribute\" the solution vector on the grid. For example, lets say we have a DofHandler dh and a solution vector u:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk = vtk_grid(\"my-solution\", dh)\nvtk_point_data(vtk, dh, u)\nvtk_save(vtk)\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"or with a do-block:","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"my-solution\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\n    vtk_cell_data(vtk, σ, \"my-cell-data\")\nend\nrm(\"my-solution.vtu\") # hide","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"When vtk_point_data is used with a DofHandler all of the fields will be written to the VTK file, and the names will be determined by the fieldname symbol that was used when the field was added to the DofHandler.","category":"page"},{"location":"manual/export/#Exporting-Boundary-Conditions","page":"Export","title":"Exporting Boundary Conditions","text":"","category":"section"},{"location":"manual/export/","page":"Export","title":"Export","text":"There is also a vtk_point_data which accepts a ConstraintHandler. This method is useful to verify that the boundary conditions are applied where they are supposed to. For a ConstraintHandler ch we can export the boundary conditions as","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"vtk_grid(\"boundary-conditions\", grid) do vtk\n    vtk_point_data(vtk, ch)\nend","category":"page"},{"location":"manual/export/","page":"Export","title":"Export","text":"This will export zero-valued fields with ones on the parts where the boundary conditions are active.","category":"page"},{"location":"reference/dofhandler/","page":"DofHandler","title":"DofHandler","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"reference/dofhandler/#DofHandler","page":"DofHandler","title":"DofHandler","text":"","category":"section"},{"location":"reference/dofhandler/","page":"DofHandler","title":"DofHandler","text":"DofHandler","category":"page"},{"location":"reference/dofhandler/#Ferrite.DofHandler","page":"DofHandler","title":"Ferrite.DofHandler","text":"DofHandler(grid::Grid)\n\nConstruct a DofHandler based on the grid grid.\n\n\n\n\n\n","category":"type"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/heat_equation.jl\"","category":"page"},{"location":"examples/heat_equation/#Heat-Equation","page":"Heat Equation","title":"Heat Equation","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"tip: Tip\nThis example is also available as a Jupyter notebook: heat_equation.ipynb","category":"page"},{"location":"examples/heat_equation/#Introduction","page":"Heat Equation","title":"Introduction","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The heat equation is the \"Hello, world!\" equation of finite elements. Here we solve the equation on a unit square, with a uniform internal source. The strong form of the (linear) heat equation is given by","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":" -nabla cdot (k nabla u) = f  quad x in Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set f = 1 and k = 1. We will consider homogeneous Dirichlet boundary conditions such that","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"u(x) = 0 quad x in partial Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where partial Omega denotes the boundary of Omega.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The resulting weak form is given by","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"int_Omega nabla v cdot nabla u  dOmega = int_Omega v  dOmega","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where v is a suitable test function.","category":"page"},{"location":"examples/heat_equation/#Commented-Program","page":"Heat Equation","title":"Commented Program","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"First we load Ferrite, and some other packages we need","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, SparseArrays","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We start  generating a simple grid with 20x20 quadrilateral elements using generate_grid. The generator defaults to the unit square, so we don't need to specify the corners of the domain.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"grid = generate_grid(Quadrilateral, (20, 20));\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Trial-and-test-functions","page":"Heat Equation","title":"Trial and test functions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"A CellValues facilitates the process of evaluating values and gradients of test and trial functions (among other things). Since the problem is a scalar problem we will use a CellScalarValues object. To define this we need to specify an interpolation space for the shape functions. We use Lagrange functions (both for interpolating the function and the geometry) based on the reference \"cube\". We also define a quadrature rule based on the same reference cube. We combine the interpolation and the quadrature rule to a CellScalarValues object.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Degrees-of-freedom","page":"Heat Equation","title":"Degrees of freedom","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we need to define a DofHandler, which will take care of numbering and distribution of degrees of freedom for our approximated fields. We create the DofHandler and then add a single field called u. Lastly we close! the DofHandler, it is now that the dofs are distributed for all the elements.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now that we have distributed all our dofs we can create our tangent matrix, using create_sparsity_pattern. This function returns a sparse matrix with the correct elements stored.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"K = create_sparsity_pattern(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We can inspect the pattern using the spy function from UnicodePlots.jl. By default the stored values are set to 0, so we first need to fill the stored values, e.g. K.nzval with something meaningful.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using UnicodePlots\nfill!(K.nzval, 1.0)\nspy(K; height = 15)","category":"page"},{"location":"examples/heat_equation/#Boundary-conditions","page":"Heat Equation","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"In Ferrite constraints like Dirichlet boundary conditions are handled by a ConstraintHandler.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"ch = ConstraintHandler(dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we need to add constraints to ch. For this problem we define homogeneous Dirichlet boundary conditions on the whole boundary, i.e. the union of all the face sets on the boundary.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"∂Ω = union(getfaceset.((grid, ), [\"left\", \"right\", \"top\", \"bottom\"])...);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we are set up to define our constraint. We specify which field the condition is for, and our combined face set ∂Ω. The last argument is a function which takes the spatial coordinate x and the current time t and returns the prescribed value. In this case it is trivial – no matter what x and t we return 0. When we have specified our constraint we add! it to ch.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"dbc = Dirichlet(:u, ∂Ω, (x, t) -> 0)\nadd!(ch, dbc);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We also need to close! and update! our boundary conditions. When we call close! the dofs which will be constrained by the boundary conditions are calculated and stored in our ch object. Since the boundary conditions are, in this case, independent of time we can update! them directly with e.g. t = 0.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"close!(ch)\nupdate!(ch, 0.0);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Assembling-the-linear-system","page":"Heat Equation","title":"Assembling the linear system","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Now we have all the pieces needed to assemble the linear system, K u = f. We define a function, doassemble to do the assembly, which takes our cellvalues, the sparse matrix and our DofHandler as input arguments. The function returns the assembled stiffness matrix, and the force vector.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function doassemble(cellvalues::CellScalarValues{dim}, K::SparseMatrixCSC, dh::DofHandler) where {dim}","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We allocate the element stiffness matrix and element force vector just once before looping over all the cells instead of allocating them every time in the loop.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next we define the global force vector f and use that and the stiffness matrix K and create an assembler. The assembler is just a thin wrapper around f and K and some extra storage to make the assembling faster.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It is now time to loop over all the cells in our grid. We do this by iterating over a CellIterator. The iterator caches some useful things for us, for example the nodal coordinates for the cell, and the local degrees of freedom.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"    @inbounds for cell in CellIterator(dh)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Always remember to reset the element stiffness matrix and force vector since we reuse them for all elements.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        fill!(Ke, 0)\n        fill!(fe, 0)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"For each cell we also need to reinitialize the cached values in cellvalues.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        reinit!(cellvalues, cell)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It is now time to loop over all the quadrature points in the cell and assemble the contribution to Ke and fe. The integration weight can be queried from cellvalues by getdetJdV.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"For each quadrature point we loop over all the (local) shape functions. We need the value and gradient of the testfunction v and also the gradient of the trial function u. We get all of these from cellvalues.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The last step in the element loop is to assemble Ke and fe into the global K and f with assemble!.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Solution-of-the-system","page":"Heat Equation","title":"Solution of the system","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The last step is to solve the system. First we call doassemble to obtain the global stiffness matrix K and force vector f.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"K, f = doassemble(cellvalues, K, dh);\nnothing #hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To account for the boundary conditions we use the apply! function. This modifies elements in K and f respectively, such that we can get the correct solution vector u by using \\.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"apply!(K, f, ch)\nu = K \\ f;\nnothing #hide","category":"page"},{"location":"examples/heat_equation/#Exporting-to-VTK","page":"Heat Equation","title":"Exporting to VTK","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To visualize the result we export the grid and our field u to a VTK-file, which can be viewed in e.g. ParaView.","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vtk_grid(\"heat_equation\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\nend","category":"page"},{"location":"examples/heat_equation/#heat_equation-plain-program","page":"Heat Equation","title":"Plain Program","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Below follows a version of the program without any comments. The file is also available here: heat_equation.jl","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, SparseArrays\n\ngrid = generate_grid(Quadrilateral, (20, 20));\n\ndim = 2\nip = Lagrange{dim, RefCube, 1}()\nqr = QuadratureRule{dim, RefCube}(2)\ncellvalues = CellScalarValues(qr, ip);\n\ndh = DofHandler(grid)\npush!(dh, :u, 1)\nclose!(dh);\n\nK = create_sparsity_pattern(dh);\n\nusing UnicodePlots\nfill!(K.nzval, 1.0)\nspy(K; height = 15)\n\nch = ConstraintHandler(dh);\n\n∂Ω = union(getfaceset.((grid, ), [\"left\", \"right\", \"top\", \"bottom\"])...);\n\ndbc = Dirichlet(:u, ∂Ω, (x, t) -> 0)\nadd!(ch, dbc);\n\nclose!(ch)\nupdate!(ch, 0.0);\n\nfunction doassemble(cellvalues::CellScalarValues{dim}, K::SparseMatrixCSC, dh::DofHandler) where {dim}\n\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    fe = zeros(n_basefuncs)\n\n    f = zeros(ndofs(dh))\n    assembler = start_assemble(K, f)\n\n    @inbounds for cell in CellIterator(dh)\n\n        fill!(Ke, 0)\n        fill!(fe, 0)\n\n        reinit!(cellvalues, cell)\n\n        for q_point in 1:getnquadpoints(cellvalues)\n            dΩ = getdetJdV(cellvalues, q_point)\n\n            for i in 1:n_basefuncs\n                v  = shape_value(cellvalues, q_point, i)\n                ∇v = shape_gradient(cellvalues, q_point, i)\n                fe[i] += v * dΩ\n                for j in 1:n_basefuncs\n                    ∇u = shape_gradient(cellvalues, q_point, j)\n                    Ke[i, j] += (∇v ⋅ ∇u) * dΩ\n                end\n            end\n        end\n\n        assemble!(assembler, celldofs(cell), fe, Ke)\n    end\n    return K, f\nend\n\nK, f = doassemble(cellvalues, K, dh);\n\napply!(K, f, ch)\nu = K \\ f;\n\nvtk_grid(\"heat_equation\", dh) do vtk\n    vtk_point_data(vtk, dh, u)\nend\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"","category":"page"},{"location":"examples/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Every PDE is accompanied with boundary conditions. There are different types of boundary conditions, and they need to be handled in different ways. Below we discuss how to handle the most common ones, Dirichlet and Neumann boundary conditions, and how to do it Ferrite.","category":"page"},{"location":"manual/boundary_conditions/#Dirichlet-Boundary-Conditions","page":"Boundary Conditions","title":"Dirichlet Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At a Dirichlet boundary the solution is prescribed to a given value. For the discrete FE-solution this means that there are some degrees of freedom that are fixed. To be able to tell which degrees of freedom we should constrain we need the DofHandler.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"ch = ConstraintHandler(dh)","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"TBW","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"note: Examples\nThe following commented examples makes use of Dirichlet boundary conditions:Heat Equation\nTODO","category":"page"},{"location":"manual/boundary_conditions/#Neumann-Boundary-Conditions","page":"Boundary Conditions","title":"Neumann Boundary Conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At the Neumann part of the boundary we know something about the gradient of the solution.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"As an example, the following code snippet can be included in the element routine, to evaluate the boundary integral:","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"for face in 1:nfaces(cell)\n    if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"Neumann Boundary\")\n        reinit!(facevalues, cell, face)\n        for q_point in 1:getnquadpoints(facevalues)\n            dΓ = getdetJdV(facevalues, q_point)\n            for i in 1:getnbasefunctions(facevalues)\n                δu = shape_value(facevalues, q_point, i)\n                fe[i] += δu * b * dΓ\n            end\n        end\n    end\nend","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We start by looping over all the faces of the cell, next we have to check if this particular face is located on the boundary, and then also check that the face is located on our face-set called \"Neumann Boundary\". If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize facevalues for this face, using reinit!. When reinit!ing facevalues we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.","category":"page"},{"location":"manual/boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"note: Examples\nThe following commented examples makes use of Neumann boundary conditions:TODO","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"#Ferrite.jl","page":"Home","title":"Ferrite.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple finite element toolbox written in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ferrite is a finite element toolbox that provides functionalities to implement finite element analysis in Julia. The aim is to be general and to keep mathematical abstractions. The main functionalities of the package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Facilitate integration using different quadrature rules.\nDefine different finite element interpolations.\nEvaluate shape functions, derivatives of shape functions etc. for the different interpolations and quadrature rules.\nEvaluate functions and derivatives in the finite element space.\nGenerate simple grids.\nExport grids and solutions to VTK.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to get started with Ferrite is to look at the documented examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nFerrite is still under development. If you find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the Ferrite GitHub page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install Ferrite from the Pkg REPL (press ] in the Julia REPL to enter pkg> mode):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Ferrite","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nAlternative installation method:julia> import Pkg; Pkg.add(\"Ferrite\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ferrite","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"DocTestSetup = :(using Ferrite)","category":"page"},{"location":"manual/assembly/#Assembly","page":"Assembly","title":"Assembly","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"When the local stiffness matrix and force vector have been calculated they should be assembled into the global stiffness matrix and the global force vector. This is just a matter of adding the local matrix and vector to the global one, at the correct place. Consider e.g. assembling the local stiffness matrix ke and the local force vector fe into the global K and f respectively. These should be assembled into the row/column which corresponds to the degrees of freedom for the cell:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K[celldofs, celldofs] += ke\nf[celldofs]           += fe","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"where celldofs is the vector containing the degrees of freedom for the cell. The method above is very inefficient – it is especially costly to index into the sparse matrix K directly. Therefore we will instead use an Assembler that will help with the assembling of both the global stiffness matrix and the global force vector. It is also often convenient to create the sparse matrix just once, and reuse the allocated matrix. This is useful for e.g. iterative solvers or time dependent problems where the sparse matrix structure, or Sparsity Pattern will stay the same in every iteration/ time step.","category":"page"},{"location":"manual/assembly/#Sparsity-Pattern","page":"Assembly","title":"Sparsity Pattern","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler we can obtain the corresponding sparse matrix by using the create_sparsity_pattern function. This will setup a SparseMatrixCSC with stored values on all the places corresponding to the degree of freedom numbering in the DofHandler. This means that when we assemble into the global stiffness matrix there is no need to change the internal representation of the sparse matrix since the sparse structure will not change.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Often the finite element problem is symmetric and will result in a symmetric sparse matrix. This information is often something that the sparse solver can take advantage of. If the solver only needs half the matrix there is no need to assemble both halves. For this purpose there is a create_symmetric_sparsity_pattern function that will only create the upper half of the matrix, and return a Symmetric wrapped SparseMatrixCSC.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Given a DofHandler dh we can obtain the (symmetric) sparsity pattern as","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nK = create_symmetric_sparsity_pattern(dh)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"The returned sparse matrix will be used together with an Assembler, which assembles efficiently into the matrix, without modifying the internal representation.","category":"page"},{"location":"manual/assembly/#Assembler","page":"Assembly","title":"Assembler","text":"","category":"section"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"Assembling efficiently into the sparse matrix requires some extra workspace. This workspace is allocated in an Assembler. start_assemble is used to create an Assembler:","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"A = start_assemble(K)\nA = start_assemble(K, f)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"where K is the global stiffness matrix, and f the global force vector. It is optional to give the force vector to the assembler – sometimes there is no need to assemble a global force vector.","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"fds","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"assemble!(A, celldofs, ke)\nassemble!(A, celldofs, ke, fe)","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"To give a more","category":"page"},{"location":"manual/assembly/","page":"Assembly","title":"Assembly","text":"K = create_sparsity_pattern(dh)\nf = zeros(ndofs(dh))\nA = start_assemble(K, f)\n\nfor cell in CellIterator(dh)\n    ke, fe = ...\n    assemble!(A, celldofs(cell), ke, fe)\nend","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/quasi_incompressible_hyperelasticity.jl\"","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Nearly-Incompressible-Hyperelasticity","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"(Image: )","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"tip: Tip\nThis example is also available as a Jupyter notebook: quasi_incompressible_hyperelasticity.ipynb","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Introduction","page":"Nearly Incompressible Hyperelasticity","title":"Introduction","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"In this example we study quasi- or nearly-incompressible hyperelasticity using the stable Taylor-Hood approximation. In spirit, this example is the nonlinear analogue of incompressible_elasticity and the incompressible analogue of hyperelasticity. Much of the code therefore follows from the above two examples. The problem is formulated in the undeformed or reference configuration with the displacement u and pressure p being the unknown fields. We now briefly outline the formulation. Consider the standard hyperelasticity problem","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  u = argmin_vinmathcalKPi(v)quad textwherequad Pi(v)  = int_Omega Psi(v)  mathrmdOmega ","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"For clarity of presentation we ignore any non-zero surface tractions and body forces and instead consider only applied displacements (i.e. non-homogeneous dirichlet boundary conditions). Moreover we stick our attention to the standard Neo-Hookean stored energy density","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"    Psi(u) = fracmu2left(I_1 - 3 right) - mu log(J) + fraclambda2left( J - 1right)^2","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"where I_1 = FF = F_ijF_ij and J = det(F) denote the standard invariants of the deformation gradient tensor F = mathbbI+nabla u. The above problem is ill-posed in the limit of incompressibility (or near-incompressibility), namely when","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"    lambdamu rightarrow +infty","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"In order to alleviate the problem, we consider the partial legendre transform of the strain energy density Ψ with respect to J = det(F), namely","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  widehatPsi(u p) = sup_J left p(J - 1) - fracmu2left(I_1 - 3 right) + mu log(J) - fraclambda2left( J - 1right)^2 right","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The supremum, say J^star, can be calculated in closed form by the first order optimailty condition partialwidehatPsipartial J = 0. This gives","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  J^star(p) = fraclambda + p + sqrt(lambda + p)^2 + 4 lambda mu (2 lambda)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Furthermore, taking the partial legendre transform of widehatPsi once again, gives us back the original problem, i.e.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"    Psi(u) = Psi^star(u p) = sup_p left p(J - 1) - p(J^star - 1) + fracmu2left(I_1 - 3 right) - mu log(J^star) + fraclambda2left( J^star - 1right)^2 right","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Therefore our original hyperelasticity problem can now be reformulated as","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  inf_uinmathcalKsup_p int_OmegaPsi^star (u p)  mathrmdOmega","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The total (modified) energy Pi^star can then be written as","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  Pi^star(u p) = int_Omega p (J - J^star)  mathrmdOmega + int_Omega fracmu2 left( I_1 - 3right)  mathrmdOmega - int_Omega mulog(J^star) mathrmdOmega + int_Omega fraclambda2left( J^star - 1 right)^2 mathrmdOmega","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The euler-lagrange equations corresponding to the above energy give us our governing PDEs in the weak form, namely","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  int_Omega fracpartialPsi^starpartial Fdelta F  mathrmdOmega = 0","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"  int_Omega fracpartial Psi^starpartial pdelta p  mathrmdOmega = 0","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"where δF = δ∇u = ∇(δu) and δu and δp denote arbitrary variations with respect to displacement and pressure (or the test functions). See the references below for a more detailed explanation of the above mathematical trick. Now, in order to apply Newton's method to the above problem, we further need to linearize the above equations and calculate the respective hessians (or tangents), namely, partial^2Psi^starpartial F^2, partial^2Psi^starpartial p^2 and partial^2Psi^starpartial Fpartial p which, using Tensors.jl, can be determined conveniently using automatic differentiation (see the code below). Hence we only need to define the above potential. The remaineder of the example follows similarly.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#References","page":"Nearly Incompressible Hyperelasticity","title":"References","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"A paradigm for higher-order polygonal elements in finite elasticity using a gradient correction scheme, CMAME 2016, 306, 216–251\nApproximation of incompressible large deformation elastic problems: some unresolved issues, Computational Mechanics, 2013","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We now get to the actual code. First, we import the respective packages","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"using Ferrite, Tensors, ProgressMeter\nusing BlockArrays, SparseArrays, LinearAlgebra","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and the corresponding struct to store our material properties.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"struct NeoHooke\n    μ::Float64\n    λ::Float64\nend","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We then create a function to generate a simple test mesh on which to compute FE solution. We also mark the boundaries to later assign Dirichlet boundary conditions","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function importTestGrid()\n    grid = generate_grid(Tetrahedron, (5, 5, 5), zero(Vec{3}), ones(Vec{3}));\n    addfaceset!(grid, \"myBottom\", x -> norm(x[2]) ≈ 0.0);\n    addfaceset!(grid, \"myBack\", x -> norm(x[3]) ≈ 0.0);\n    addfaceset!(grid, \"myRight\", x -> norm(x[1]) ≈ 1.0);\n    addfaceset!(grid, \"myLeft\", x -> norm(x[1]) ≈ 0.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The function to create corresponding cellvalues for the displacement field u and pressure p follows in a similar fashion from the incompressible_elasticity example","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(4)\n    face_qr = QuadratureRule{2,RefTetrahedron}(4)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We now create the function for Ψ*","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function Ψ(F, p, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(tdot(F))\n    J = det(F)\n    Js = (λ + p + sqrt((λ + p)^2. + 4. * λ * μ ))/(2. * λ)\n    return p * (Js - J) + μ / 2 * (Ic - 3) - μ * log(Js) + λ / 2 * (Js - 1)^2\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and it's derivatives (required in computing the jacobian and hessian respectively)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function constitutive_driver(F, p, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂F², ∂Ψ∂F = Tensors.hessian(y -> Ψ(y, p, mp), F, :all)\n    ∂²Ψ∂p², ∂Ψ∂p = Tensors.hessian(y -> Ψ(F, y, mp), p, :all)\n    ∂²Ψ∂F∂p = Tensors.gradient(q -> Tensors.gradient(y -> Ψ(y, q, mp), F), p)\n    return ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The functions to create the DofHandler and ConstraintHandler (to assign corresponding boundary conditions) follow likewise from the incompressible elasticity example, namely","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 3, ipu) # displacement dim = 3\n    push!(dh, :p, 1, ipp) # pressure dim = 1\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We are simulating a uniaxial tensile loading of a unit cube. Hence we apply a displacement field (:u) in x direction on the right face. The left, bottom and back faces are fixed in the x, y and z components of the displacement so as to emulate the uniaxial nature of the loading.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myLeft\"), (x,t) -> zero(Vec{1}), [1]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBottom\"), (x,t) -> zero(Vec{1}), [2]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBack\"), (x,t) -> zero(Vec{1}), [3]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myRight\"), (x,t) -> t*ones(Vec{1}), [1]))\n    close!(dbc)\n    Ferrite.update!(dbc, 0.0)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Also, since we are considering incompressible hyperelasticity, an interesting quantity that we can compute is the deformed volume of the solid. It is easy to show that this is equal to ∫J*dΩ where J=det(F). This can be done at the level of each element (cell)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function calculate_element_volume(cell, cellvalues_u, ue)\n    reinit!(cellvalues_u, cell)\n    evol::Float64=0.0;\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        F = one(∇u) + ∇u\n        J = det(F)\n        evol += J * dΩ\n    end\n    return evol\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"and then assembled over all the cells (elements)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function calculate_volume_deformed_mesh(w, dh::DofHandler, cellvalues_u)\n    evol::Float64 = 0.0;\n    @inbounds for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        nu = getnbasefunctions(cellvalues_u)\n        global_dofs_u = global_dofs[1:nu]\n        ue = w[global_dofs_u]\n        δevol = calculate_element_volume(cell, cellvalues_u, ue)\n        evol += δevol;\n    end\n    return evol\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The function to assemble the element stiffness matrix for each element in the mesh now has a block structure like in incompressible_elasticity.","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function assemble_element!(Ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n    # Reinitialize cell values, and reset output arrays\n    ublock, pblock = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n    fill!(Ke, 0.0)\n    fill!(fe, 0.0)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        # Compute deformation gradient F\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        p = function_value(cellvalues_p, qp, pe)\n        F = one(∇u) + ∇u\n\n        # Compute first Piola-Kirchhoff stress and tangent modulus\n        ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p = constitutive_driver(F, p, mp)\n\n        # Loop over the `u`-test functions to calculate the `u`-`u` and `u`-`p` blocks\n        for i in 1:n_basefuncs_u\n            # gradient of the test function\n            ∇δui = shape_gradient(cellvalues_u, qp, i)\n            # Add contribution to the residual from this test function\n            fe[BlockIndex((ublock), (i))] += ( ∇δui ⊡ ∂Ψ∂F) * dΩ\n\n            ∇δui∂S∂F = ∇δui ⊡ ∂²Ψ∂F²\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, ublock), (i, j))] += ( ∇δui∂S∂F ⊡ ∇δuj ) * dΩ\n            end\n            # Loop over the `p`-test functions\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, pblock), (i, j))] += ( ∂²Ψ∂F∂p ⊡ ∇δui ) * δp * dΩ\n            end\n        end\n        # Loop over the `p`-test functions to calculate the `p-`u` and `p`-`p` blocks\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, qp, i)\n            fe[BlockIndex((pblock), (i))] += ( δp * ∂Ψ∂p) * dΩ\n\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n                Ke[BlockIndex((pblock, ublock), (i, j))] += ∇δuj ⊡ ∂²Ψ∂F∂p * δp * dΩ\n            end\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                Ke[BlockIndex((pblock, pblock), (i, j))] += δp * ∂²Ψ∂p² * δp * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"The only thing that changes in the assembly of the global stiffness matrix is slicing the corresponding element dofs for the displacement (see global_dofsu) and pressure (global_dofsp).","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function assemble_global!(K::SparseMatrixCSC, f, cellvalues_u::CellVectorValues{dim},\n                         cellvalues_p::CellScalarValues{dim}, dh::DofHandler, mp::NeoHooke, w) where {dim}\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    # start_assemble resets K and f\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    assembler = start_assemble(K, f)\n    # Loop over all cells in the grid\n    for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        global_dofsu = global_dofs[1:nu]; # first nu dofs are displacement\n        global_dofsp = global_dofs[nu + 1:end]; # last np dofs are pressure\n        @assert size(global_dofs, 1) == nu + np # sanity check\n        ue = w[global_dofsu] # displacement dofs for the current cell\n        pe = w[global_dofsp] # pressure dofs for the current cell\n        assemble_element!(ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n        assemble!(assembler, global_dofs, fe, ke)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We now define a main function solve. For nonlinear quasistatic problems we often like to parameterize the solution in terms of a pseudo time like parameter, which in this case is used to gradually apply the boundary displacement on the right face. Also for definitenessm we consider λ/μ = 10⁴","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"function solve(interpolation_u, interpolation_p)\n\n    # import the mesh\n    grid = importTestGrid()\n\n    # Material parameters\n    μ = 1.\n    λ = 1.E4 * μ\n    mp = NeoHooke(μ, λ)\n\n    # Create the DofHandler and CellValues\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # Create the DirichletBCs\n    dbc = create_bc(dh)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    w  = zeros(_ndofs)\n    ΔΔw = zeros(_ndofs)\n    apply!(w, dbc)\n\n    # Create the sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    f = zeros(_ndofs)\n\n    # We run the simulation parameterized by a time like parameter. `Tf` denotes the final value\n    # of this parameter, and Δt denotes its increment in each step\n    Tf = 2.0;\n    Δt = 0.1;\n    NEWTON_TOL = 1e-8\n\n    pvd = paraview_collection(\"hyperelasticity_incomp_mixed.pvd\");\n    for t ∈ 0.0:Δt:Tf\n        # Perform Newton iterations\n        Ferrite.update!(dbc, t)\n        apply!(w, dbc)\n        newton_itr = -1\n        prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving @ time $t of $Tf;\")\n        fill!(ΔΔw, 0.0);\n        while true; newton_itr += 1\n            assemble_global!(K, f, cellvalues_u, cellvalues_p, dh, mp, w)\n            norm_res = norm(f[Ferrite.free_dofs(dbc)])\n            apply_zero!(K, f, dbc)\n            # Only display output at specific load steps\n            if t%(5*Δt) == 0\n                ProgressMeter.update!(prog, norm_res; showvalues = [(:iter, newton_itr)])\n            end\n            if norm_res < NEWTON_TOL\n                break\n            elseif newton_itr > 30\n                error(\"Reached maximum Newton iterations, aborting\")\n            end\n            # Compute the incremental `dof`-vector (both displacement and pressure)\n            ΔΔw .= K\\f;\n\n            apply_zero!(ΔΔw, dbc)\n            w .-= ΔΔw\n        end;\n\n        # Save the solution fields\n        vtk_grid(\"hyperelasticity_incomp_mixed_$t.vtu\", dh, compress=false) do vtkfile\n            vtk_point_data(vtkfile, dh, w)\n            vtk_save(vtkfile)\n            pvd[t] = vtkfile\n        end\n    end;\n    vtk_save(pvd);\n    vol_def = calculate_volume_deformed_mesh(w, dh, cellvalues_u);\n    print(\"Deformed volume is $vol_def\")\n    return vol_def;\nend;\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We can now test the solution using the Taylor-Hood approximation","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"quadratic = Lagrange{3, RefTetrahedron, 2}()\nlinear = Lagrange{3, RefTetrahedron, 1}()\nvol_def = solve(quadratic, linear);\nnothing #hide","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"We can also check that the deformed volume is indeed close to 1 (as should be for a nearly incompressible material)","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/#Plain-Program","page":"Nearly Incompressible Hyperelasticity","title":"Plain Program","text":"","category":"section"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"Below follows a version of the program without any comments. The file is also available here: quasi_incompressible_hyperelasticity.jl","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"using Ferrite, Tensors, ProgressMeter\nusing BlockArrays, SparseArrays, LinearAlgebra\n\nstruct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction importTestGrid()\n    grid = generate_grid(Tetrahedron, (5, 5, 5), zero(Vec{3}), ones(Vec{3}));\n    addfaceset!(grid, \"myBottom\", x -> norm(x[2]) ≈ 0.0);\n    addfaceset!(grid, \"myBack\", x -> norm(x[3]) ≈ 0.0);\n    addfaceset!(grid, \"myRight\", x -> norm(x[1]) ≈ 1.0);\n    addfaceset!(grid, \"myLeft\", x -> norm(x[1]) ≈ 0.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(4)\n    face_qr = QuadratureRule{2,RefTetrahedron}(4)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction Ψ(F, p, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(tdot(F))\n    J = det(F)\n    Js = (λ + p + sqrt((λ + p)^2. + 4. * λ * μ ))/(2. * λ)\n    return p * (Js - J) + μ / 2 * (Ic - 3) - μ * log(Js) + λ / 2 * (Js - 1)^2\nend;\n\nfunction constitutive_driver(F, p, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂F², ∂Ψ∂F = Tensors.hessian(y -> Ψ(y, p, mp), F, :all)\n    ∂²Ψ∂p², ∂Ψ∂p = Tensors.hessian(y -> Ψ(F, y, mp), p, :all)\n    ∂²Ψ∂F∂p = Tensors.gradient(q -> Tensors.gradient(y -> Ψ(y, q, mp), F), p)\n    return ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 3, ipu) # displacement dim = 3\n    push!(dh, :p, 1, ipp) # pressure dim = 1\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myLeft\"), (x,t) -> zero(Vec{1}), [1]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBottom\"), (x,t) -> zero(Vec{1}), [2]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myBack\"), (x,t) -> zero(Vec{1}), [3]))\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"myRight\"), (x,t) -> t*ones(Vec{1}), [1]))\n    close!(dbc)\n    Ferrite.update!(dbc, 0.0)\n    return dbc\nend;\n\nfunction calculate_element_volume(cell, cellvalues_u, ue)\n    reinit!(cellvalues_u, cell)\n    evol::Float64=0.0;\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        F = one(∇u) + ∇u\n        J = det(F)\n        evol += J * dΩ\n    end\n    return evol\nend;\n\nfunction calculate_volume_deformed_mesh(w, dh::DofHandler, cellvalues_u)\n    evol::Float64 = 0.0;\n    @inbounds for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        nu = getnbasefunctions(cellvalues_u)\n        global_dofs_u = global_dofs[1:nu]\n        ue = w[global_dofs_u]\n        δevol = calculate_element_volume(cell, cellvalues_u, ue)\n        evol += δevol;\n    end\n    return evol\nend;\n\nfunction assemble_element!(Ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n    # Reinitialize cell values, and reset output arrays\n    ublock, pblock = 1, 2\n    reinit!(cellvalues_u, cell)\n    reinit!(cellvalues_p, cell)\n    fill!(Ke, 0.0)\n    fill!(fe, 0.0)\n\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n\n    @inbounds for qp in 1:getnquadpoints(cellvalues_u)\n        dΩ = getdetJdV(cellvalues_u, qp)\n        # Compute deformation gradient F\n        ∇u = function_gradient(cellvalues_u, qp, ue)\n        p = function_value(cellvalues_p, qp, pe)\n        F = one(∇u) + ∇u\n\n        # Compute first Piola-Kirchhoff stress and tangent modulus\n        ∂Ψ∂F, ∂²Ψ∂F², ∂Ψ∂p, ∂²Ψ∂p², ∂²Ψ∂F∂p = constitutive_driver(F, p, mp)\n\n        # Loop over the `u`-test functions to calculate the `u`-`u` and `u`-`p` blocks\n        for i in 1:n_basefuncs_u\n            # gradient of the test function\n            ∇δui = shape_gradient(cellvalues_u, qp, i)\n            # Add contribution to the residual from this test function\n            fe[BlockIndex((ublock), (i))] += ( ∇δui ⊡ ∂Ψ∂F) * dΩ\n\n            ∇δui∂S∂F = ∇δui ⊡ ∂²Ψ∂F²\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, ublock), (i, j))] += ( ∇δui∂S∂F ⊡ ∇δuj ) * dΩ\n            end\n            # Loop over the `p`-test functions\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                # Add contribution to the tangent\n                Ke[BlockIndex((ublock, pblock), (i, j))] += ( ∂²Ψ∂F∂p ⊡ ∇δui ) * δp * dΩ\n            end\n        end\n        # Loop over the `p`-test functions to calculate the `p-`u` and `p`-`p` blocks\n        for i in 1:n_basefuncs_p\n            δp = shape_value(cellvalues_p, qp, i)\n            fe[BlockIndex((pblock), (i))] += ( δp * ∂Ψ∂p) * dΩ\n\n            for j in 1:n_basefuncs_u\n                ∇δuj = shape_gradient(cellvalues_u, qp, j)\n                Ke[BlockIndex((pblock, ublock), (i, j))] += ∇δuj ⊡ ∂²Ψ∂F∂p * δp * dΩ\n            end\n            for j in 1:n_basefuncs_p\n                δp = shape_value(cellvalues_p, qp, j)\n                Ke[BlockIndex((pblock, pblock), (i, j))] += δp * ∂²Ψ∂p² * δp * dΩ\n            end\n        end\n    end\nend;\n\nfunction assemble_global!(K::SparseMatrixCSC, f, cellvalues_u::CellVectorValues{dim},\n                         cellvalues_p::CellScalarValues{dim}, dh::DofHandler, mp::NeoHooke, w) where {dim}\n    nu = getnbasefunctions(cellvalues_u)\n    np = getnbasefunctions(cellvalues_p)\n\n    # start_assemble resets K and f\n    fe = PseudoBlockArray(zeros(nu + np), [nu, np]) # local force vector\n    ke = PseudoBlockArray(zeros(nu + np, nu + np), [nu, np], [nu, np]) # local stiffness matrix\n\n    assembler = start_assemble(K, f)\n    # Loop over all cells in the grid\n    for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        global_dofsu = global_dofs[1:nu]; # first nu dofs are displacement\n        global_dofsp = global_dofs[nu + 1:end]; # last np dofs are pressure\n        @assert size(global_dofs, 1) == nu + np # sanity check\n        ue = w[global_dofsu] # displacement dofs for the current cell\n        pe = w[global_dofsp] # pressure dofs for the current cell\n        assemble_element!(ke, fe, cell, cellvalues_u, cellvalues_p, mp, ue, pe)\n        assemble!(assembler, global_dofs, fe, ke)\n    end\nend;\n\nfunction solve(interpolation_u, interpolation_p)\n\n    # import the mesh\n    grid = importTestGrid()\n\n    # Material parameters\n    μ = 1.\n    λ = 1.E4 * μ\n    mp = NeoHooke(μ, λ)\n\n    # Create the DofHandler and CellValues\n    dh = create_dofhandler(grid, interpolation_u, interpolation_p)\n    cellvalues_u, cellvalues_p, facevalues_u = create_values(interpolation_u, interpolation_p)\n\n    # Create the DirichletBCs\n    dbc = create_bc(dh)\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    w  = zeros(_ndofs)\n    ΔΔw = zeros(_ndofs)\n    apply!(w, dbc)\n\n    # Create the sparse matrix and residual vector\n    K = create_sparsity_pattern(dh)\n    f = zeros(_ndofs)\n\n    # We run the simulation parameterized by a time like parameter. `Tf` denotes the final value\n    # of this parameter, and Δt denotes its increment in each step\n    Tf = 2.0;\n    Δt = 0.1;\n    NEWTON_TOL = 1e-8\n\n    pvd = paraview_collection(\"hyperelasticity_incomp_mixed.pvd\");\n    for t ∈ 0.0:Δt:Tf\n        # Perform Newton iterations\n        Ferrite.update!(dbc, t)\n        apply!(w, dbc)\n        newton_itr = -1\n        prog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving @ time $t of $Tf;\")\n        fill!(ΔΔw, 0.0);\n        while true; newton_itr += 1\n            assemble_global!(K, f, cellvalues_u, cellvalues_p, dh, mp, w)\n            norm_res = norm(f[Ferrite.free_dofs(dbc)])\n            apply_zero!(K, f, dbc)\n            # Only display output at specific load steps\n            if t%(5*Δt) == 0\n                ProgressMeter.update!(prog, norm_res; showvalues = [(:iter, newton_itr)])\n            end\n            if norm_res < NEWTON_TOL\n                break\n            elseif newton_itr > 30\n                error(\"Reached maximum Newton iterations, aborting\")\n            end\n            # Compute the incremental `dof`-vector (both displacement and pressure)\n            ΔΔw .= K\\f;\n\n            apply_zero!(ΔΔw, dbc)\n            w .-= ΔΔw\n        end;\n\n        # Save the solution fields\n        vtk_grid(\"hyperelasticity_incomp_mixed_$t.vtu\", dh, compress=false) do vtkfile\n            vtk_point_data(vtkfile, dh, w)\n            vtk_save(vtkfile)\n            pvd[t] = vtkfile\n        end\n    end;\n    vtk_save(pvd);\n    vol_def = calculate_volume_deformed_mesh(w, dh, cellvalues_u);\n    print(\"Deformed volume is $vol_def\")\n    return vol_def;\nend;\n\nquadratic = Lagrange{3, RefTetrahedron, 2}()\nlinear = Lagrange{3, RefTetrahedron, 1}()\nvol_def = solve(quadratic, linear);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"","category":"page"},{"location":"examples/quasi_incompressible_hyperelasticity/","page":"Nearly Incompressible Hyperelasticity","title":"Nearly Incompressible Hyperelasticity","text":"This page was generated using Literate.jl.","category":"page"}]
}
